[{"title":"两数之和II-输入有序数组","url":"/2022/09/10/两数之和II-输入有序数组/","content":"\n# 问题描述：\n\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n你所设计的解决方案必须只使用常量级的额外空间。\n\n---\n\n# 例子\n\n示例 1：\n\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n示例 2：\n\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n示例 3：\n\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n\n---\n# 提示：\n\n - 2 <= numbers.length <= 3 * 104\n- -1000 <= numbers[i] <= 1000\n- numbers 按 非递减顺序 排列\n- -1000 <= target <= 1000\n- 仅存在一个有效答案\n\n---\n\n\n# 代码实现：\n## 1.双指针：\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n       int left =0;\n       int rigth=numbers.length-1;\n       while(left<rigth){\n           if(numbers[left]+numbers[rigth]==target){\n               return new int []{left+1,rigth+1};\n           }else if(numbers[left]+numbers[rigth]<target){\n               left++;\n           }else rigth--;\n       }\n       return new int[]{};\n    }\n}\n```\n## 2.二分：\n`使用二分时我发现会超时，但是暴力求解不会`\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        for(int i=0;i<numbers.length-1;i++){\n          int left =i+1;\n          int rigth=numbers.length-1;\n          while(left<=rigth){\n               int mid=left+((rigth-left)>>1);\n           if(numbers[mid]==target-numbers[i])return new int[]{i+1,mid+1};\n           else if (numbers[mid] > target - numbers[i]){\n              rigth=mid-1; \n           }\n           else rigth=mid+1;\n           }\n        }\n       return new int[]{-1,-1};\n    }\n}\n\n```\n\n## 3.暴力求解\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int temp2[]=new int[2];\n        for(int i=0;i<numbers.length;i++){\n            int temp=target-numbers[i];\n            for(int j=i+1;j<numbers.length;j++){\n               if(numbers[j]==temp){\n                   temp2[0]=i+1;\n                   temp2[1]=j+1;\n                   return temp2;\n               }\n            }\n        }\n        return temp2;\n    }\n}\n\n```\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)\n","tags":["算法","数组","简单","offer","力扣"],"categories":["算法","力扣"]},{"title":"一些JS的插件库","url":"/2022/09/10/js插件库/","content":"\n1、[airbnb](https://github.com/airbnb)/[lottie-web](https://github.com/airbnb/lottie-web)*\n\n一个可以从Adobe After Effects中创建的动画直接导出到你的网站。\n\n适用于Lottie for Web，[Android](https://github.com/airbnb/lottie-android)，[iOS](https://github.com/airbnb/lottie-ios)，[React Native](https://github.com/airbnb/lottie-react-native)和[Windows。](https://aka.ms/lottie)\n\n例子：\n\n![Example4.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example4.gif?raw=true)\n\n![Example2.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example2.gif?raw=true)\n\n\n\n![Community 2_3.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Community%202_3.gif?raw=true)\n\n2、[wagerfield](https://github.com/wagerfield)/**[parallax](https://github.com/wagerfield/parallax)**\n\n一个轻量级视差渲染JS库，可以创建视察效果，用鼠标来控制，还可以调整物体移动速度。\n\n示例网站：[parallax.js (wagerfield.com)](http://matthew.wagerfield.com/parallax/)\n\n\n\n3、[e-oj](https://github.com/e-oj)/**[Magic-Grid](https://github.com/e-oj/Magic-Grid)**\n\n一个简单、轻量级的 Javascript 库，用于动态网格布局\n\n效果：\n\n![Magic-Gridv](http://imgconvert.csdnimg.cn/aHR0cHM6Ly92dWVqc2V4YW1wbGVzLmNvbS9jb250ZW50L2ltYWdlcy8yMDE5LzAxL01hZ2ljLUdyaWR2LmdpZg)\n\n\n\n4、[webslides](https://github.com/webslides)/**[WebSlides](https://github.com/webslides/WebSlides)**\n\n以漂亮的方式制作HTML演示文稿\n\n演示网站：https://webslides.tv/demos.\n\n\n\n5、[svgdotjs](https://github.com/svgdotjs)/**[svg.js](https://github.com/svgdotjs/svg.js)**\n\n用于操作 SVG 和制作动画的轻量级库，无需任何依赖项。\n\n\n\n6、[dixonandmoe](https://github.com/dixonandmoe)/**[rellax](https://github.com/dixonandmoe/rellax)**\n\n是一个超轻量级，JavaScript视差库。Rellax 现在可以在移动设备上工作 \n\n效果网站：[Demo Website](https://dixonandmoe.com/rellax/)\n\n\n\n7、[Dynamics.js (dynamicsjs.com)](http://dynamicsjs.com/)\n\n用于创建基于物理的动画\n\n\n\n\n\n8、[mojs](https://github.com/mojs)/**[mojs](https://github.com/mojs/mojs)**\n\n用于 Web 的运动图形工具\n\n演示网址：[mo.js](https://mojs.github.io/)\n\n\n\n9、[metafizzy](https://github.com/metafizzy)/**[zdog](https://github.com/metafizzy/zdog)**\n\n圆形，平面，设计师友好的伪3D引擎，用于canvas和SVG\n\n官网：[Zdog · Round, flat, designer-friendly pseudo-3D engine for canvas and SVG (zzz.dog)](https://zzz.dog/)\n\n\n\n10、[leader-line-vue](https://www.npmjs.com/package/leader-line-vue)\n\n用来画引导线\n\n![前020](https://raw.githubusercontent.com/anseki/leader-line/HEAD/img/ex-020.gif)\n","tags":["前端","JS","插件"],"categories":["JS","前端"]},{"title":"Vue的生命周期，各个组件间的执行情况","url":"/2022/09/10/Vue生命周期及各组件间的执行情况/","content":"\n\n\n---\n\n# 前言\n\n\nVue的生命周期，各个组件间的执行情况。\n`注：本文是以Vue2.x版本展开叙述`\n\n\n---\n\n\n# 一、Vue的生命周期是什么？\nVue的组件都是独立存在的，每个组件都要经历他自己的`生命周期`。Vue的生命周期是指组件：\n**创建**--->**数据初始化**--->**挂载**--->**更新**--->**销毁**\n简单的来说就是组件从创建到销毁之间的过程\n\n\n# 二、Vue生命周期中具体过程\n## 1.Vue生命周期中的函数\n**生命周期钩子**也叫**生命周期函数**也叫**生命周期事件**，vue中他自己携带了八个生命周期函数，如下：\n### 创建Vue实例期阶段：\n\n - **beforeCreate：**\n 实例刚在内存中被创建出来，此时，还没有初始化完成data和methods属性。\n\n- **created：**\n实例已经在内存中创建完成，此时data和menthods以及创建完成，但没有开始编译模板。\n- **beforeMount：**\n此时完成了模板的编译，但没有进行挂载。\n- **mounted：**\n此时已经完成挂载到指定容器中显示了。\n### 运行阶段：\n- **beforeUpdate：**\n状态更新之前调用此函数，此时data中的状态值是最新的，但在界面上并没有得到更新，还没有开始重新渲染DOM节点。\n- **updated：**\n实例更新完成后调用此函数，此时以及重新渲染好DOM节点，界面显示数据也是最新的。\n### 销毁阶段：\n- **beforeDestroy：**\n实例 销毁前调用的函数，此时，实力还是完全可用的。\n- **destroyed：**\n实例销毁后调用，实例锁指示的所有东西都将解绑，所有监听器将移除，所有子实例也将销毁。\n>生命周期流程图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/27c2330b888345dba3fec82144bb8306.png#pic_center)\n\n\n>代码演示：\n\n```c\n var app = new Vue({\n        el: \"#app\",\n        data: {\n            message: \"Hello Vue!\"\n        },\n        methods: {\n            changeMessage() {\n                this.message='改变了！'\n            }\n        },\n        beforeCreate() {\n            console.log(\"---------- 初始化前 beforeCreate-----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n            \n        },\n        created() {\n            console.log(\"---------- 初始化完成 created----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeMount() {\n            console.log(\"---------- 挂载前 beforeMount----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        mounted() {\n            console.log(\"---------- 挂载完成 mounted----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeUpdate() {\n            console.log(\"---------- 更新前 beforeUpdate----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        updated() {\n            console.log(\"---------- 更新完成 updated----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        }\n    });\n```\n>创建阶段运行结果：\n>\n![](https://img-blog.csdnimg.cn/d3c052cebaad48329c13c55b72f25f23.png)\n**可以看到首次加载只会运行前四个周期函数，在挂载前才能拿到el属性，如果要操作DOM节点最早在挂在完成 mounted中操作。**\n>运行阶段运行结果：\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b1907c6374949568f14cccd17df1bbe.png)\n## 2.加入keep-alive后\n### 1）keep-alive的认识：\n\n是vue自带的内部组件，是用**来缓存组件**的，达到**提升性能**的目的。\n当使用keep-alive后会增加两个生命周期函数：\n- activated\n在 **keep-alive 组件激活**时调用， 该钩子函数在**服务器端渲染期间**不被调用。\n承担原来**created**钩子中获取数据的任务\n在第一次进入keep-alive包裹的组件时，会调用 beforeCreate、created、beforeMount、mounted、activated；这五个生命周期函数。\n当第二次或第n次进入时只会调用activated\n\n- deactivated\n在 keep-alive 组件停用时调用，该钩子在服务器端渲染期间不被调用。\n\n### 2）keep-alive的用法：\nProps有三个include、exclude、max。\n  - include\n  使用字符串或者正则表达式，匹配的组件才会被缓存\n  - exclude\n  使用字符串或者正则表达式，匹配的组件都不会被缓存\n  - max\n  以数字的形式记录可以缓存多少个组件实例，到达这个值后再次缓存时将销毁最久未使用的组件实例。\n\n# 各组件间的执行情况\n## 1.加载渲染过程\n\n>过程：\n>**父组件beforeCreate** --> **父组件created** --> **父组件beforeMount** --> **子组件beforeCreate** --> **子组件created** --> **子组件beforeMount** --> **子组件mounted** --> **父组件mounted**\n## 2.子组件更新过程\n>过程：\n> **子组件beforeUpdate**  -->  **子组件updated**  \n## 3.父组件更新过程\n>**父组件beforeUpdate**  -->  **父组件updated**\n## 4.组件销毁过程\n>**父组件beforeDestroy** --> **子组件beforeDestroy** --> **子组件destroyed** --> **父组件destroyed**\n## 5.过程演示\n> 父组件代码\n\n```javascript\n<template>\n  <div style=\"border: 2px #1E1E1E; height: 500px;width: 500px;background-color: blueviolet; text-align: center\">\n    <span>{{message}}</span>\n    <button @click=\"changef\" >父组件改变</button>\n    <Son></Son>\n    <button @click=\"destroy\">点击销毁</button>\n  </div>\n</template>\n\n<script>\nimport Son from './components/Son.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    Son\n  },\n  data() {\n    return {\n      message: \"父组件\"\n    }\n  },\n  methods: {\n    changef(){\n      this.message='父组件改变了'\n    },\n    destroy(){\n      this.$destroy();\n      console.log('销毁完成');\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 父组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 父组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 父组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 父组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 父组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 父组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 父组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 父组件销毁后 destroyed----------')\n  }\n}\n</script>\n\n```\n> 子组件代码\n\n```javascript\n<template>\n  <div>\n    <div style=\"border: 2px #1E1E1E; height: 200px;width:200px;background-color: aqua;\">\n      <span>{{message}}</span>\n      <button @click=\"changes\">子组件改变</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  // eslint-disable-next-line vue/multi-word-component-names\n  name: 'Son',\n  props: {\n\n  },\n  data() {\n    return {\n      message: \"子组件\"\n    }\n  },\n  methods: {\n    changes(){\n      this.message='子组件改变了'\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 子组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 子组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 子组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 子组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 子组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 子组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 子组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 子组件销毁后 destroyed----------')\n  }\n}\n</script>\n```\n\n>加载渲染：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1e0fc120774141659a13fc399163e525.png)\n\n>更新阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/1dbd838712ba4a6cbbb50f8b26c45ef9.png)\n\n>销毁阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/11c316d9bff44e798c70517f11209b53.png)\n# 总结\n - 生命周期：\n   - 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n    -   是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n    -   生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n     -  生命周期函数中的this指向是vm 或 组件实例对象。\n ---\n- 常用的生命周期钩子：\n   -  mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n   - beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n   \n---\n- 关于销毁Vue实例：\n   - 销毁后借助Vue开发者工具看不到任何信息。\n   - 销毁后自定义事件会失效，但原生DOM事件依然有效。\n   - 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n","tags":["Vue","生命周期","组件"],"categories":["Vue"]}]