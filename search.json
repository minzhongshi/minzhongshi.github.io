[{"title":"网络-navigator.sendBeacon","url":"/2023/10/11/网络-navigator.sendBeacon/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录navigator.sendBeacon异步请求的使用，以及应用场景和埋点小demo。\n\n---\n\n\n\n# 一、navigator.sendBeacon是什么？\n>`navigator.sendBeacon` 是一个浏览器 API，用于在浏览器后台发送异步请求,不会等服务端响应。\n它可以用于在页面卸载或关闭时发送数据，以及在不阻塞页面卸载的情况下发送数据。\n使用 `navigator.sendBeacon` 方法发送的请求是异步的，不会阻塞页面的卸载或关闭过程。\n这对于需要在用户离开页面之前发送数据的情况非常有用。\n\n## 优点\n- 不受页面卸载过程的影响，确保数据可靠发送\n普通的`http`请求如`XMLHttpRequest `和`Fetch`在页面关闭或者刷新、前进、后退等操作时这些请求有可能在页面销毁之前没有完成，导致数据丢失。也可以控制页面销毁延后，这就导致页面销毁时间增加。\n-   异步执行，不阻塞页面关闭或者跳转\n`navigator.sendBeacon`的优先级是较低的，`XMLHttpRequest `和`Fetch`这些同步请求，以及其他高优先级任务在它之前，`navigator.sendBeacon`并不会立即执行，可以说它会在空闲时间发送请求。\n -  能够发送跨域请求\n`navigator.sendBeacon`是不受跨域限制的\n## 缺点\n- 只能发送POST请求\n- 只能传输少量数据（64 KB以内）\n-   无法自定义请求头\n -  只能传输`ArrayBuffer`、`ArrayBufferView`、`Blob`、`DOMString`、`FormData`或`URLSearchParams`类型数据\n -  如果处于危险网络环境、开启了广告屏蔽插件 该请求将无效\n\n# 二、navigator.sendBeacon应用场景\n\n- 发送心跳包\n利用`navigator.sendBeacon`发送心跳包，与服务器保持长连接，避免长时间未请求而断开连接。\n\n```javascript\nfunction sendHeartbeat() {\n  const data = 'heartbeat'; // 心跳包数据\n  const url = 'http://localhost:3001/api/heartbeat'; // 心跳包目标 URL\n\n  navigator.sendBeacon(url, data);\n}\n\n// 每隔一定时间发送心跳包\nsetInterval(sendHeartbeat, 5000); // 每 5 秒发送一次心跳包\n```\n![心跳](https://img-blog.csdnimg.cn/4c72c52a639544c0912086181f714f0d.gif)\n\n\n -  埋点\n 可以使用`navigator.sendBeacon`在页面卸载时记录停留时间，以及pv、uv、错误日志的上报、按钮点击次数等\n -  用户反馈\n 对于一些小的表单，如：用户反馈、意见和建议等可以使用`navigator.sendBeacon`进行请求。\n ![反馈](https://img-blog.csdnimg.cn/bf0f586b617c48e580f1b1021a2a1f52.png#pic_center =300x500)\n\n\n# 三、navigator.sendBeacon的使用\n>基本语法如下：\n\n```javascript\nnavigator.sendBeacon(url, data);\n```\n- url： 是要发送请求的目标地址，可以是相对路径或绝对 URL。\n- data： 是要发送的数据，可以是字符串、ArrayBuffer 或 Blob。\n\n`navigator.sendBeacon 方法发送的请求是 POST 请求，并且请求头中会自动添加 Content-Type: application/x-www-form-urlencoded。`\n\n需要发送JSON格式的数据的时候，可以使用Blob进行包装从而发送JSON数据\n\n```javascript\nlet data = {name:\"smz\"}\nlet blob = new Blob([JSON.stringify(data)],{type:'application/json; charset=UTF-8'})\n```\n\n# 四、用户停留时间埋点\n\n当打开页面时记录时间，在页面销毁的时候记录时间，这样就得到了用户停留时间，再通过`navigator.sendBeacon`进行上报用户名、时间、页面等信息完成数据的统计。\n\n>前端：\n\n```javascript\nconst reportData = () =>{\n    //统计停留时间\n    let startTime = performance.now(); // 进入页面的时间点\n    let logVisit = async function() {\n        if (!navigator.sendBeacon) return false;\n\n        const endTime = performance.now(); // 页面卸载的时间点\n\n        let data = new FormData();\n        const reportDataList = {\n            name: 'smz',\n            page: 'home',\n            stayTime: ((endTime - startTime)/60000).toFixed(2) + '分钟' // 用户停留时间\n        };\n        let time = new Blob([JSON.stringify(reportDataList)],{type:'application/json; charset=UTF-8'})\n        navigator.sendBeacon(\"http://localhost:3001/api/b\", time);\n    };\n    window.addEventListener(\"beforeunload\", logVisit);\n}\nreportData()\n```\n\n>后端：这里使用node\n\n```javascript\nconst express = require('express')\nconst app = express()\n\napp.use((req, res, next) => {\n    res.setHeader('Access-Control-Allow-Origin', 'http://localhost:63342');\n    res.setHeader('Access-Control-Allow-Credentials', true);\n    res.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type,XFILENAME,XFILECATEGORY,XFILESIZE\");\n    next();\n});\n\n// 解析req.body中的内容\napp.use(express.text())\n// 心跳包\napp.post('/api/heartbeat',(req,res)=>{\n    console.log(req.body)\n    res.send('ok')\n})\n\n// 解析req.body中的内容\napp.use(express.json())\n\n// navigator.sendBeacon\napp.post('/api/b',(req,res)=>{\n    console.log(req.body)\n    res.send('ok')\n})\n\napp.listen(3001,()=>{\n    console.log('server is running')\n})\n```\n\n![用户停留时间埋点](https://img-blog.csdnimg.cn/926a1d413fc9419096672acce2429dae.gif)\n\n\n---\n\n# 总结\n总之，navigator.sendBeacon 是一个方便的浏览器 API，用于在页面卸载或关闭时发送异步请求，适用于发送统计数据、日志记录、表单提交等场景。\n\n","tags":["网络","navigator.sendBeacon","异步请求","埋点","日志"],"categories":["网络","navigator.sendBeacon","异步请求"]},{"title":"网络-SSE","url":"/2023/10/03/网络-SSE/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录SSE通讯的简介、使用、以及原理和一个ChatGPT返回数据的demo。\n\n---\n\n\n\n# 一、SSE简介\nSSE（Server-Sent Events，服务器推送事件）是一种用于在浏览器和服务器之间实现实时、单向通信的Web技术。它允许服务器向客户端推送数据，而无需客户端发起请求。与传统的HTTP请求-响应模式不同，SSE建立了一种持久的连接，通过这个连接，服务器可以随时向客户端发送更新的数据。这种实时通信的方式非常适用于需要实时更新数据的应用，如聊天应用、股票行情、实时监控等。\n\n\n\n\n## 1、SSE特点\n- 简单易用：SSE使用简单的API，只需要创建`EventSource`对象并监听事件即可实现实时通信。\n- 单向通信：SSE是一种单向通信方式，只允许服务器向客户端推送数据，而不支持客户端向服务器发送请求。\n- 实时性：SSE建立了持久连接，服务器可以随时向客户端发送更新的数据，实现实时的数据推送。\n- 自动重连：如果连接中断，SSE会自动尝试重新建立连接，确保持久连接的稳定性。\n- 支持事件流：SSE使用事件流（event stream）的格式来传输数据，可以发送不同类型的事件，方便客户端进行处理。\n\n需要注意的是，SSE在一些旧版本的浏览器中可能不被完全支持。但是，大多数现代浏览器都支持SSE，并且可以通过`Polyfill`来提供兼容性支持。\n\n  ### Polyfill\n  \n>Polyfill是一种用于填充浏览器或环境中缺少的功能或API的代码。它可以在旧版本的浏览器或不支持某些新特性的环境中，提供对这些功能的兼容性支持。当新的Web标准或API被引入时，不同的浏览器或环境可能会以不同的速度进行支持和实现。在这种情况下，开发人员可以使用Polyfill来填充这些缺失的功能。\n\n>Polyfill通常是一个JavaScript库或脚本，它通过在运行时检测浏览器或环境的功能支持情况，然后根据需要动态地添加缺失的功能或API的实现。例如，如果某个浏览器不支持ES6的新特性，如箭头函数、模板字符串等，开发人员可以使用相应的Polyfill来提供对这些特性的支持。Polyfill会检测浏览器是否支持这些特性，如果不支持，则在运行时添加相应的代码来实现这些特性。\n\n>需要注意的是，Polyfill并不是一种通用的解决方案，它可能会增加页面的加载时间和代码体积。因此，在使用Polyfill时，需要根据具体的需求和目标浏览器进行选择和优化。\n\n## 2、SSE原理\n- 客户端通过创建一个`EventSource`对象来与服务器建立连接。\n- 服务器通过发送特定格式的事件流（event stream）数据，将数据推送给客户端。\n- 客户端通过监听EventSource对象的事件，如`message`事件，来接收服务器发送的数据。\n- 服务器可以根据需要发送不同类型的事件，如`message`事件、`open`事件、`error`事件等。\n\n## 3、SSE技术实现：\nSSE基于HTTP协议，利用其长连接特性，通过浏览器向服务器发送一个HTTP请求，建立一条持久化连接。\n\n## 4、SSE应用场景：\n- 实时数据大屏（这种不需要客户端做操作的，只需要服务端将数据不断给客户端，并且需要长时间连接，并不一定需要`WebSocket`）\n- chatGPT 返回数据\n\n## 5、EventSource\n`EventSource`是HTML5中的一个API，用于在客户端与服务器之间建立基于HTTP的单向通信。\n# 二、SSE使用\n## 1、前端\n- 创建`EventSource`对象：\n      在客户端的JavaScript代码中，使用`new EventSource(url，options)`来创建一个`EventSource`对象.\n     -  其中url是服务器端的URL,必填。\n     -  `options`是配置项可选参数`Object`类型，常用配置包括：\n        -  `withCredentials`:`Boolean`类型，标识是否允许发送`Coolie`和`HTTP`认证信息。默认`false`\n        - `headers`:`Object`类型，标识发送的请求头信息。\n        - `retryInterval`:`Number`类型，标识与服务器失去连接后，重连时间间隔。默认1000毫秒\n```javascript\n const sse = new EventSource('http://localhost:3000/api/sse',{\n                withCredentials:false,\n                headers:{},\n                retryInterval: 1000\n            })\n```\n\n- 监听事件：\n      通过为EventSource对象添加事件监听器，如onmessage、onopen、onerror等，来处理服务器发送的事件。\n     -  `onmessage`：表示已经收到服务端数据。\n     -  `onopen`：表示已经建立了连接，并开始接收服务端数据。当后端没有定义返回的事件，默认是该事件。\n     - `onerror`：表示建立连接或接收数据时发生错误。\n- 接收事件：\n      当服务器发送事件流数据时，`EventSource`对象会触发相应的事件，客户端可以通过事件监听器来接收和处理这些事件。\n  \n\n```javascript\n sse.onopen = (e) =>{\n                console.log('连接成功', e)\n            }\n            sse.onmessage = (e) =>{\n                console.log('接收到数据', e)\n            }\n            sse.onerror= (e) =>{\n                console.log('发生错误',e)\n            }\n            sse.addEventListener('message',(e)=>{\n                const span = document.getElementById('animate')\n                span.remove()\n                message.innerHTML += `${e.data}<span id=\"animate\">|</span>`\n            })\n```\n\n- 关闭连接：\n      如果不再需要与服务器保持连接，可以调用`EventSource`对象的`close()`方法来关闭连接。\n```javascript\nstop.addEventListener('click',(e)=>{\n                console.log('断开连接',e)\n                sse.close()\n            })\n```\n\n## 2、后端\n后端必须设置响应头  `'Content-Type': 'text/event-stream'`，然后其他就和普通get请求一样。\n\n后端是可以设置事件名称的，返回event 表示定义事件名称\n\n```javascript\nres.write(`event:dg\\n`)\n```\n\n\n## 3、完整代码\n   ### 前端\n   \n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<style>\n    .box{\n        height: 100vh;\n        width: 100%;\n        background: #1B1A22;\n    }\n    #message{\n        color: white;\n    }\n    #animate{\n        display: inline-block;\n        padding:0 5px;\n        font-size:20px;\n        font-weight: bold;\n        animation: fade 1s infinite forwards;\n    }\n    @keyframes fade {\n        from{\n            opacity: 0;\n        }\n        to {\n            opacity: 1;\n        }\n    }\n</style>\n<body>\n<div>\n    <div class=\"box\">\n        <div id=\"message\"><span id=\"animate\">|</span></div>\n        <div style=\"margin-top: 30px\"><button id=\"stop\">断开连接</button></div>\n    </div>\n</div>\n</body>\n<script>\n    const message = document.getElementById('message')\n    const stop = document.getElementById('stop')\n    document.addEventListener('keydown',(e)=>{\n        if (e.keyCode == 13){\n            const sse = new EventSource('http://localhost:3000/api/sse',{\n                withCredentials:false,\n                headers:{},\n                retryInterval: 1000\n            })\n            sse.onopen = (e) =>{\n                console.log('连接成功', e)\n            }\n            sse.onmessage = (e) =>{\n                console.log('接收到数据', e)\n            }\n            sse.onerror= (e) =>{\n                console.log('发生错误',e)\n            }\n            sse.addEventListener('message',(e)=>{\n                const span = document.getElementById('animate')\n                span.remove()\n                message.innerHTML += `${e.data}<span id=\"animate\">|</span>`\n            })\n            stop.addEventListener('click',(e)=>{\n                console.log('断开连接',e)\n                sse.close()\n            })\n\n        }\n    })\n\n</script>\n</html>\n```\n   ### 后端\n这里后端用Node\n\n```javascript\napp.get('/api/sse',(req,res)=>{\n    res.writeHead(200,{\n        'Content-Type': 'text/event-stream',\n        'Access-Control-Allow-Origin': '*'\n    })\n    // 读取本地文件\n    const txt =  fs.readFileSync('../SSE/index.txt','utf8')\n    // 分割成字符数组\n    const arr = txt.split('')\n    let currnet = 0\n    let timer = setInterval(()=>{\n        if (currnet < arr.length){\n            // 设置返回事件名称\n            // res.write(`event:dg\\n`)\n            res.write(`data:${arr[currnet]}\\n\\n`)\n            currnet++\n        }else{\n            clearTimeout(timer)\n        }\n    },300)\n\n})\n```\n\n   ![SSE](https://img-blog.csdnimg.cn/4c3b371275cc41ffacf4419314890b9c.gif)\n\n`注:`\n`SSE是服务端主动向客户端发送数据，在客户端发送连接数据连接后，客户端就不能再向服务端发送数据了，只能服务端给客户端发送数据，这是因为SSE是单工通讯的。`\n\n`只接受get请求`\n\n`服务端没有设置正确的响应头信息，可能导致无法接收数据`\n\n\n---\n\n# 总结\n\n总的来说，SSE是一种简单、实时的通信技术，适用于需要实时推送数据的应用场景，提供了一种有效的方式来实现服务器向客户端的实时通信。\n\n","tags":["网络","SSE","EventSource","ChatGPT","实时数据大屏","单工通讯"],"categories":["网络","SSE"]},{"title":"网络-fetch","url":"/2023/10/02/网络-fetch/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\n本文主要记录浏览器与服务端网络通讯 fetch 的介绍与使用，将完成get、post、进度、取消请求、和超时请求的功能实现。\n\n---\n\n\n# 一、fetch简介\n\nfetch作为继XMLHttpRequest的网络通讯手段，在使用方面极大的简化了使用方法，通过直观的语义化调用方式让代码更具有可读性，但是它对于一些复杂问题确实有待提高，也有一些实验性的更新还在尝试，如获取请求进度、设置超时时间、中断请求等，他自身都不能完成，需要借助外界的力量。\n\n## 优点：\n   - 简洁易用：Fetch API提供了一种简洁的方式来发送网络请求，使用起来非常直观和易于理解。它使用了Promise和链式调用的方式，使得代码更加清晰和可读。\n   - 强大灵活：Fetch API支持发送不同类型的请求，如GET、POST、PUT、DELETE等，可以满足各种不同的需求。它还支持设置请求头、发送FormData、上传文件等功能，提供了更多的灵活性和功能性。\n   - 支持异步编程：Fetch API基于Promise，可以使用异步编程的方式处理请求和响应。这使得我们可以更好地处理异步操作，避免回调地狱和复杂的嵌套结构。\n   - 内置的错误处理：Fetch API内置了错误处理机制，可以通过.catch()方法捕获和处理请求过程中的错误。这使得我们可以更好地处理网络请求中可能出现的问题，提高了代码的健壮性和可靠性。\n   - 跨域请求支持：Fetch API支持跨域请求，可以发送跨域请求并处理响应。这对于开发跨域应用或与不同域的API进行通信非常有用。\n   \n ## 缺点：\n   - 兼容性问题：Fetch API在一些旧版本的浏览器中可能不被完全支持。特别是在IE浏览器中，需要使用Polyfill或者其他库来提供兼容性支持。\n   - 不支持取消请求：Fetch API目前不支持取消请求的功能。一旦请求被发送出去，就无法中止或取消。这可能会导致一些问题，特别是在需要处理大量请求或需要及时取消请求的情况下。\n   - 不支持超时设置：Fetch API也不支持设置请求的超时时间。如果需要在一定时间内没有响应时取消请求，需要使用其他方式来实现，如使用AbortController和AbortSignal。\n   - 无法直接获取请求进度：Fetch API没有提供直接获取请求进度的功能。如果需要获取请求的进度信息，如上传或下载的进度，需要使用其他方式来实现，如使用XMLHttpRequest或其他库。\n   - 缺乏一些高级功能：相比于一些第三方库，Fetch API在一些高级功能方面可能有所欠缺。例如，它没有提供自动的请求重试、请求拦截、请求缓存等功能，需要自行实现或使用其他库来满足需求。\n\n---\n\n# 二、使用\n不用像XMLHttpreques,需要先构造一个XMLHttpreques对象。fetch直接可以使用，就直接 fetch() 使用就行，可以传递；两个参数，参数二在get请求时可不传，fetch默认发送get请求。\n -  参数1：url 请求地址\n- 参数2：对象，对象包括请求方式、头部、请求体\n\n```javascript\n {\n                method:'post',\n                headers:{\n                    'Content-Type':'application/json'\n                },\n                body: JSON.stringify({\n                    name:'smz'\n                })\n            }\n```\n\nfetch在第一个then返回的是一个promise ===> fetch的response对象,并不是结果，在这个对象里面包括了请求状态、信息、方法等。在这里需要设置一下返回数据的格式，这个一般和后端沟通好。对请求做处理大都是在这里进行的。\n\n>response对象\n\n![response](https://img-blog.csdnimg.cn/2d77b003afbc4f6ea9a1c56b37e57935.png)\n\n  \n   > 返回格式：\n   \n   \n-  `text()`:将响应体解析为纯文本字符串并返回\n -   `json()`：将响应体解析为JSON格式并返回一个JS对象\n -  `blob()`：将响应体解析为二进制数据并返回一个Blob对象\n -   `arrayBuffer()`：将响应体解析为二进制数据并返回一个ArrayBuffer对象\n -  `formData()`：将响应体解析为FormData对象\n\n\n \n在第二个then中，才是返回的数据，当然，可以通过链式调用catch来处理请求中发生的错误。\n下面就进入使用吧。\n\n## get\n`get`请求时，第二个参数可不传，默认就是`get`请求，当然你需要添加请求头之类的可以传第二个参数，这里需要注意的是第一个then里面需要指定返回数据的格式，上面已经给出了几种格式。遇到跨域问题可以看我这个文章 [跨域解决](https://blog.csdn.net/smznbhh/article/details/133422065?spm=1001.2014.3001.5501) 给出了几个跨域的解决方案。\n\n```javascript\n fetch('http://localhost:3000/api/txt').then(response=>{\n            console.log(response)\n            //指定返回的格式\n            return response.text()\n        }).then(data=>{\n            console.log(data)\n        }).catch(error => {\n            // 处理错误\n            console.error(error);\n        });\n```\n\n## post\n`post`请求只要将第二个参数中`method`属性改为`post`,`headers`属性是设置请求头的，`body`是请求体也就是带的数据。\n\n```javascript\nfetch('http://localhost:3000/api/txt',\n            {\n                 method:'post',\n                 headers:{\n                     'Content-Type':'application/json'\n                 },\n                 body: JSON.stringify({\n                     name:'smz'\n                 }),\n            }\n        ).then(response=>{\n            console.log(response)\n            //指定返回的格式\n            return res.json()\n        }).then(data=>{\n            console.log(data)\n        }).catch(error => {\n            // 处理错误\n            console.error(error);\n        });\n```\n\n## 进度实现\n在`fetch`中没有像 `XMLHttpReques` 中 `progress`事件的`loaded`和`total`属性用来监听请求的进度，所以这个功能只能自己实现。实现思路大致如下：\n\n- 在第一个`then`中利用`response.body.getReader()`返回一个流\n\n```javascript\n// 返回一个流\nconst reader = response.body.getReader()\n```\n\n- 利用`response.headers.get('Content-Length')`获取资源总长度\n\n```javascript\n// 响应头上有总长度信息\nconst total = response.headers.get('Content-Length')\n```\n\n- 循环流分片，利用`reader.read()`得到请求信息，计算当前进度，并传递给元素\n\n每个分片利用`reader.read()`会得到`done`和`value`，`done`表示是否完成，`value`表示当前长度。\n\n```javascript\nlet loaded = 0\n            while (true){\n                const {done,value} = await reader.read()\n                if (done){\n                    break\n                }\n                loaded += value.length// 当前进度\n                console.log(loaded)\n                const progress = document.getElementById('progress')\n                progress.innerHTML = `${(loaded/total*100).toFixed(2)+ '%'}`\n            }\n```\n\n`这里需要注意因为response被getReader()占用了，所以需要提前拷贝一份response，返回用拷贝的response`\n\n```javascript\nconst res = response.clone()// 拷贝一份，因为被getReader()占用\nreturn res.text()\n```\n\n>完整代码：\n\n```javascript\nfetch('http://localhost:3000/api/txt').then(async response=>{\n            console.log(response)\n            const res = response.clone()// 拷贝一份，因为被getReader()占用\n            // 返回一个流\n            const reader = response.body.getReader()\n            // 响应头上有总长度信息\n            const total = response.headers.get('Content-Length')\n            let loaded = 0\n            while (true){\n                const {done,value} = await reader.read()\n                if (done){\n                    break\n                }\n                loaded += value.length// 当前进度\n                console.log(loaded)\n                const progress = document.getElementById('progress')\n                progress.innerHTML = `${(loaded/total*100).toFixed(2)+ '%'}`\n            }\n            //指定返回的格式\n            return res.text()\n        }).then(data=>{\n            console.log(data)\n        }).catch(error => {\n            // 处理错误\n            console.error(error);\n        });\n```\n![进度条](https://img-blog.csdnimg.cn/71e3b3bc68c74b33ba3863e6f125d0e5.gif)\n\n\n\n## 取消请求\n同样在`fetch`中是无法通过它内部API实现请求的中断的，需要借助`AbortController`和`AbortSignal`对象来实现请求中断。\n\n- 创建了一个`AbortController`对象\n在请求外部创建`AbortController`对象\n```javascript\n const controller = new AbortController();\n```\n\n- 通过`controller.signal`获取对应的`AbortSignal`对象。\n\n```javascript\nconst signal = controller.signal\n```\n\n- 将`AbortSignal`对象作为`Fetch`请求的`signal`选项传递给`fetch`函数 \n\n```javascript\nfetch('http://localhost:3000/api/txt',\n            {\n                signal // AbortSignal对象\n            }\n        )\n```\n\n- 调用`controller.abort()`方法，触发`AbortSignal`对象的`abort`事件，终止`Fetch`请求\n\n```javascript\n stop.addEventListener('click',()=>{\n        // 终止请求\n        controller.abort();\n    })\n```\n\n- 在请求被终止后，进入`catch`块，进行错误处理。\n  需要注意的是，终止请求后，`Fetch`请求的`Promise`会被拒绝，并且会抛出一个`AbortError`错误。因此，在处理错误时，可以通过判断错误类型为`AbortError`来区分是否是请求被终止的情况。\n\n```javascript\ncatch(error => {\n            // 处理错误\n            if (error.name === 'AbortError'){// 中断请求\n                alert('请求被终止')\n            }else {\n                console.error(error);\n            }\n        });\n```\n  \n  使用`AbortController`和`AbortSignal`可以灵活地控制和终止`Fetch`请求，特别适用于需要及时取消请求的场景，如用户取消操作或超时处理。\n\n![中止请求](https://img-blog.csdnimg.cn/f78ab1b602f74bdbb5219788dcdc572c.gif)\n\n## 超时实现\nfetch也是不能设置超时时间的。\n>先定义一个自定义错误，用来标识超时错误\n\n```javascript\nclass TimeoutError extends Error {\n        constructor(message = '请求超时') {\n            super(message)\n            this.name = 'TimeoutError'\n        }\n    }\n```\n\n>超时有两种办法：\n\n1. 使用setTimeout和AbortController实现\n     在指定的时间内调用请求终止 controller.abort();\n```javascript\nfunction fetchWithTimeout(url, timeout) {\n        return new Promise((resolve, reject) => {\n            // 创建一个AbortController对象\n            const controller = new AbortController();\n            const signal = controller.signal;\n            // 设置超时定时器\n            const timeoutId = setTimeout(() => {\n                // 终止请求\n                controller.abort();\n                reject(new TimeoutError();\n            }, timeout);\n            fetch(url, { signal })\n                .then(response => {\n                    clearTimeout(timeoutId); // 清除超时定时器\n                    resolve(response);\n                })\n                .catch(error => {\n                    clearTimeout(timeoutId); // 清除超时定时器\n                    reject(error);\n                });\n        });\n    }\n```\n\n\n     \n2. 使用setTimeout和Promise.race方法实现\n      定义好一个超时promise对象，利用Promise.race()方法返回 超时promise和请求promise对象第一个完成的状态。\n```javascript\n    function fetchWithTimeout2(url, timeout) {\n        const fetchPromise = fetch(url);\n        const timeoutPromise = new Promise((resolve, reject) => {\n            setTimeout(() => {\n                // 终止请求\n                controller.abort();\n                reject(new TimeoutError());\n            }, timeout);\n        });\n// 使用Promise.race方法，同时等待fetchPromise和timeoutPromise\n        return Promise.race([fetchPromise, timeoutPromise]);\n    }\n```\n\n两种方式使用就和fetch使用方式一样。\n\n```javascript\n// fetchWithTimeout('http://localhost:3000/api/txt', 3000)\n        fetchWithTimeout2('http://localhost:3000/api/txt', 3000)\n            .then(response => response.text())\n            .then(data => {\n                console.log(data);\n            })\n            .catch(error => {\n                if (error.name === 'TimeoutError'){\n                    alert('请求超时，请重试')\n                }else {\n                    console.error(error);\n                }\n            });\n```\n\n`方式二这里只能将超时实现，并不能将请求杀死，请求还会继续进行，直到后端处理了该请求`\n\n![超时](https://img-blog.csdnimg.cn/1f4c8dadb96d4f9bb676295c89c5e396.gif)\n\n>完整代码：\n\n```javascript\n // 超时设置\n    // 自定义错误\n    class TimeoutError extends Error {\n        constructor(message = '请求超时') {\n            super(message)\n            this.name = 'TimeoutError'\n        }\n    }\n    // 方案一\n    function fetchWithTimeout(url, timeout) {\n        return new Promise((resolve, reject) => {\n            // 创建一个AbortController对象\n            const controller = new AbortController();\n            const signal = controller.signal;\n\n            // 设置超时定时器\n            const timeoutId = setTimeout(() => {\n                // 请求中断\n                controller.abort();\n                reject(new TimeoutError());\n            }, timeout);\n            fetch(url, { signal })\n                .then(response => {\n                    clearTimeout(timeoutId); // 清除超时定时器\n                    resolve(response);\n                })\n                .catch(error => {\n                    clearTimeout(timeoutId); // 清除超时定时器\n                    reject(error);\n                });\n        });\n    }\n\n    // 方案二\n    function fetchWithTimeout2(url, timeout) {\n        const fetchPromise = fetch(url);\n        const timeoutPromise = new Promise((resolve, reject) => {\n            setTimeout(() => {\n                // 超时\n                reject(new TimeoutError());\n            }, timeout);\n        });\n// 使用Promise.race方法，同时等待fetchPromise和timeoutPromise\n        return Promise.race([fetchPromise, timeoutPromise]);\n    }\n    const overtime = ()=>{\n        // fetchWithTimeout('http://localhost:3000/api/txt', 300)\n        fetchWithTimeout2('http://localhost:3000/api/txt', 300)\n            .then(response => response.text())\n            .then(data => {\n                console.log(data);\n            })\n            .catch(error => {\n                if (error.name === 'TimeoutError'){\n                    alert('请求超时，请重试')\n                }else {\n                    console.error(error);\n                }\n            });\n    }\n```\n\n---\n\n# 总结\n`fetch`请求目前来说处理简单请求，日后等`fetch API`完善吧。其他复杂的请求还是使用`ajax`来完成，而且还有`axios`对`ajax`做了封装。这里值得一提的是`XMLHttpReques`已经不再更新了。\n\n","tags":["网络","fetch","AbortController","AbortSignal","Promise"],"categories":["网络","fetch"]},{"title":"网络-Ajax","url":"/2023/10/01/网络-Ajax/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录Ajax技术的简介，以及用法。\n\n---\n\n\n# 一、Ajax\nAjax是一组用于在Web浏览器和Web服务器之间进行异步通信的Web开发技术。\n它代表着**Asynchronous JavaScript** and **XML**（异步JavaScript和XML），尽管XML并不总是作为数据格式使用。\n通过Ajax，Web应用程序可以在**不重新加载整个页面**的情况下更新页面的部分内容。这样可以实现更加交互和响应式的用户体验。\nAjax使用JavaScript发送请求到服务器并异步处理响应，而不会阻塞用户界面。\n可以通过 JavaScript 和`XNLHttpRequest`对象来向服务器请求数据\n\nAjax可以用于执行各种任务，例如从服务器检索数据、提交表单数据和动态更新内容。\n它通常用于现代Web应用程序中，用于创建自动完成搜索框、实时更新和无限滚动等交互功能。\n\n## 优点：\n   - 提高用户体验：通过减少页面重载和刷新，使得网站变得更加灵活和动态\n  -  减轻服务器负载：可以有效减少服务器接收到的请求次数和需要响应的数据量，从而减轻服务器负担\n  -  提高响应速度：可以异步获取数据并更新页面，从而提高响应速度\n   - 增加交互：使页面变得可交互性\n\n## 缺点：\n   - 对搜索引擎优化（SEO）不友好，爬虫无法抓取Ajax中的内容与URL ===>考虑用SSR服务端渲染技术\n   - 需要考虑安全性问题，数据和网络安全需要采取对应的措施\n\n\n# 二、使用步骤\n## XNLHttpRequest对象\n- 创建对象xhr：\n\n```javascript\nconst xhr = new XMLHttpRequest()\n```\n\n- open方法：接收三个参数分别是 请求方式、请求地址、是否异步：默认为true\n\n```javascript\n xhr.open('post','http://localhost:3000/api/post',true)\n```\n\n - setRequestHeader方法:用于为请求的HTTP头设置值。\n \n\n```javascript\nsetRequestHeader(\"header\", \"value\")\n```\n\n -  onreadystatechange方法：监听服务端返回的数据\n \n\n```javascript\nxhr.onreadystatechange = () =>{\n            console.log(xhr)\n            if (xhr.readyState === 4 && xhr.status === 200) {\n                console.log(xhr.responseText)\n            }\n        }\n```\n![onreadystatechange](https://img-blog.csdnimg.cn/6874fb4873e942ee91ccc80439bcf39e.png)\n\n\n  -    readyState属性：\n         -   0：未初始化，XNLHttpRequest已经创建，但未调用open方法\n          -  1：已打开，open方法已调用，send方法未调用\n          -  2：已发送，send方法已调用，服务端接收到请求\n         -   3：正在接收，服务器正在处理请求并返回数据\n         -   4：完成，服务端已完成数据传输\n- status属性: 200成功 400参数错误 403没有权限 401token找不到  404未找到 500服务器错误\n- send方法：给服务端发送的数据\n\n```javascript\nxhr.send(JSON.stringify({name:'smz'}))\n```\n![send](https://img-blog.csdnimg.cn/0496ce1e395841ecba5e133293bc1eb2.png)\n\n\n- abort方法:用于停止或放弃当前异步请求。必须在open方法后,无法恢复。\n\n```javascript\nstop.addEventListener('click',()=>{\n            xhr.abort()\n        })\n```\n\n- getResponseHeader方法:用于以字符串形式返回指定的HTTP头信息。\n\n```javascript\ngetResponseHeader(\"headerLabel\")\n```\n\n- getAllResponseHeaders方法:用于以字符串形式返回完整的HTTP头信息。\n\n```javascript\n getAllResponseHeaders()\n```\n![获取请求头](https://img-blog.csdnimg.cn/87371f7578eb4445871e275dde915227.png)\n\n\n- 监听进度：\n   \n   >给xhr对象添加一个progress事件，返回event\n   \n    event.loaded：当前进度\n   event.total：总进度\n```javascript\n xhr.addEventListener('progress',(event)=>{\n            console.log(event.loaded,event.total)\n        })\n```\n   ![进度](https://img-blog.csdnimg.cn/3ad33f0e4ad9487688c9dfc16efcc416.png)\n![进度](https://img-blog.csdnimg.cn/02cce2b1aec445eaa1e09dc77ef3a0aa.gif)\n\n\n\n\n   - 设置超时：xhr.timeout = 3000\n   \n   - 超时回调：监听timeout事件\n```javascript\n xhr.addEventListener('timeout',()=>{\n            alert('请求超时')\n        })\n```\n\n![超时](https://img-blog.csdnimg.cn/a5b3e7bdd9c64b5d92ffdd85280035e1.png)\n\n      \n   - 中断回调：监听abort事件\n   \n\n```javascript\n xhr.addEventListener('abort',()=>{\n            console.log('请求中断')\n        })\n```\n\n   -  监听load事件：也可以监听请求是否成功，就不用判断readyState的值\n   \n\n```javascript\n xhr.addEventListener('load',()=>{\n            if (xhr.status === 200){\n                console.log('请求成功，触发onload')\n            }\n        })\n```\n\n![请求成功](https://img-blog.csdnimg.cn/6de01e60d05949d0814ffab77df715e6.png)\n\n\n   -  post请求：请求参数要放在send()中\n## 2.完整代码\n>前端代码\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div>\n    <button id=\"send\">发送请求</button>\n    <button id=\"stop\">中断请求</button>\n    <div>进度条<span id=\"progress\"></span></div>\n    <input id=\"file\" type=\"file\">\n</div>\n</body>\n<script>\n    let btn = document.getElementById('send')\n    let file = document.getElementById('file')\n    btn.addEventListener('click',()=>{\n        sendAjax()\n    })\n    //上传文件\n    file.addEventListener('change',()=>{\n        const formData = new FormData()\n        formData.append('file',file.files[0]) // key值对应后端 upload.single('file')\n        const xhr = new XMLHttpRequest()\n        xhr.open('post','http://localhost:3000/api/upload',true)\n        xhr.onreadystatechange = () =>{\n            console.log(xhr)\n            if (xhr.readyState === 4 && xhr.status === 200) {\n                console.log(xhr.responseText)\n            }\n        }\n        xhr.send(formData)\n    })\n    const sendAjax = () =>{\n        const xhr = new XMLHttpRequest()\n        // 三个参数，请求方式、请求地址、是否异步：默认为true\n        //get\n        // xhr.open('get','http://localhost:3000/api/txt?name=smz',true)\n        //post\n        xhr.open('post','http://localhost:3000/api/post',true)\n        //设置请求头\n        xhr.setRequestHeader('Content-Type','application/json')\n        //设置超时\n        xhr.timeout = 30000\n        //超时回调\n        xhr.addEventListener('timeout',()=>{\n            alert('请求超时')\n        })\n        // 监听服务端返回的数据\n        xhr.onreadystatechange = () =>{\n\n            if (xhr.readyState === 4 && xhr.status === 200) {\n                console.log(xhr.responseText)\n            }\n        }\n        //监听进度\n        xhr.addEventListener('progress',(event)=>{\n            const progress = document.getElementById('progress')\n            progress.innerText = `${(event.loaded/event.total*100).toFixed(2)}%`\n            console.log(event.loaded,event.total)\n            //响应头\n            console.log(xhr.getAllResponseHeaders())\n            console.log(xhr.getResponseHeader('content-type'))\n        })\n        //中断请求\n        let stop = document.getElementById('stop')\n        stop.addEventListener('click',()=>{\n            xhr.abort()\n        })\n        //监听中断\n        xhr.addEventListener('abort',()=>{\n            console.log('请求中断')\n        })\n        //监听请求成功\n        xhr.addEventListener('load',()=>{\n            if (xhr.status === 200){\n                console.log('请求成功，触发onload')\n            }\n        })\n        // 给服务端发送的数据\n        // xhr.send(null)\n        //post\n        xhr.send(JSON.stringify({name:'smz'}))\n    }\n\n</script>\n</html>\n```\n\n>后端代码：这里用的node\n\n```javascript\nconst express = require('express')\nconst app = express()\nconst multer = require('multer')\n\nconst single = multer.diskStorage({\n    destination: (req, file, cb) => {\n        cb(null, './upload')\n    },\n    filename: (req, file, cb) => {\n        cb(null, Date.now() + file.originalname)\n    }\n})\nconst upload = multer({\n    single\n})\n\napp.get('/api/txt',(req,res)=>{\n    res.setHeader('Access-Control-Allow-Origin','*')\n    const {name} = req.query // 函数名\n    let text = ''\n    for(let i=0;i<10000;i++){\n        text += `${name}Ajax`\n    }\n    res.send( text)\n})\n\napp.use(express.json())\napp.use(express.urlencoded({extended:true}))\n// post请求\napp.post('/api/post',(req,res)=>{\n    res.setHeader('Access-Control-Allow-Origin','*')\n    console.log(req.body)\n    res.json({\n        code:200,\n        data:{\n            name: req.body.name\n        }\n    })\n})\n// 预检请求放行\napp.options('/api/*', (req,res) => {\n    res.setHeader(\"Access-Control-Allow-Origin\",\"*\")\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n    res.end()\n})\n\n//传文件\napp.post('/api/upload',upload.single('file'),(req,res)=>{\n    console.log(req.file)\n    res.setHeader('Access-Control-Allow-Origin','*')\n    res.json({\n        code:200\n    })\n})\n\napp.listen(3000,()=>{\n    console.log('server is running')\n})\n```\n\n\n---\n\n# 总结\n本文主要记录了Ajax的介绍与使用,第三方库 axios 对 Ajax 做了封装。\n\n","tags":["网络","Ajax","node","axios"],"categories":["网络","Ajax"]},{"title":"网络-跨域解决","url":"/2023/09/30/网络-跨域解决/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n# 前言\n本文主要介绍跨域问题介绍并提供了四种解决办法。\n\n\n---\n\n\n\n# 一、跨域是什么？\n准确的来说是浏览器存在跨域问题，浏览器为了安全考虑，也就是同源策略的限制，会拒绝跨域请求。\n在这里同源策略是指：请求时拥有相同的协议、域名、端口，其中只要有一项不满足就被视为跨域。\n| 主机（http://www.smz.com） | 是否跨域      |原因     |\n|:--------:| :-------------:| :-------------:|\n| https://www.smz.com | 是 |协议不同 |\n| http://www.smz.com:8001 | 是 |端口不同 |\n| http://www.baidu.com | 是 |域名不同 |\n| http://www.smz.com/index.html | 否 |符合三个条件 |\n\n\n跨域产生：\n\n>前端，这里直接请求，就会产生跨域问题\n\n```javascript\n fetch('http://localhost:3000/api/json').then(res=>res.json()).then(res=>{\n        console.log(res)\n    })\n```\n\n>后端，这里不做处理直接返回数据\n\n```javascript\napp.get('/api/json',(req,res)=>{\n    res.send({name:'smz'})\n})\n```\n\n>这里浏览器报错，是因为端口不一致导致跨域\n\n![跨域](https://img-blog.csdnimg.cn/525c0791e8d04882b0c00b76ce174079.png)\n\n这里值得注意的是，在发送跨域请求时，浏览器会先发送一个`OPTIONS`请求（预检请求），用来获取服务器对跨域的支持情况。以下几种跨域请求都会触发预检请求，如果服务端在请求头中返回了适当的跨域头，则允许发送实际请求，否则拒绝。而其他简单请求则会正常发送。\n\n-  使用了非简单请求\n简单请求包括：`GET`、`HEAD`、`POST`。\n请求头部只包含以下字段：`Accept`、`Accept-Language`、`Content-Language`、`Content-Type`（仅限于`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`）。\n- 自定义请求头部：跨域请求中的请求头部包含了自定义的字段\n\n\n---\n# 二、跨域的解决\n## 1.JSONP\n这种方式需要前后端一起协商解决，原理就是动态创建script标签，因为script标签src属性不受跨域限制。但是script标签只能发送get请求，是不安全的。\n\n后端返回的是一个函数 这个函数前端需先定义好 他会把返回的值注入到这个函数的参数中，其中具有代表性的就是百度搜索跨域请求就是jsonp实现的。\n\n>前端：\n\n\n\n```javascript\n<script>\n    let text = document.querySelector('#text')\n    // 动态创建script标签，添加scr请求地址拼接函数名称\n    const jsonp = (name) =>{\n        let script = document.createElement('script')\n        script.src = 'http://localhost:3000/api/jsonp?callback=' + name\n        document.body.appendChild(script)\n        return new Promise((resolve)=>{\n            window[name] = (data) =>{\n                resolve(data)\n            }\n        })\n    }\n    // 利用函数接收返回的参数\n    jsonp(`callback${new Date().getTime()}`).then(res=>{\n        text.textContent = res\n        console.log(res)\n    })\n</script>\n```\n\n>后端：这里用Node\n>\n\n```javascript\nconst express = require('express')\nconst app = express()\napp.get('/api/jsonp',(req,res)=>{\n    const {callback} = req.query // 函数名\n    res.send(`${callback}('hello jsonp')`) //返回并将数据充当函数参数返回\n})\n\napp.listen(3000,()=>{\n    console.log('server is running')\n})\n```\n\n![jsonp](https://img-blog.csdnimg.cn/c0ff6a10745c46929f4df6d63024c22a.png)\n\n\n\n\n跨域问题可以通过以下几种方式解决：\n\n1. JSONP（JSON with Padding）：通过动态创建<script>标签，将请求的数据作为参数传递给服务器，服务器返回一个包裹在函数调用中的数据，浏览器解析并执行该函数，从而实现跨域请求。\n\n2. CORS（Cross-Origin Resource Sharing）：在服务器端设置响应头，允许指定的域名访问资源。通过在响应头中添加\"Access-Control-Allow-Origin\"字段，指定允许访问的域名，可以实现跨域请求。\n\n3. 代理服务器：在同一域名下设置一个代理服务器，将跨域请求转发到目标服务器，并将响应返回给浏览器。这种方式需要在服务器端进行配置。\n\n4. WebSocket：使用WebSocket协议进行跨域通信，WebSocket协议不受同源策略的限制。\n\n需要注意的是，跨域问题只存在于浏览器中，对于服务器端来说并不存在跨域问题。因此，以上解决方案都是在浏览器端实现的。\n\n---\n## 2.前端代理dev环境\n利用vite或者webpack通过代理，将请求转发到对应的服务器上。\n\n>vite或者webpack配置文件，这里用vite\n\n```javascript\nimport {defineConfig} from 'vite'\n\nexport default defineConfig({\n    server:{\n        proxy:{\n            '/api':{\n                target:'http://localhost:3000',\n                changeOrigin:true,// 开启跨域\n            }\n        }\n    }\n})\n```\n\n>请求：\n\n```javascript\n fetch('/api/json').then(res=>res.json()).then(res=>{\n        console.log(res)\n    })\n```\n![vite](https://img-blog.csdnimg.cn/c47b56366fc042afb5cb6b0bfcff4cac.png)\n\n---\n这里浏览器显示的是前端端口发送的请求，实际上已经通过请求转发给3000端口了，是vite开启了一个Node服务，在Node服务这里做了请求转发的操作。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c24c308cf5b44140a32f633071d6cab2.png)\n\n`只在开发环境生效，项目上线得用nginx`\n## 3.后端设置请求头CORS\n后端设置跨域很简单，只要在返回请求头中带入允许跨域的接口地址就行`Access-Control-Allow-Origin`\n\n将其值设置为*可以放行全部，但是不建议这样放行全部，可以指定ip。\n```javascript\nres.setHeader('Access-Control-Allow-Origin','*')\n```\n![CORS](https://img-blog.csdnimg.cn/ac3ecaf69da34ab7b540e652650a4734.png)\n\n\n其实在产生跨域问题时，浏览器就提示我们这样的做法了\n\n![跨域](https://img-blog.csdnimg.cn/4169d65de09d4dce887708b89228ec20.png)\n\n## 4.运维nginx代理\n在项目上线时，通过nginx代理进行请求转发。\n\n>在nginx配置文件nginx.conf中加入代理配置\n\n```javascript\n  location /api {\n            proxy_pass http://127.0.0.1:5000;\n        }\n```\n![nginx](https://img-blog.csdnimg.cn/826521dc8b0d4d0aba602df0e48788fe.png)\n\n\n---\n\n# 总结\n本文记录了，跨域问题在前后端的解决方法，以及不同环境下的解决方案。\n\n","tags":["跨域","请求转发","网络","JSONP","Nginx","同源策略","简单请求","预检请求","代理"],"categories":["网络","跨域"]},{"title":"网络-OSI、TCP、浏览器URL、CDN","url":"/2023/09/29/网络-OSI、TCP、浏览器URL、CDN/","content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文记录OSI七层参考模型，和TCP/IP基本介绍以及浏览器输入URL过程和CDN。\n\n---\n![OSI、TCP](https://img-blog.csdnimg.cn/07552b8c729348138f6c7422cf58d271.png)\n\n\n---\n# 一、OSI七层模型\n七层参考模型分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。\n\n- 应用层（报文）\n最接近用户的一层，如使用ajax调用接口发送http请求、webSocket长连接、SSH协议等\n- 表示层（报文）\n对数据进行解码和编码，将数据解析成计算机识别的语言\n- 会话层（报文）\n是在发送方和接收方之间进行通讯时创建、维持、之后终止或断开连接的地方。\n- 传输层（数据段）\n定义端口号，以及控流和校验。\n    - TCP\n    TCP是面向连接的协议且是可靠的，因为建立TCP连接需要通过三次握手四次挥手，这样虽然可靠，但是连接速度有所减慢\n    - UDP\n    UDP具有实时性，传输效率比TCP高，但是不稳定，常用于直播、游戏\n- 网络层\n控制数据链路层与传输层之间的消息转发，建立、维护、终止网络连接。也就是说将数据链路层的数据转换为数据包进行传输，这一层定义了IP协议，通常我们使用的是IPV4。\n    - 寻址\n    利用IP地址进行通讯，与MAC地址类似，但是MAC属于物理地址，IP属于网络地址\n    - 路由\n    在同一个网络不需要网络层，就可以完成通讯。而对于不同网络之间的通讯就必须借助网络层的设备（路由器），路由器以端对端的方式查找对应IP地址。\n- 数据链路层\n数据链路层把物理层传输的比特流，通过MAC地址（网卡唯一标识：物理地址）拼接比特组成的数据帧，以广播的形式进行传输，局域网内的所有计算机都能收到消息。\n- 物理层\n物理层是直接和实物介质打交道的，这一层通过电、光、无线电波，获取对应的信号转换成二进制数据，单位为**bit**，称为传输**比特流**\n\n\n\n---\n\n# 二、TCP/IP和UDP\n### TCP\n#### 三次握手\nTCP连接需要通过三次握手才能建立连接。\n\n名词解释：\n- seq  序列号 随机生成\n- ack 确认号 ack=seq+1\n- ACK 确定序列号有效\n- SYN 发起新连接\n\n![TCP三次握手](https://img-blog.csdnimg.cn/ff10894c817c4074953017d6b8212bed.png)\n#### 四次挥手\n在关闭连接时，无论是客户端断开还是服务端断开需要通过四次挥手才能关闭TCP连接。在第三次挥手之前第二次挥手之后，会将未完成的请求完成，才会进行第三次挥手。\n在进行第三次挥手的时候客户端会进入超时等待状态，进入超时等待是因为怕ACK丢失，导致连接无法关闭，等待状态会让服务端重新发送FIN。\n名词解释：\n- seq  序列号 随机生成\n- ack 确认号 ack=seq+1\n- ACK 确定序列号有效\n- SYN 发起新连接\n- FIN 完成\n\n\n![四次挥手](https://img-blog.csdnimg.cn/855f196b644b4448a06d1d70f8e5aeee.png)\n\n---\n\n# 三、 浏览器输入URL\n\n## URL\nURL由三部分组成：协议、域名、和请求资源路径\n![URL](https://img-blog.csdnimg.cn/4f8c67d99de44f99bcf7a3f664794344.png)\n## DNS查询\nDNS是将ip与域名做映射关系，这一步就是通过域名查找ip地址\nDNS查询会以以下几个步骤进行，其中一步找到则跳到建立连接部分。\n - 浏览器自身DNS\n ![浏览器DNS](https://img-blog.csdnimg.cn/9623aeb7cf1b4ab590d9c16a339dc0ce.png)\n\n - 操作系统DNS\n - 本地hosts文件\n - 向域名服务器发送请求\n向域名服务器发送请求分为三步，首先在根域名服务器找如果没有对应ip就到顶级域名服务器再没有就到权威域名服务器找：\n![域名服务器](https://img-blog.csdnimg.cn/6bb4f2069cef431780f5ed2e7023eab6.png)\n\n     - 根域名\n     ![根域名](https://img-blog.csdnimg.cn/1555859b356143b2aa19dcc6266dd531.png)\n\n     - 顶级域名\n     ![顶级域名](https://img-blog.csdnimg.cn/6998c9830e6347beb9e27f90ae9cdf5c.png)\n\n     - 权威域名\n     ![权威域名](https://img-blog.csdnimg.cn/5787a8a6df144b289bf38f05eacebc3a.png)\n\n\n## TCP/IP连接\n\n## 浏览器缓存\n### 强缓存\n让浏览器强制缓存服务端提供的资源,一般是js、css等静态资源，在第一次请求后，这个请求就直接会在浏览器缓存中找，分为磁盘缓存和内存缓存，在返回状态码后有标记，在通过磁盘读取缓存后有几率读取浏览器内存中都缓存。\n\n需要后端配置其中一个响应头字段：\n - Cache-Control: max-age=432000\n - Expires: Wed,21 Oct 2015 07:28:00 GMT\n\n![强缓存](https://img-blog.csdnimg.cn/d500a0033a4c4731a7e4a8fcdff0d611.png)\n\n### 协商缓存\n后端通过两个字段确定缓存的时间：\n - Last-Modified: Set, 21 Oct 2015 07:30:00 GMT  (最后被修改的时间)\n - if-Modified-Sice: Set, 21 Oct 2015 07:30:00 GMT\n或者：\n- ETAG: \"0.0.1\"\n- if-None-Match: \"0.0.1\"\n通过比较两个字段的值，确定资源是否改动，没改动就返回304，否则将返回200并带上最新资源，ETAG可带版本号或者文件hash。\n\n\n### 断开连接\n## 浏览器渲染\n\n- 解析HTML进行AST解析成DOM树\n\n\n- 将css样式转换成浏览器认识的样式，计算出DOM节点样式\n\n**回流**\n当元素尺寸、结构、或属性发生变化时，浏览器将重新渲染部分或者全部文档\n\n导致回流操作：\n  - 首次渲染\n  - 浏览器窗口发生改变\n  - 元素尺寸、位置发生改变\n  - 元素内容变化\n  - 元素字体大小\n  - 添加或者删除可见的DOM元素\n  - 激活CSS伪类（:hover）\n  - 查询某些属性或者调用某些方法\n       - clientWidth、clientHeight、clienTop、clienLeft\n       - offsetWidth\n       - scrollwidth\n       - getComputedStyle()\n       - getBoundingClientRect()\n       - scrollTo()\n       \n**重绘**\n当页面元素样式的改变并不影响他在文档流中的位置时，浏览器会将新样式赋予给元素并重绘它\n\n\n- JS解析\nJS的解析通过V8引擎，通过解析器解析成AST语法树，再转换成字节码（兼容跨平台），通过解释器（JIT）编译代码后变成机器码，运行到CPU。\n\n---\n\n\n# 四、 CDN\n内容分发网络，CDN是用来优化网络资源请求时间的，在DNS解析的时候会去距离比较近的服务器查找。\n\n![CDN](https://img-blog.csdnimg.cn/8250f7a638d940e59e52505afcdebfbc.png)\n\n\n\n---\n\n# 总结\n\n\n","tags":["网络","OSI","TCP","URL","CDN"],"categories":["网络","OSI","TCP"]},{"title":"Vue-Router","url":"/2023/09/27/Vue-Router/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n本文主要记录Vue-Router的使用以及其原理剖析。\n\n---\n\n# 一、简介\n在这里不得不说Vue Router 的作用，因为构建出的vue应用是一个SPA（单页面），他只有一个html，Vue Router的作用就在于，如何在视口显示正确页面以及不同组件的跳转等问题。他能在不刷新页面的同时，更改URL进行页面的更改。\n\n在官方文档中，是这样形容Vue Router的\n- 富有表现力的路由语法\n用直观且强大的语法来定义静态或动态路由。\n- 细致的导航控制\n可拦截任何导航并更精确地控制其结果。\n- 基于组件配置方法\n将每条路由映射到应该显示的组件上。\n- 支持历史模式\n有 HTML5、hash 或记忆历史模式可供选择。\n- 支持滚动控制\n可精确控制每个页面的滚动位置。\n- 支持自动编码\n可直接在代码中使用 unicode 字符（你好）\n\n# 二、安装与使用\n\n- 使用命令安装 Vue Router 路由插件\n\n`注：如果是vue2项目需要安装 vue-router@3 版本的路由插件`\n```javascript\n//vue3\npnpm i vue-router@4\n\n//vue2\npnpm i vue-router@3\n```\n\n- 新建一个Router文件用于存放路由配置和组件映射等信息\n\n```javascript\nimport {createRouter,createWebHashHistory,RouteRecordRaw} from 'vue-router'\n\n/**\n * 定义路由映射，每个组件对应一个路由映射\n * 其中路由类型为 RouteRecordRaw\n */\nconst routes:Array<RouteRecordRaw> = [\n    {path: '/A',component:()=> 'coms/路由/Router-A.vue'},\n    {path: '/B',component:()=> 'coms/路由/Router-B.vue'},\n]\n\n/**\n * 创建路由实例传递一些配置\n * 配置：\n * 1.history\n *   路由模式存在三种：\n *    vue2--->mode:history ===  vue3--->history:createWebHistory()\n *    vue2--->mode:hash   === vue3--->history:createWebHashHistory()\n *    vue2--->mode:abstact  === vue3--->history:createMemoryHashHistory()\n * 2.routes\n *   路由映射关系\n * 3.name\n *   名称\n * 4.scrollBehavior（可选）\n * 5.parseQuery（可选）\n * 6.stringifyQuery（可选）\n * 7.linkActiveClass（可选）\n * 8.linkExactActiveClass（可选）\n */\nexport const router = createRouter({\n    history:createWebHashHistory(),\n    routes, // `routes: routes` 的缩写\n})\n```\n`不同路由的介绍与原理在之后剖析`\n\n- 挂载到根实例\n\n```javascript\n//vue-router\nimport {router} from \"../Router\"\napp.use(router)\n```\n- 页面使用\n 页面使用分为两个部分\n   - 路由导航\n   使用 router-link 组件进行导航，通过传递 `to` 来指定链接，`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签\n   这里没有使用 `a` 标签，官方给了解释：\n   >请注意，我们没有使用常规的 a 标签，而是使用一个自定义组件 `router-link` 来创建链接。这使得 `Vue Router` 可以在`不重新加载页面的情况下更改 URL`，处理 URL 的生成以及编码。我们将在后面看到如何从这些功能中获益。\n\n   - 路由出口\n利用`<router-view>`路由匹配到的组件将渲染在这里\n该组件可以放在任意位置以便适应布局\n\n```html\n<p>\n    <!--使用 router-link 组件进行导航 -->\n    <!--通过传递 `to` 来指定链接 -->\n    <!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->\n    <router-link to=\"/\">Go to Home</router-link>\n    <router-link to=\"/about\">Go to About</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n```\n---\n全局挂载完后，在以`选择式API`的组件中，我们可以使用`this.$router`的形式访问路由信息，`this.$route`的形式访问当前路由信息，官方也给出了这样做的目的：\n>在整个文档中，我们会经常使用 router 实例，请记住，`this.$router` 与直接使用通过 `createRouter` 创建的 router 实例完全相同。我们使用 `this.$router` 的原因是，我们不想在每个需要操作路由的组件中都导入路由。\n\n![this.$router](https://img-blog.csdnimg.cn/604c20bb38ee45d6bd0f0c585648c113.png)\n\n![this.$route](https://img-blog.csdnimg.cn/de17815f9f49409bbdc5c78ceb43f07c.png)\n\n在`组合式API`中，用`useRouter`, `useRoute`方法使用，在模板中可以使用`$route`和`$router`来获取路由信息，不用将`useRouter`, `useRoute`方法获取的路由返回。\n\n```javascript\n<template>\n<div style=\"background-color: red;width: 100vw;height: 50vh\">这是A</div>\n  <div>这是路由{{$route}}</div>\n</template>\n\n<script setup lang=\"ts\">\nimport {useRoute,useRouter} from 'vue-router'\nconst route = useRoute()\nconst router = useRouter()\n\nconsole.log(route)\nconsole.log(router)\n</script>\n```\n\n![useRouter, useRoute](https://img-blog.csdnimg.cn/f7c81dd65b7e4254b183573a1ba010b8.png)\n![  $route和 $router](https://img-blog.csdnimg.cn/f4c5232ae2f44d0b9bf2a5baa344f9a7.png)\n\n`扩展：在这里使用 getCurrentInstance() 方法可以获取当前实例对象`\n\n![getCurrentInstance() ](https://img-blog.csdnimg.cn/96c109aa551046e18196b9af78f9cdb2.png)\n\n\n# 三、路由模式\n## 1.hash \n该方式通过window.location.hash`的方式进行URL匹配，他会在URL地址拼接一个‘#’，hash是 '#' 之后的部分，用作锚点在页面内进行导航。\n\n`改变hash部分不会引起页面刷新`\n\n能让URL变化的方式有以下几种：\n\n - 通过浏览器回退和前进改变\n 通过`hashchang`事件监听URL的变化\n\n```javascript\nwindow.addEventListener(\n    \"hashchange\",\n    function (e) {\n      console.log(\"The hash has changed!\",e);\n    },\n    false,\n);\n```\n\n ![hashchang](https://img-blog.csdnimg.cn/0478beaacd08489b9e90d3b0404454ae.png)\n - 通过`<a>`标签改变\n - 通过window.location改变URL\n\n\n## 2.history\nhistory模式在URL路径中是没有’#‘的，它是利用了H5 中`history.pushState`API来完成URL的path改变而不重载页面，history提供了类似`hashchange`事件的`popstate`事件,但是通过`history.pushState`改变URL不会被该事件监听。\nMDN中是这样介绍的:\n>按指定的名称和 URL（如果提供该参数）将数据 push 进会话历史栈，数据被 DOM 进行不透明处理；你可以指定任何可以被序列化的 javascript 对象。请注意，除了 Safari 所有浏览器现在都忽略了 title 参数。更多的信息，请看使用 [History API](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)。\n\nhistory 也提供了一些其他方法比如\n- window.history.back();\n回退\n- window.history.forward();\n前进\n- window.history.go(number);\n去以当前页面为基数的第几个页面\n\n- history.pushState()\n\n   pushState() 需要三个参数：一个状态对象，一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容：\n\n\n  - 状态对象 — 状态对象 state 是一个 JavaScript 对象，通过 pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate 事件就会被触发，且该事件的 state 属性包含该历史记录条目状态对象的副本。 状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有 640k 的大小限制。如果你给 pushState() 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage.\n   - 标题 — Firefox 目前忽略这个参数，但未来可能会用到。在此处传一个空字符串应该可以安全的防范未来这个方法的更改。或者，你可以为跳转的 state 传递一个短标题。\n   - URL — 该参数定义了新的历史 URL 记录。注意，调用 pushState() 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新 URL 不必须为绝对路径。如果新 URL 是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前 URL 同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前 URL。\n\n以上是MDN给的解释和用法\n\n`history.pushState，是不会检查URL地址是否存在，浏览器不会加载该页面，甚至不会检查是否存在。只能通过手动刷新或者利用vue内部路由push方法进行浏览器URL导航,此时会发送请求，如果不存在则会404，所以在这里需要后端配合处理`\n\n\n利用`popstate`事件监听回退与前进。\n```javascript\nwindow.addEventListener(\"popstate\", () => {\n  let currentState = history.state;\n  console.log(\"currentState\", currentState);\n});\n```\n\n## 3.abstact\n该路由方式用在服务端渲染，之前的两种路由方式与浏览器URL地址进行操作，与浏览器API不可分割，而这种路由方式就可以脱离浏览器API的环境，他的功能就是将在已存在的路由页面中嵌入新的路由页面，而地址不发生改变\n\n\n\n`location.reload() 方法可以让页面重载`\n\n---\n\n# 四、命名路由-编程式导航-历史记录\n## 1.命名路由\n在路由配置项中可以配置name属性,可以让跳转不用再写路由地址，也会避开路径排序。\n\n```javascript\nconst routes:Array<RouteRecordRaw> = [\n    {path: '/A',component:()=> import('coms/路由/Router-A.vue')},\n    {path: '/B',name:'B',component:()=> import('coms/路由/Router-B.vue')},\n    {path: '/C',name:'C',component:()=> import('coms/路由/Router-C.vue')},\n]\n```\n\n```html\n<router-link to=\"/A\">Go to Router-A</router-link>\n    <br/>\n    <router-link :to=\"{name:'B'}\">Go to Router-B</router-link>\n    <br/>\n    <router-link :to=\"{name:'C'}\">Go to Router-C</router-link>\n```\n## 2.编程式导航\n编程式导航相对于`<router-link>`形式来说，增加了灵活性，不再是通过点击事件触发，也可以通过其他方式进行触发路由跳转。\n\n利用`useRouter().push()`方法可以进行路由跳转。\n\n```javascript\nimport {useRouter} from 'vue-router'\nconst router = useRouter()\n// 字符串\nconst toPage=(url:string)=>{\n  // 字符串\n  router.push(url)\n  // 对象形式\n  router.push({\n    path:url,\n    name:'A'\n  })\n}\n```\n\n以对象形式，可以很方便的进行路由传参。\n- 以query的方式传参 传递一个对象，这种传参方式会拼接在URL地址上\n\n```javascript\nrouter.push({\n    path:url,\n    query:{\n      name:'smz',\n      age:18\n    }\n  })\n```\n组件内用useRoute()方式接收参数\n\n```javascript\nconst route = useRoute()\n<div>这是路由传参{{route.query.name}}{{route.query.age}}</div>\n```\n![query](https://img-blog.csdnimg.cn/43878898225d4e9497ae7b06932b1545.png)\n\n-  ~~以params方式传参，这种传参方式必须使用name形式路由跳转，这种不会拼接在URL上，存于内存中，刷新页面后数据消失。~~ \n`在4.1.4版本后移除了params方式`\n- 动态路由参数，在配置路由时可以在后面拼接一个动态参数\n\n```javascript\n// 这些都会传递给 `createRouter`\nconst routes = [\n  // 动态字段以冒号开始\n  { path: '/users/:id', component: User },\n]\n```\n\n```javascript\nrouter.push({\n     name:'A',\n    params:{\n      id:1\n    }\n  })\n```\n\n```html\n<div>这是路由传参params:{{route.params.id}}</div>\n```\n\n\n\n## 3.历史记录\n在进行路由跳转的时候，浏览器会有一个历史记录，用户可以通过左右箭头来到达记录的页面，组织产生历史记录（登录后不再记录登录页）有如下方法：\n\n在`<router-link>`标签中加入 `replace`属性\n\n```javascript\n<router-link replace to=\"/A\">Go to Router-A</router-link>\n```\n\n在编程式导航时，使用 replace()方法\n\n```javascript\nconst router = useRouter()\nrouter.replace(url)\n```\n\n\n---\n\n# 五、嵌套路由\n一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构。\n\n```javascript\n/user/johnny/profile                     /user/johnny/posts\n+------------------+                  +-----------------+\n| User             |                  | User            |\n| +--------------+ |                  | +-------------+ |\n| | Profile      | |  +------------>  | | Posts       | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+\n```\n嵌套路由就是在路由配置的时候添加`children`属性，将子路由放在里面，在父路由页面放`<router-view></router-view>`来放子路由页面\n在路由地址匹配的时候需要拼接上父路由地址。\n\n```javascript\nconst routes = [\n  {\n    path: '/user/:id',\n    component: User,\n    // 请注意，只有子路由具有名称\n    children: [{ path: '', name: 'user', component: UserHome }],\n  },\n]\n```\n\n---\n# 六、命名视图\n\n希望组件在同级展示，在一个地址有多个组件时，可以设置多个`<router-view>`并匹配name属性的值来渲染，当没有设置name 属性的时候默认找default属性的组件。 \n\n```html\n<router-view class=\"view left-sidebar\" name=\"aaa\"></router-view>\n<router-view class=\"view main-content\"></router-view>\n<router-view class=\"view right-sidebar\" name=\"bbb\"></router-view>\n```\n\n```javascript\nconst routes = [\n  {\n   {path: '/D',name:'D',component:{\n        defaults:()=> import('coms/路由/Router-C.vue')\n        }},\n    {path: '/E',name:'E',component:{\n            aaa:()=> import('coms/路由/Router-C.vue'),\n            bbb:()=> import('coms/路由/Router-C.vue')\n        }},\n  },\n]\n```\n\n# 七、重定向-别名\n## 1.重定向\n在访问某个路由时可以通过`redirect`属性来配置该路由访问的路由。其中 `redirect`可以以字符串、对象、函数的形式。\n\n```javascript\n{path: '/E',name:'E',redirect:'/B',component:{\n            aaa:()=> import('coms/路由/Router-C.vue'),\n            bbb:()=> import('coms/路由/Router-C.vue')\n        },children:[\n            {path: '/B',name:'B',component:()=> import('coms/路由/Router-B.vue')},\n        ]},\n```\n\n```javascript\n{path: '/E',name:'E',redirect: {name:'B'},component:{\n            aaa:()=> import('coms/路由/Router-C.vue'),\n            bbb:()=> import('coms/路由/Router-C.vue')\n        },children:[\n            {path: '/B',name:'B',component:()=> import('coms/路由/Router-B.vue')},\n        ]},\n```\n\n```javascript\n{path: '/E',name:'E',redirect: to=>{\n        return '/B'\n        },component:{\n            aaa:()=> import('coms/路由/Router-C.vue'),\n            bbb:()=> import('coms/路由/Router-C.vue')\n        },children:[\n            {path: '/B',name:'B',component:()=> import('coms/路由/Router-B.vue')},\n        ]},\n```\n\n\n## 2.别名\n可以为某个路由起多个名称，利用属性`alias`属性\n\n```javascript\nalias:['/E1','/E2']\n```\n\n\n# 八、进阶\n\n## 导航守卫\n路由守卫都接收三个参数to,from,next，之后将不再赘述。\n### 全局前置守卫\n全局前置守卫：router.beforeEach()\n用来拦截路由跳转，在跳转前做判断有三个参数\n- to: 跳转到哪个路由\n- from: 从哪个路由跳转\n- next(): 执行跳转\n- next(false):终端导航\n- next('/'):跳转到不同的地址，中断当前导航，进行新的导航\n\n  **使用场景**：权限判断\n  在代码中，whileList为路由白名单，也就是在导航到白名单的路由时没有限制，首先判断是否是白名单路由或者本地存有token就放行，否则就跳转到指定路由地址。\n\n```javascript\n// 白名单\nconst whileList = ['/']\nrouter.beforeEach((to,from,next)=>{\n    if (whileList.includes(to.path) || localStorage.getItem('token')){\n        next()\n    }else {\n        next('/')\n    }\n})\n```\n\n### 全局解析守卫\nrouter.beforeResolve()\n他与全局前置守卫差不多，但是调用时机不太一样，他在导航被确认前调用，在组件内路由和一部路由组件被解析，比前置守卫要晚一点。此时是获取数据或者进入页面发生错误时进行操作的最佳位置。\n\n```javascript\nrouter.beforeResolve(async to => {\n  if (to.meta.requiresCamera) {\n    try {\n      await askForCameraPermission()\n    } catch (error) {\n      if (error instanceof NotAllowedError) {\n        // ... 处理错误，然后取消导航\n        return false\n      } else {\n        // 意料之外的错误，取消导航并把错误传给全局处理器\n        throw error\n      }\n    }\n  }\n})\n```\n\n### 全局后置守卫\nrouter.afterEach()\n用来在路由跳转后，做的一些操作，比如加载条,与前置守卫有相同的参数，但是next对路由没影响\n全局后置守卫，感觉没多大用，但是可以和前置守卫配合做一个顶部加载条loadingBar，在前置守卫利用JS添加长度逐渐变长的加载条，然后在90%后，在后置守卫设置为100%，这样就完成了。\n\n后置守卫可以直接在单个路由配置中使用：\n\n```javascript\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: (to, from) => {\n      // reject the navigation\n      return false\n    },\n  },\n]\n```\n\n**场景：做loadingBar**\n\n>loadingBar组件：\n\n```javascript\n<template>\n<div class=\"wraps\">\n  <div ref=\"bar\" class=\"bar\"></div>\n</div>\n</template>\n\n<script setup lang=\"ts\">\n/**\n * requestAnimationFrame:\n *       这里使用该定时器的原因在于采用系统时间，和setTimeout和setInterval不精确，\n *       会导致动画卡顿或者过度绘制，该定时器会将回流与重绘收集起来一起执行。以60帧来渲染\n */\nimport {ref} from 'vue'\n// 进度\nlet speed =ref<number>(1)\nlet bar = ref<HTMLElement>()\nlet timer = ref<number>(0)\n\n\n// 开始加载\nconst startLoading = () =>{\n  let dom = bar.value as HTMLElement\n  timer.value = window.requestAnimationFrame(function fn() {\n    if (speed.value < 90){\n      speed.value +=1\n      dom.style.width = speed.value + '%'\n      timer.value = window.requestAnimationFrame(fn)\n    }else {\n      // 清除定时器\n      speed.value = 1\n      window.cancelAnimationFrame(timer.value)\n    }\n  })\n}\n\n// 结束加载\nconst endLoading= () =>{\n  let dom = bar.value as HTMLElement;\n  setTimeout(()=>{\n    window.requestAnimationFrame(()=>{\n      speed.value = 100\n      dom.style.width = speed.value + '%'\n    })\n  },500)\n}\n\ndefineExpose({\n  startLoading,\n  endLoading\n})\n\n</script>\n\n<style lang=\"less\" scoped>\n.wraps{\n  position: fixed;\n  top: 0;\n  width: 100%;\n  height: 3px;\n  .bar{\n    height: inherit;\n    width: 0%;\n    background: blue;\n  }\n}\n</style>\n```\n\n>挂载到全局实例：\n\n```javascript\nimport loadingBar from \"../src/components/路由/后置守卫/loadingBar.vue\";\nconst Vnode = createVNode(loadingBar)\nrender(Vnode,document.body)\n```\n\n>前置守卫：\n>运行组件`startLoading()`方法\n\n```javascript\n Vnode.component?.extends?.startLoading()\n```\n\n>后置守卫：\n>运行组件`endLoading()`方法\n\n```javascript\nVnode.component?.extends?.endLoading()\n```\n![加载](https://img-blog.csdnimg.cn/dd0b3f1e650a4eda92b5979001585b35.gif)\n\n\n### 组件内的守卫\n顾名思义就是在组件内定义的路由守卫，然后传递给路由配置，总共有三个组件内守卫。\n\n- beforeRouteEnter\n  该守卫是不能访问`this`的，因为该守卫执行的时候，组件还未被创建，但是可以通过`next()`的回调拿到组件实例。\n\n```javascript\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n```\n\n- beforeRouteUpdate\n- beforeRouteLeave\n  离开守卫的应用场景是：用户在未保存的情况下突然跳转。通过返回false取消跳转\n\n```javascript\nbeforeRouteLeave (to, from) {\n  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n  if (!answer) return false\n}\n```\n\n```javascript\nconst UserDetails = {\n  template: `...`,\n  beforeRouteEnter(to, from) {\n    // 在渲染该组件的对应路由被验证前调用\n    // 不能获取组件实例 `this` ！\n    // 因为当守卫执行时，组件实例还没被创建！\n  },\n  beforeRouteUpdate(to, from) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，\n    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`\n  },\n  beforeRouteLeave(to, from) {\n    // 在导航离开渲染该组件的对应路由时调用\n    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`\n  },\n}\n```\n\n完整导航解析流程：\n\n1. 导航被触发。\n2. 在失活的组件里调用 beforeRouteLeave 守卫。\n3. 调用全局的 beforeEach 守卫。\n4. 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。\n5. 在路由配置里调用 beforeEnter。\n6. 解析异步路由组件。\n7. 在被激活的组件里调用 beforeRouteEnter。\n8. 调用全局的 beforeResolve 守卫(2.5+)。\n9. 导航被确认。\n10. 调用全局的 afterEach 钩子。\n11. 触发 DOM 更新。\n12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n##  路由元信息\n路由元信息，希望路由上附带其他的一些信息，如权限校验标识，路由组件过度名称，持久化缓存keep-alive配置，标题名称，在路由中添加 `meta`对象，在里面可以定义一些值让路由更具表达性，可以在导航守卫或者路由对象中读取路由元信息。\n\n```javascript\nroutes:[\n        {\n            path:'/',\n            component:()=>import('@/views/路由/前置守卫/Login.vue'),\n            meta:{\n                title: '登录',\n                transition:\"animate__fadeIn\"\n            }\n        },\n        {\n            path:'/home',\n            component:()=>import('@/views/路由/前置守卫/Home.vue'),\n            meta:{\n                title: '主页',\n                transition:\"animate__bounceIn\"\n            }\n        }\n    ]\n```\n\n获取路由元信息：\n\n```javascript\nrouter.beforeEach((to,from,next)=>{\n    document.title = to.meta.title\n})\n```\n\n\n## 过渡动效\n利用meta定义 transition 属性来指定进入该路由的过渡css样式，这里采用了animate.css 来做动效\n改造`<router-view>`标签，利用插槽和过度组件：\n- router:当前路由信息,\n- Component：当前VNode\n\n```javascript\n       <router-view v-slot=\"{ router,Component }\">\n            <transition :name=\"route.meta.transition\">\n              <component :is=\"Component\" />\n            </transition>\n       </router-view>\n```\n\n```javascript\n    routes:[\n        {\n            path:'/',\n            component:()=>import('@/views/路由/前置守卫/Login.vue'),\n            meta:{\n                title: '登录',\n                transition:\"animate__fadeIn\"\n            }\n        },\n        {\n            path:'/home',\n            component:()=>import('@/views/路由/前置守卫/Home.vue'),\n            meta:{\n                title: '主页',\n                transition:\"animate__bounceIn\"\n            }\n        }\n    ]\n```\n\n![过渡动画](https://img-blog.csdnimg.cn/7233658f887847fba5a24e28bdcf0103.gif)\n\n\n## 滚动行为\n在跳转路由时,想要页面滚动到顶部，或者保持原先位置，vue-router提供了方法`scrollBehavior`\n方法接收三个参数：\n-  to: 路由到哪\n- from: 当前路由\n- savePosition: 通过浏览器前进和后退能使用该参数，记录上一次位置\n  vue-router3中是x和y， vue-router4中是top和left\n\n  return 期望滚动到哪个的位置\n\n```javascript\nconst router = createRouter({\n  scrollBehavior(to, from, savedPosition) {\n    // 始终滚动到顶部\n    return { top: 0 }\n  },\n})\n```\n\n\n在官网中也列举了几种特殊的滚动条件，如滚动到锚点、滚动到某个元素、延迟滚动等\n[滚动行为](https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html)\n\n## 路由懒加载\n\n在vue-router中支持动态导入\n\n```javascript\n// 将\n// import UserDetails from './views/UserDetails.vue'\n// 替换成\nconst UserDetails = () => import('./views/UserDetails.vue')\n```\n\n但是这里要记录的是vite和webpack分包的配置，虽然vue-router官网只是说vite和webpack可以将组件分包打包，但是这个配置对其他文件也适用，如第三方库等，都可以进行分包。\n>vite：\n\n```javascript\n  build: {\n      rollupOptions:{\n        manualChunks: {\n          vue:['vue'],\n          elementPlus:['element-plus'],\n          pinia:['pinia'],\n          vueRouter:['vue-router']\n        }\n      }\n    }\n```\n![vite打包](https://img-blog.csdnimg.cn/b51b009327d4408cb5429297a3884547.png)\n>webpack：\n\n```javascript\nconst UserDetails = () =>\n  import(/* webpackChunkName: \"group-user\" */ './UserDetails.vue')\nconst UserDashboard = () =>\n  import(/* webpackChunkName: \"group-user\" */ './UserDashboard.vue')\nconst UserProfileEdit = () =>\n  import(/* webpackChunkName: \"group-user\" */ './UserProfileEdit.vue')\n```\n\n## 动态路由\n一般动态路由是用来做权限控制的，路由由后端返回，在这里就需要将后端返回的路由添加到路由中，其中使用`router.addRoute()`和`router.removeRoute()`方法来添加路由和删除路由，这样就要使用 `router.push()`或者`router.replace()`手动导航，才能显示新路由。\n\n### 删除路由\n有几个不同的方法来删除现有的路由：\n\n- 通过添加一个名称冲突的路由。如果添加与现有途径名称相同的途径，会先删除路由，再添加路由：\n\n```javascript\nrouter.addRoute({ path: '/about', name: 'about', component: About })\n// 这将会删除之前已经添加的路由，因为他们具有相同的名字且名字必须是唯一的\nrouter.addRoute({ path: '/other', name: 'about', component: Other })\n```\n- 通过调用 router.addRoute() 返回的回调：没有名称时\n\n```javascript\nconst removeRoute = router.addRoute(routeRecord)\nremoveRoute() // 删除路由如果存在的话\n```\n\n- 通过使用 router.removeRoute() 按名称删除路由：\n\n```javascript\nrouter.addRoute({ path: '/about', name: 'about', component: About })\n// 删除路由\nrouter.removeRoute('about')\n```\n\n`需要注意的是，如果你想使用这个功能，但又想避免名字的冲突，可以在路由中使用 Symbol 作为名字。`\n`当路由被删除时，所有的别名和子路由也会被同时删除`\n\n### 添加嵌套路由\n\n大多数情况下，后端返回的路由信息都是有嵌套的，这就需要进行添加嵌套路由的操作，其中有两种方式：\n\n- 可以将路由的 name 作为第一个参数传递给 router.addRoute()，这将有效地添加路由，就像通过 children 添加的一样：\n\n```javascript\nrouter.addRoute({ name: 'admin', path: '/admin', component: Admin })\nrouter.addRoute('admin', { path: 'settings', component: AdminSettings })\n```\n\n- 后端返回的路由信息大多数都是直接以最佳路由形式返回的，就直接添加就完了。\n\n```javascript\nrouter.addRoute({\n  name: 'admin',\n  path: '/admin',\n  component: Admin,\n  children: [{ path: 'settings', component: AdminSettings }],\n})\n```\n\n---\n# 总结\n\n本文主要记录vue-router的使用与原理剖析，如果想要对项目vue-router进行升级，可以参考官网对[改动说明](https://router.vuejs.org/zh/guide/migration/)。\n\n","tags":["前端","Vue3","路由","Vue-Router"],"categories":["Vue","前端","Vue-Router","路由"]},{"title":"状态管理容器Pinia","url":"/2023/09/25/状态管理容器Pinia/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录Vue3状态管理工具Pinia的介绍与使用\n\n---\n\n\n\n# 一、集中式状态管理容器\n\n## 1、VueX\n集中式管理状态容器，可以实现任意组件之间的通讯 \n\n核心：\n 1. state 存储数据\n 2. mutations 唯一修改数据\n 3. actions 处理异步、处理业务\n 4. getters 计算属性\n 5. modules 模块式开发\n\n\n## 2、Pinia\n \n集中式管理状态容器，可以实现任意组件之间的通讯 \n核心：\n 1. state 存储数据\n 2. actions 修改数据、处理异步、处理业务\n 3. getters 计算属性\n\n优点：\n1. 完全支持TS，在JS中也提供自动补全\n2. 体积小\n3. 去除了 VeuX 的 mutations 和 modules\n4. actions 可同步也可异步\n5. 每个store都是独立的仓库，在打包时可拆分每个仓库\n6. 极致轻量化\n7. 自动加载store\n8. 支持Vue2和Vue3\n9. 可拓展性，可以通过本地存储等方式扩展PInia\n\n\n### 创建步骤：\n1. 安装Pinia\n\n```javascript\nnpm install pinia -S\n```\n\n2. 建立大仓库\n\n这里有两种方式建立大仓库：\n   \n- 直接在Mian.ts文件中建立\n   \n```javascript\nimport {createPinia,PiniaVuePlugin} from \"pinia\";\nlet store = createPinia()\napp.use(store)\n```\n\n   -  在其他文件下创建\n   \n\n```javascript\n// index.ts\nimport {createPinia,PiniaVuePlugin} from \"pinia\";\n/**\n * 利用createPinia方法创建大仓库(在Vue2中使用PiniaVuePlugin)\n * 并对外暴露该仓库\n * 在全局引入\n */\nlet store = createPinia()\nexport default store\n```\n全局引入：\n\n```javascript\nimport store from \"./store\";\napp.use(store)\n```\n`在Vue3中使用createPiniaAPI, Vue2中使用PiniaVuePluginAPI`\n   \n3. 建立小仓库\n- 利用defineStoreAPI创建小仓库\n这里创建小仓库，必须传一个唯一名称，用来创建唯一的仓库，也就对应了他所说的模块化了吧。这里小仓库可以选择一个小仓库对应一个文件，也可以多个小仓库组成一个功能模块在一个文件中。\n这里也分为选择式和组合式两种\n \n **选择式：**\n   \n\n```javascript\n/**\n * 选择式API仓库\n * defineStore方法定义小仓库，带两个参数\n *   1、仓库名称\n *   2、仓库配置对象\n * defineStore返回一个函数，让组件可以获取到仓库数据\n * 存储数据：state\n * 需对外暴露方法\n */\nimport {defineStore} from \"pinia\";\nlet userInfoStore = defineStore(\"info\",{\n    state:()=>{\n        return {\n            count: 99,\n            arr: [1,2,3,4,5,6,7,8,9,10]\n        }\n    },\n    actions: {\n        //内部没有context上下文对象\n        //没有commit、没有mutations去修改数据\n        updateNum(a:number,b:number){\n            this.count+=(a+b)\n        }\n    },\n    getters: {\n        total() {\n            let result:number = this.arr.reduce((prev,next)=>{\n                return prev+next\n            },0)\n            return result\n        }\n    }\n})\nexport default userInfoStore\n```\n\n\n **组合式：**\n\n```javascript\n/**\n * 定义组合式API仓库\n * 务必返回一个对象：属性与方法可以提供给组件使用\n */\nimport {defineStore} from \"pinia\";\nimport {computed, reactive} from \"vue\";\nlet userTodoStore = defineStore(\"todo\",()=>{\n\n    let todos = reactive([{id:1,title:'吃饭'},{id:2,title:'睡觉'}])\n   let arr = reactive([1,2,3,4,5,6])\n    const total = computed(()=>{\n        return arr.reduce((prev,next)=>{\n            return prev+next\n        },0)\n    })\n    return {\n        todos,\n        total,\n        updateTodo(){\n            todos.push({id:3,title: '组合式API'})\n        }\n    }\n})\nexport default userTodoStore\n```\n---\n\n这里命名也可以通过枚举类来管理名称\n\n```javascript\nexport const enum Names {\n    TEST='TEST'\n}\n```\n\n使用：\n\n```javascript\nimport {Names} from \"../store-name\";\nimport {defineStore} from 'pinia'\n\nexport const useTestStore = defineStore(Names.TEST,{\n    state:()=>{\n        return {\n            current:1,\n            name:'smz'\n        }\n    },\n    getters:{\n\n    },\n    actions:{}\n})\n```\n\n---\n### 用法：\n #### 1、选择式\n   修改数据：\n   -  使用返回的函数直接修改其属性\n\n```javascript\nimport userInfoStore from \"../../../store/modules/info\";\nlet infoStore = userInfoStore()\ninfoStore.count++\n```\n\n   - 使用返回函数上的$patch方法\n\n```javascript\nimport userInfoStore from \"../../../store/modules/info\";\nlet infoStore = userInfoStore()\ninfoStore.$patch({count:222})\n```\n\n   - 使用自定义方法，在actions中定义方法，可传参\n\n```javascript\nimport userInfoStore from \"../../../store/modules/info\";\nlet infoStore = userInfoStore()\ninfoStore.updateNum(1,2)\n```\n仓库：\n\n```javascript\n actions: {\n        //内部没有context上下文对象\n        //没有commit、没有mutations去修改数据\n        updateNum(a:number,b:number){\n            this.count+=(a+b)\n        }\n    },\n```\n\n`           注：在方法内部要用this，this指向仓库对象`\n\n #### 2、组合式\n   修改数据：\n- 使用返回的函数直接修改其属性\n  \n\n```javascript\nimport userTodoStore from \"../../../store/modules/todo\";\nlet todoStore = userTodoStore()\n todoStore.todos[0].title = '喝水'\n```\n\n- 使用computed计算属性，将计算值返回就能获取\n     \n\n```javascript\n  const total = computed(()=>{\n             return arr.reduce((prev,next)=>{\n                return prev+next\n             },0)\n           })\n```\n- 使用自定义方法，在return中定义方法，可传参\n   \n\n```javascript\n    updateTodo(){\n               todos.push({id:3,title: '组合式API'})\n            }\n```\n\n   ` 注：在方法内部要用this，this指向仓库对象`\n\n---\n# 二、state\n## 修改值\n修改state中的数据有以下五种方式：\n修改值的方法：\n 1. 直接修改\n\n```javascript\nTest.current++\n```\n\n 2. 使用函数上自带的$patch方法\n \n\n```javascript\nTest.$patch({current:888,name:'smz2'})\n```\n\n 3. 以$patch箭头函数形式\n 这里的state就是仓库里的state\n```javascript\nTest.$patch((state)=>{state.current = 999})\n```\n\n 4.使用函数上自带的$state方法\n \n该方法需要修改整个对象\n```javascript\n Test.$state = {current:2000,name: \"smz3\"} \n```\n\n 5. 在actions内定义方法，用this直接修改值\n\n```javascript\n    actions:{setCurrent(number){this.current = number}}\n    Test.setCurrent(28888)\n```\n    \n  ---\n    \n## 解构\nstate解构\n  \n\n```javascript\n const {current,name} = Test\n```\n\n   这样解构出来的值是不具备数据响应式的\n   需要使用 storeToRefs 包裹 和toRefs效果一致\n   \n\n```javascript\nimport {storeToRefs} from 'pinia'\nconst {current,name} = storeToRefs(Test)\n```\n\n---\n\n# 三、actions - getters\n\n## actions\nactions可以用同步也可以使用异步\n### 同步\n\n```javascript\nlet result:User = {\n    name: 'Pinia'\n}\n\n// actions内\n setUser(){\n           this.user = result\n        },\n```\n\n### 异步\n\n```javascript\nconst Login = ():Promise<User> =>{\n    return new Promise(resolve => {\n        setTimeout(()=>{\n            resolve({\n                name:\"1234\"\n            })\n        },2000)\n    })\n}\n\n// actions内\n async setUser2(){\n           this.user =await Login()\n        }\n```\n\n### 相互调用\nactions内的方法是可以相互调用的\n\n```javascript\n setCurrent(number){\n           this.current = number\n       },\n        setUser(){\n           this.user = result\n            this.setCurrent(666)\n        },\n```\n\n## getters\n用来修饰值，这里有两种写法，在其中是可以相互调用的\n\n\n```javascript\n  getters:{\n        newName():string{\n            return `name: ${this.name}`\n        },\n        newName2():string{\n            return this.newName()\n        }\n    },\n```\n\n---\n\n# 四、API\n## $reset\n重新初始化仓库，直接使用就可以将仓库初始化成原始值\n\n```javascript\nTest.$reset()\n```\n\n## $subscribe\n\n响应 store 变化，该方法会监听state中的数据变化，与watch有相同的功能，比起普通的 watch()，使用 $subscribe() 的好处是 subscriptions 在 patch 后只触发一次\n可以设置detached:true 来控制组件被销毁时也能继续监听,还包括了其他一些配置项\n\n```javascript\nTest.$subscribe((args,state)=>{\n  console.log(args)\n  console.log(state)\n},{\n  detached:true,\n  deep:true,\n  flush:'post'\n})\n```\n\n## $onAction\n监听action，在一个action即将被调用时，将触发该方法，回调接收一个对象， 其包含被调用 action 的所有相关信息：\n\n- store: 被调用的 store\n- name: action 的名称\n- args: 传递给 action 的参数\n\n除此之外，它会接收两个函数， 允许在 action 完成或失败时执行的回调。\n\n```javascript\nTest.$onAction(({ after, onError }) => {\n // 你可以在这里创建所有钩子之间的共享变量，\n // 同时设置侦听器并清理它们。\n after((resolvedValue) => {\n   // 可以用来清理副作用 \n   // `resolvedValue` 是 action 返回的值，\n   // 如果是一个 Promise，它将是已经 resolved 的值\n })\n onError((error) => {\n   // 可以用于向上传递错误\n })\n},true)\n```\n\n它还会返回一个用来删除回调的函数。 请注意，当在组件内调用 store.$onAction() 时，除非 detached 被设置为 true， 否则当组件被卸载时，它将被自动清理掉。\n\n\n---\n\n# 五、Pinia插件\n在Pinia中，数据在页面刷新后将被重新初始化，所以需要一个持久化插件来解决这个问题，原理都是将其存入localStorage中\n使用现成的持久化插件：\n\n```javascript\npinia-plugin-persistedstate\n```\n\n- 安装：\n\n```javascript\npnpm i pinia-plugin-persistedstate\n```\n\n- 挂载：\n\n```javascript\nimport { createPinia } from 'pinia'\nimport piniaPluginPersistedstate from 'pinia-plugin-persistedstate'\n\nconst pinia = createPinia()\npinia.use(piniaPluginPersistedstate)\n```\n- 开启持久化\n\n```javascript\nconst useTestStore = defineStore(\"Test\",{\n  // 开启数据持久化\n  persist: true\n});\n```\n\n一些其他配置：\n\n```javascript\nimport { defineStore } from 'pinia'\n\nexport const useStore = defineStore('main', s{\n  state: () => {\n    return {\n      someState: 'hello pinia',\n      nested: {\n        data: 'nested pinia',\n      },\n    }\n  },\n  // 所有数据持久化\n  // persist: true,\n  // 持久化存储插件其他配置\n  persist: {\n    // 修改存储中使用的键名称，默认为当前 Store的 id\n    key: 'storekey',\n    // 修改为 sessionStorage，默认为 localStorage\n    storage: window.sessionStorage,\n    // 部分持久化状态的点符号路径数组，[]意味着没有状态被持久化(默认为undefined，持久化整个状态)\n    paths: ['nested.data'],\n  },\n})\n\n```\n\nPInia持久化参考了文章：[Pinia的使用以及数据持久化](https://juejin.cn/post/7101657189428756516)\n\n---\n\n# 总结\nPinia相对于VueX来说，简化了API的使用，支持TS，让学习成本大大降低。\n\n","tags":["前端","Vue3","状态管理","Pinia","持久化存储"],"categories":["Vue","前端","Vue3","状态管理","状态管理","Pinia"]},{"title":"Vue3 环境变量","url":"/2023/09/20/Vue3 环境变量/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录在项目中如何定义环境变量，达到不同环境中有不同的效果以及在vite配置文件中读取环境变量的方法。\n\n---\n\n\n# 一、环境变量简介\n\n场景：各个环境下存在某些差异，比如请求地址不同，方便测试做的一些测试功能，\n这些在不同环境下都是不同的，所以需要一些环境变量来控制\n自带的环境变量存在于 import.meta.env 中\n\n```javascript\n BASE_URL: \"/\"  ===>路由应用前缀\nDEV: true  ===>npm run dev 设置为true 当前运行环境开发环境\nMODE: \"development\" ===》当前运行环境\nPROD: false ===>npm run build 生产环境\nSSR: false ===》服务端渲染\n```\n\n![内置环境变量](https://img-blog.csdnimg.cn/8df3ff8615ce41848b87b4542909a14f.png)\n\n\n这些环境变量可修改，但是不要做动态修改 import.meta.env[BASE_URL] = 'BASE_URL'，\n生产环境是硬编码，写死的\n\n---\n# 二、自定义环境变量\n自定义环境变量\n- 在根目录下创建.env.xxxx文件\n如开发环境变量文件：.env.development\n   生产环境变量文件：.env.production\n\n- 以VITE_开头自定义环境变量\n~~在 package.json 中 在dev补充 \"dev\":--mode development ===> \"vite --mode development\",~~\n生产环境会默认读取.env.production文件内容，不用配置\n\n<font color = hotpink size=3>开发环境也会默认读取.env.development文件内容，不用配置 </font>\n\n\n![开发环境](https://img-blog.csdnimg.cn/31d2c1ec2a6d41db8a554b29043e3b38.png)\n\n## 生产环境预览\n生产环境在打包好后无法在本地直接运行index.html，需要为他开启一个服务\n  - 安装 http-server ：npm install http-server -g\n -  开启服务：在打包文件下（dist）执行命令 http-server -p 9002 就可以在本地查看效果\n\n![打包预览](https://img-blog.csdnimg.cn/7bb459d56589446590f29e959ff1fb0f.png)\n\n\n---\n\n# 三、vite配置文件读取环境变量\n\n在vite.config中读取环境变量，因为是Node环境编译无法通过import.meta.env读取环境变量需要进行改造，使用 process.env 可读取到机器的环境变量，但是读取不到我们定义的环境变量， 需要使用 Vite 的 **loadEnv** 包 ，loadEnv接收两个参数\n - 第一个为运行环境\n 运行环境通过回调获取，所以这里需要对导出做改造 将其变成箭头函数，再将配置 return返回\n 回调返回mode就是当前环境，将其作为第一个参数传入 loadEnv\n - 第二个为目录\n 再通过process.cwd()获取当前项目根目录，将其作为第二个参数传入 loadEnv\n 最终就可以读到环境变量了\n\n\n```javascript\nexport default ({mode}:any)=>{\n  console.log(loadEnv(mode,process.cwd())) // 读取环境变量\n  return defineConfig({\n    plugins: [vue()],\n    // 别名配置\n    resolve: {\n      alias: {\n        \"@\": path.resolve(__dirname, \"src\"),\n        \"coms\": path.resolve(__dirname, \"src/components\"),\n      },\n    },\n    css:{\n      // 预处理器\n      preprocessorOptions: {\n        scss:{\n          additionalData: `@import\"./src/views/BEM架构与layout布局/index.scss\";`\n        }\n      },\n      postcss:{\n        plugins:[PostcssPxToViewport()]\n      }\n    }\n  })\n}\n```\n\n![vite配置文件读取环境变量](https://img-blog.csdnimg.cn/02695b4706b249019a6801dd31fecf71.png)\n\n\n---\n# 总结\n\n以上就是自定义环境变量，和在vite配置文件中读取环境变量的全部介绍。\n","tags":["前端","Vue3","环境变量"],"categories":["Vue","前端","Vue3","环境变量"]},{"title":"Vue3 函数式编程","url":"/2023/09/19/Vue3函数式编程/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录vue3中的函数式编程以及其他编程风格的简介\n\n---\n\n\n\n# 一、三种编程风格\n## 1.template\nVue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。\n也就是HTML的书写方式。\n\n```html\n <template>\n         <div>\n           <template v-if=\"reverse\">\n             <div class=\"bar\">Bar DOM...</div>\n             <div class=\"foo\">Foo DOM...</div>\n           </template>\n           <template v-else>\n             <div class=\"foo\">Foo DOM...</div>\n             <div class=\"bar\">Bar DOM...</div>\n           </template>\n         </div>\n       </template>\n```\n\n## 2.jsx/tsx\n这是一种DOM标签和JS混用的方式，对DOM操作更加灵活，发挥出JS的完全编程能力，但是需要手动实现渲染优化，Vue在模板语法中做的优化在此方式中不适用\n如：根据 props 上的 reverse 属性，来决定是否要调换两块内容的渲染顺序。\n\n>jsx：\n\n```javascript\nconst renderContent = () => {\n       const Content = [\n         <div class=\"foo\">Foo DOM...</div>,\n         <div class=\"bar\">Bar DOM...</div>,\n       ];\n       if (props.reverse) {\n         Content.reverse();\n       }\n       return <div>{Content}</div>;\n     }\n```\n\n>template：\n\n```html\n<template>\n         <div>\n           <template v-if=\"reverse\">\n             <div class=\"bar\">Bar DOM...</div>\n             <div class=\"foo\">Foo DOM...</div>\n           </template>\n           <template v-else>\n             <div class=\"foo\">Foo DOM...</div>\n             <div class=\"bar\">Bar DOM...</div>\n           </template>\n         </div>\n </template>\n```\n\n\n## 3.函数式编写风格\nvue中提供了h函数,h 函数是一个重载函数，支持多种调用方式，但在内部会处理为符合 createVNode 函数的入参，然后交给 createVNode 来创建虚拟 DOM。在此可以利用vue3提供的render函数将此虚拟DOM创建成真实DOM并挂载到指定结点。\n可以直接跳过模板的编译过程\n> parser函数 -> ast抽象语法树 -> transform -> js 可描述api -> generate生成 -> render\n\n```html\n<div><span>1</span></div>\n```\n>转换函数式为：\n\n```javascript\nlet render = () =>{\n       return h('div),{},[\n         h('span),{},'1']\n     }\n```\n\n\n\n\n\n# 二、函数式编程\n## 1.使用场景\n封装一些小组件（弹窗、按钮等）\n## 2.参数\nh 函数有三个参数\n- 第一个是创建的结点\n- 第二个是节点属性\n- 第三个是节点内容\n## 3.例子\n\n代码如下（示例）：\n\n```javascript\ninterface Props {\n  type: 'success' | 'error'\n}\nconst Btn = (props:Props,ctx:any) =>{\n  return h('button',\n      {\n        style: {\n          color:props.type === 'success'? 'green': 'red'\n        },\n        onClick:()=>{\n          ctx.emit('click','smz')\n          console.log('点击了按钮',props.type)\n        }\n      },\n      ctx.slots.default()\n  )\n}\n```\n\n```html\n<template>\n<Btn type=\"success\">编辑</Btn>\n  <Btn type=\"error\">删除</Btn>\n</template>\n```\n\n## 3.render渲染函数\n该函数由vue内部提供，可以将标签或者虚拟DOM转换成真实DOM并挂载到指定结点\n该函数接收两个参数：\n\n- 标签或虚拟dom\n当该参数为null时，会将此组件移除\n- 挂载结点\n\n>例子：（提示组件）\n\n```javascript\nexport const message = (message, duration = 2000) =>{\n    const handleDestroy = () =>{\n        render(null,document.body)\n    }\n    const vNode = h(\n        'messageComponent',\n        {\n            style:{\n                width: '200px',\n                height: '100px',\n                border: '2px solid',\n                float: 'left',\n                position: 'relative',\n                left: '50%',\n                'margin-left': '-50px'\n            },\n            message,\n            duration,\n            destroy:handleDestroy\n        },message)\n    render(vNode,document.body);\n        (function () {\n          setTimeout(()=>render(null,document.body),duration)\n        })()\n}\n```\n>使用：直接以API的形式调用\n\n```javascript\nconst messages = () =>{\n  message('这是一个提示窗')\n}\n```\n![弹窗提示](https://img-blog.csdnimg.cn/ab6e77a6e1864c96a11b810590d380ef.png)\n\n \n\n---\n\n# 总结\n以上就是三种编码风格以及vue3中h函数和render函数的简单实用。\n\n","tags":["前端","Vue3","函数式编程","h函数","render函数"],"categories":["Vue","前端","Vue3","函数式编程"]},{"title":"移动端适配以及多屏幕自适应方案","url":"/2023/09/18/移动端适配以及多屏幕自适应方案/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录适配移动端以及多屏幕的解决办法，还有postcss转换插件的编写。\n\n---\n\n\n# 一、移动端适配问题\n在MDN中提到：\n>在移动设备和其他窄屏设备中，某些内容在比普通屏幕更宽的虚拟窗口或视口中渲染页面，然后缩小渲染的结果，以便可以一次看到所有内容。然后，用户可以通过平移和缩放以查看页面的不同区域。例如，如果移动屏幕的宽度为 640px，则页面可能会使用 980px 的虚拟视口渲染，然后页面将缩小以适应 640px 的空间。\n\n![横向滚动条](https://img-blog.csdnimg.cn/9fbf5e289f2947108560c344d9d353af.gif)\n\n\n换成通俗易懂的话就是说，为了适配窄屏，他会把渲染视口以短边进行截断，然后就出现了横向滚动条，让用户能够左右滑动来查看完整的页面，但是这样做对移动端有很大的问题，左右滑动对移动端的用户体验大打折扣。\n所以需要某种机制或者方法来适配移动端。\n以下是最为常见的移动端适配方案。\n\n---\n# 二、meta-viewport标记\nmeta标签写在`<head>`标签中\n\n```javascript\n<head>\n    <meta charset=\"UTF-8\">\n<!--    移动端适配-->\n    <meta name=\"viewport\" content=\"with=device-width,initial-scale=1.0\">\n    <title>Title</title>\n</head>\n```\n其中有很多选项用来调整视口与屏幕的关系\n- **width**\n控制视口的大小。这可以设置为特定像素数（如'width=600'），也可以设置为特殊值device-width，即 100vw，100% 的视口宽度。最小值为 1。最大值为 10000。负值会被忽略。\n\n- **height**\n控制视口的大小。这可以设置为特定像素数（如 width=600），也可以设置为特殊值 device-height，即 100vh，100% 的视口高度。最小值为 1。最大值为 10000。负值会被忽略。\n\n- **initial-scale**\n控制页面首次加载时显示的缩放倍数。最小值是 0.1。最大值是 10。默认值为 1。负值会被忽略。\n\n- **minimum-scale**\n控制页面允许缩小的倍数。最小值是 0.1。最大值是 10。默认值为 1。负值会被忽略。\n\n- **maximum-scale**\n控制页面允许放大的倍数。设置一个低于 3 的值将不具备无障碍访问性。最小值是 0.1。最大值是 10。默认值为 1。负值会被忽略。\n\n- **user-scalable**\n控制是否允许页面上的放大和缩小操作。有效值为 0、1、yes 或 no。默认值为 1，与 yes 相同。将值设置为 0（即与 no 相同）将违反 Web 内容无障碍指南（WCAG）。\n\n- **interactive-widget**\n指定交互式 UI 组件（如虚拟键盘）对页面视口的影响。有效值：resizes-visual、resizes-content 或 overlays-content。默认值：resizes-visual。\n- **viewport-fit**\n设置为 cover 可以解决 **刘海屏** 的留白问题\n\n最终完整的meta标签可以写成：\n\n```javascript\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover\">\n```\n\n\n在创建vue项目时，他会在index.html中自动加入这个标签。\n\n```javascript\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Vite + Vue + TS</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <script type=\"module\" src=\"/src/main.ts\"></script>\n  </body>\n</html>\n```\n\n**优点：**\n\n-  不需要考虑一些屏幕计算问题，直接使用设计稿中的数值就可以\n\n**缺点：**\n \n - 存在兼容问题，部分安卓机识别不了完整的meta属性\n - 使整个页面都进行了适配，导致某些不用适配的也参与了适配\n - 图片会失真\n\n---\n\n# 三、rem字体适配\nrem是个长度单位，表示相对根元素的字体大小，例如根元素为14px，那么1rem表示14px，2rem表示28px。\n利用JS控制根元素的字体大小就可以控制整个页面的字体大小的适配\n首先是需要获取当前视口宽，利用宽动态调整根元素字体大小`document.documentElement.clientWidth`。\n利用`window.onresize`监听当前窗口变化\n\n其中关键点是以下的两个点：\n \n - 计算对应宽度的根元素字体大小\n    \n    这个一般设计稿会给，设计稿都是固定某个宽，上边对应的字体大小就是这个宽对应的字体大小，就比如设计稿给我们一个宽375px，字体28px的设计稿，那么其他宽度对应的字体大小就是：**其他宽度 × 28 ÷ 750**\n   \n - 计算子元素字体与根元素对应关系\n  这个也是根据设计稿计算个比例就可以了，例如一个根元素是28px，子元素是14px，那么转换成rem就是：14 ÷ 28 = 0.5 rem\n     这个也有一些插件可以实现将px自动转换成rem，如postcss-pxtorem，参考文章：[px自动转rem](https://juejin.cn/post/7217999296263553081)\n\n\n```javascript\n<style>\n  .box{\n    font-size: 3rem;\n  }\n  #text{\n      font-size: 0.5rem;\n  }\n</style>\n<body>\n<div class=\"box\">\n  smz\n</div>\n<div id=\"text\"></div>\n</body>\n<script>\n  function adapter() {\n    const text = document.querySelector('#text')\n    //获取布局视口宽度，布局视口=设备横向独立像素值\n    const dpWidth = document.documentElement.clientWidth\n    //计算根字体大小\n    const rootFonstSize = (dpWidth * 28)/375\n    //设置根字体大小\n    document.documentElement.style.fontSize = rootFonstSize + 'px'\n    text.innerText = `当前根元素字体大小:${document.documentElement.style.fontSize}`\n  }\n  adapter()\n  // 监听窗口变化\n  window.onresize = adapter\n</script>\n```\n\n![rem](https://img-blog.csdnimg.cn/d6d9752eb072493a8bd54ba6c4fc7fc3.gif)\n\n---\n\n# 四、vw和vh\nvw和vh也是长度单位，他与传统的以像素为单位不同，他是以视口百分比为单位\n`对于百分比布局有一定的区别，百分比是相对于父元素，尔vw和vh是相对于视口的`\n\n-  1vw:表示视口宽度的百分之1\n- 1vh：表示视口高度的百分之1\n\n也就是说100vw和100vh表示整个视口\n\n使用vw和vh就不用再使用JS控制了\n同样，使用此单位也需要计算设计稿中px与视口比例关系：对应像素长度 × 100vw ÷ 设计稿屏幕像素宽\n\n>less文件：\n```javascript\nbody{\n  @basic:375/100vw;\n  .box{\n    width: 300/@basic;\n    height: 150/@basic;\n    background: red;\n    margin: auto;\n  }\n}\n```\n\n![vw](https://img-blog.csdnimg.cn/45b3377ce4e14e86a21541f86b9a9e58.gif)\n\n---\n\n# 五、postcss转换插件\n\n>在vite开发的项目中集成了postcss，可以利用postcss编写一个全局转换的的一个方法，可以快速将px转换成vw，或者对某些可以做到不转换。\n\n- 在项目目录下新建plugins目录用来存放插件\n\n- 在tsconfig.node.json下添加配置项\n![tsconfig.node.json](https://img-blog.csdnimg.cn/e4b774bf3bc04dbf955bec0b954e4401.png)\n\n- 在plugins目录下新建ts文件编写插件\n\n```javascript\nimport {Plugin} from \"postcss\";\n// 默认宽度\nconst Options = {\n    viewportWidth: 375 //UI设计稿宽度\n}\ninterface Options {\n    viewportWidth?:number\n}\nexport const PostcssPxToViewport = (options:Options = Options):Plugin =>{\n    const opt = Object.assign({},Options,options)// 将Options,options复制到同一对象中\n    return {\n        postcssPlugin : \"postcss-px-to-viewport\",// 名称\n        //钩子函数 取css结点\n        Declaration(cssNode){\n            // 这里可以改名字‘smz’ 改成需要转换的，比如‘smz’ 就只针对 单位为'smz'的css结点进行转换\n            if (cssNode.value.includes('smz')){// cssNode.value.includes('px')对含有px单位的css结点，可更改\n                const num = parseFloat(cssNode.value)// 转换成数字去掉px\n                cssNode.value =  `${(( num / opt.viewportWidth) * 100).toFixed(2)}vw` // 计算公式\n            }\n        }\n    }\n}\n```\n\n- 在vite.config.ts引入注册插件\n\n![引入插件](https://img-blog.csdnimg.cn/17c5aa65839a458880fc544f32838fd4.png)\n\n>使用：\n\n```javascript\n<template>\n<div class=\"box\">\n  postcss转换插件\n</div>\n  <div class=\"box2\">\n    普通未转换\n  </div>\n</template>\n\n<style scoped>\n.box{\n  width: 200smz;\n  height: 100smz;\n  font-size: 20smz;\n  border: 3px solid red;\n}\n.box2{\n   width: 200px;\n   height: 100px;\n   font-size: 20px;\n  border: 3px solid yellow;\n }\n</style>\n```\n\n![postcss转换插件](https://img-blog.csdnimg.cn/5f5ecd20e8eb421e96536af5d3702b29.gif)\n\n\n# 总结\n以上三种方案，是相互搭配进行移动端的适配的。\n\n","tags":["前端","Vite","postcss插件","多端适配","长度单位","Meta标签"],"categories":["前端","多端适配","Vite","postcss插件"]},{"title":"vue3 自定义Hooks","url":"/2023/09/14/vue3 自定义Hooks/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录了vue3学习中自定义Hooks和vue2中Mixins的使用与案例。\n\n---\n\n\n\n# 一、Hooks是什么？\nHooks用来处理复用代码逻辑的一些封装，Hooks与Mixins不同点在于**Hooks是函数**。\n在vue2中是以Mixins形式将相同的逻辑抽离，各个组件只需要引入mixins，就能使用，mixins存在覆盖问题：\n组件data、methods、filters会覆盖mixins中同名data、methods、filters\n\n![Mixins生命周期](https://img-blog.csdnimg.cn/9fa9326ff2c94f4e93b9dd862424931e.png)\n\n`使用VueUse库可以使用100多项用Hooks完成的功能`\n\n# 二、图片转换Base64\n## 1.Hooks\n>代码如下：\n\n```javascript\ntype Options = {\n    el:string\n}\nexport default function (options:Options):Promise<{baseUrl:string}> {\n    // @ts-ignore\n    return new Promise((resolve)=>{\n        onMounted(()=>{\n            let img:HTMLImageElement = document.querySelector(options.el) as HTMLImageElement\n            img.onload = () =>{\n                resolve({\n                    baseUrl:base64(img)\n                })\n            }\n        })\n        const base64 = (el:HTMLImageElement) =>{\n            const canvas = document.createElement('canvas')\n            const ctx = canvas.getContext('2d')\n            canvas.width = el.width\n            canvas.height = el.height\n            ctx?.drawImage(el,0,0,canvas.width,canvas.height)\n            return canvas.toDataURL('image/jpg')\n        }\n    })\n}\n```\n\n## 2.使用\n\n代码如下：\n\n```javascript\nimport useBase64 from '../../../../hooks/index'\nuseBase64({\n  el: '#img'\n}).then(res=>{\n  console.log(res.baseUrl)\n})\n```\n\n---\n# 三、监听元素宽高（自定义指令+Hooks）\n## 1.Hooks\n\n这里要注意的是vue插件需要定义install方法，在app.use()挂载时会调用该方法\n\n```javascript\n/**\n * interSectionObserver 主要监听元素是否在视口内\n * MutationObserver 主要监听子集的变化 以及 元素的增删改查\n * ResizeObserver 主要监听元素宽高的变化\n */\n// @ts-ignore\nimport type { APP } from 'vue'\n\n/**\n * 自定义Hooks监听元素宽高变化\n * @param el\n * @param callback\n */\nfunction useResize(el:HTMLElement,callback:Function) {\n    let resize = new ResizeObserver((entries)=>{\n        callback(entries[0].contentRect)\n    })\n    resize.observe(el)\n}\n\n/**\n * 自定义指令\n * vue插件 必须要有install方法，在app.use()时会调用该方法\n * @param app\n */\nconst install = (app:APP) => {\n    app.directive('resize', {\n        mounted(el,binding) {\n            useResize(el,binding.value)\n        }\n    })\n}\n// 将install 挂载到useResize上的install上\nuseResize.install = install\nexport default useResize\n```\n## 2.使用\n\n\n```javascript\n<script setup lang=\"ts\">\n\nimport {onMounted} from \"vue\";\nimport useResize from \"../../../hooks/useResize\";\n// 自定义Hooks\nonMounted(()=>{\n  useResize(document.querySelector('.box') as HTMLElement,(e:any)=>{\n    console.log('自定义Hooks',e)\n  })\n})\n// 自定义指令\nconst aaa = (e)=>{\n  console.log('自定义指令',e)\n}\n</script>\n\n<template>\n<div v-resize=\"aaa\" class=\"box\"></div>\n</template>\n\n<style scoped>\n.box{\n  overflow: hidden;\n  border: 2px solid black;\n  resize: both;\n  width: 300px;\n  height: 300px;\n}\n</style>\n```\n\n\n---\n\n# 总结\n本文主要记录了vue3学习中自定义Hooks和vue2中Mixins的使用与案例。\n\n","tags":["前端","Vue3","自定义指令","WebAPI","监听宽高","Hooks","Mixins"],"categories":["Vue","前端","Vue3","Hooks"]},{"title":"Vue3自定义指令（directive）","url":"/2023/09/12/Vue3自定义指令（directive）/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n此文章主要讲了vue3中自定义指令的使用，以及一些WebAPI的使用。如 ResizeObserver、IntersectionObserver API的使用。\n\n---\n\n\n\n# 一、Vue3指令钩子函数\n\n- created 元素初始化\n- beforeMount 指令绑定到元素后调用 只调用一次\n- mounted 元素插入父级dom调用\n- beforeUpdate 元素被更新前调用\n- updated 元素被更新后调用\n- beforeUnmount 元素移除前调用\n- unmounted 元素被移除后调用\n\nvue2中的指令钩子函数有：\n>bind、inserted、update、componentUpdated、unbind\n\n# 二、自定义指令的两种方式\n利用Directive可以创建自定义指令\n## 1.局部使用\n>接收两个参数\n>el：表示当前组件实例\n>dir：表示传入的参数以及函数\n\nDirectiveBinding：与返回参数一致，使用来约束类型\n\n```javascript\nexport interface DirectiveBinding<V = any> {\n    instance: ComponentPublicInstance | null;\n    value: V;\n    oldValue: V | null;\n    arg?: string;\n    modifiers: DirectiveModifiers;\n    dir: ObjectDirective<any, V>;\n}\n```\n>使用如下:\n```javascript\n<script setup lang=\"ts\">\nimport {Directive, DirectiveBinding} from \"vue\";\nimport A from \"./A.vue\";\ntype Dir = {\n  background:string\n}\nconst vMove:Directive = {\n  created(){\n    console.log('------created-------')\n  },\n  beforeMount(){\n    console.log('------beforeMount-------')\n  },\n  mounted(el:HTMLElement,dir:DirectiveBinding<Dir>){\n    console.log('------mounted-------')\n    el.style.background = dir.value.background\n  },\n  beforeUpdate(){\n    console.log('------beforeUpdate-------')\n  },\n  updated(){\n    console.log('------updated-------')\n  },\n  beforeUnmount(){\n    console.log('------beforeUnmount-------')\n  },\n  unmounted(){\n    console.log('------unmounted-------')\n  }\n}\n</script>\n\n<template>\n<A v-move:aaa.smz=\"{background:'red'}\"/>\n</template>\n```\n\n### 例子1：鉴权\n\n```javascript\n<script setup lang=\"ts\">\nimport {Directive} from \"vue\";\n\n// 用户id\nlocalStorage.setItem('userId','smz')\n// mock后台数据\nconst permission = [\n  'smz:shop:edit',\n  // 'smz:shop:create',\n  'smz:shop:delete'\n]\nconst userId = localStorage.getItem('userId') as string\nconst vHasShow:Directive<HTMLElement,string> = (el,bingding)=>{\n  // 当后台返回的权限列表中没有对应的权限，则将其隐藏\n  if (!permission.includes(userId+':'+bingding.value)){\n    // 这里感觉还要对用户在控制台的操作做一些操作，防止用户直接改样式\n    // 监听用户对改元素的操作，在改变其值时进行样式添加\n    el.style.display = 'none'\n  }\n}\n</script>\n\n<template>\n<div class=\"btns\">\n  <button v-has-show=\"'shop:create'\">创建</button>\n  <button v-has-show=\"'shop:edit'\">编辑</button>\n  <button v-has-show=\"'shop:delete'\">删除</button>\n</div>\n</template>\n```\n\n### 例子2：拖拽\n这里使用拖拽需要改变拖拽的`position`，因为不改变，则修改元素位置不起作用\n>static\n该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。\n\n```javascript\n<script setup lang=\"ts\">\n/**\n * Element.firstElementChild：只读属性，返回对象第一个子元素，没有则返回Null\n * Element.clientX:只读属性,元素距离视口左边的距离（中心点）\n * Element.offsetLeft：只读属性，元素左上角距离视口左边的距离\n * Element.offsetWidth:元素宽度\n * Element.offsetHeight:元素高度\n * window.innerWidth：可视窗宽度\n * window.innerHeight：可视窗高度\n */\nimport {Directive, DirectiveBinding} from \"vue\";\n\nconst vDrea:Directive<any,void> = (el:HTMLElement,binding:DirectiveBinding)=>{\n  let gap = 10\n  let moveElement:HTMLDivElement = el.firstElementChild as HTMLDivElement\n  const mouseDown = (e:MouseEvent)=>{\n    console.log(window.innerHeight)\n    let X = e.clientX - el.offsetLeft\n    let Y = e.clientY - el.offsetTop\n    const move = (e:MouseEvent)=>{\n      let x = e.clientX - X\n      let y = e.clientY - Y\n      //超出边界判断\n      if (x<=gap){\n        x = 0\n      }\n      if (y<=gap){\n        y = 0\n      }\n      if (x>= window.innerWidth -el.offsetWidth -gap){\n        x = window.innerWidth -el.offsetWidth\n      }\n      if (y>= window.innerHeight - el.offsetHeight-gap){\n        y = window.innerHeight - el.offsetHeight\n      }\n\n      el.style.left = x + 'px'\n      el.style.top = y + 'px'\n    }\n    // 鼠标移动\n    document.addEventListener('mousemove',move)\n    //松开鼠标\n    document.addEventListener('mouseup',()=>{\n      //清除移动事件\n      document.removeEventListener('mousemove',move)\n    })\n  }\n  //鼠标按下\n  moveElement.addEventListener('mousedown',mouseDown)\n}\n</script>\n\n<template>\n  <div v-drea class=\"box\">\n    <div class=\"header\"></div>\n    <div>内容</div>\n  </div>\n</template>\n\n<style lang=\"less\" scoped>\n.box{\n  position: fixed;\n  width: 300px;\n  height: 250px;\n  border: solid 1px black;\n  .header{\n    height: 30px;\n    background-color: black;\n  }\n}\n</style>\n```\n\n---\n## 2.全局使用\n 定义好全局指令文件，其中需要导出指令钩子函数\n \n```javascript\n/**\n * el:监听的dom元素\n * binding: 回调事件\n */\nexport default {\n    mounted(el,binding) {\n        //将dom与回调的关系塞入map\n        map.set(el,binding.value)\n        //监听el元素的变化\n        ob.observe(el)\n    },\n    unmounted(el) {\n        //取消监听\n        ob.unobserve(el)\n    }\n}\n```\n\n 在main.ts文件中添加以下代码\n 挂载指令，省略‘v-’前缀\n```javascript\nimport sizeDireect from '../src/directs/resize指令封装/sizeDireect'\napp.directive('size-ob', sizeDireect)\n```\n\n 使用：\n     在需要监听的标签上使用命令 `v-size-ob=\"handle\"`，其中handle为回调函数，其中返回的参数为尺寸信息\n```javascript\n <div class=\"dir\"  v-size-ob=\"handle\">\n```\n\n### 例子1：监听宽高指令\n\n```javascript\n/**\n * @ResizeObserver 监听元素变化的API\n * @entries 元素变化的数组集合\n * @entry 每个被监听的元素 其中包含的属性有：\n *    borderBoxSize：边框盒尺寸\n *    contentBoxSize：内容盒尺寸\n *    contentRect:内容区域矩形信息 => DOMRectReadOnly {x: 0, y: 0, width: 3800, height: 3800, top: 0, …}\n *    devicePixelContentBoxSize:DPR尺寸\n *    target：哪一个元素发生变化\n */\nconst ob = new ResizeObserver((entries)=>{\n    for (const entry of entries) {\n        // 获取dom元素的回调\n        const handler = map.get(entry.target)\n        //存在回调函数\n        if (handler){\n            // 将监听的值给回调函数\n            handler({\n                width: entry.borderBoxSize[0].inlineSize,\n                height: entry.borderBoxSize[0].blockSize\n            })\n        }\n    }\n})\n/**\n * map:存储dom与回调函数的映射关系\n * 使用WeakMap，防止内存溢出\n */\nconst map = new WeakMap();\n/**\n * el:监听的dom元素\n * binding: 回调事件\n */\nexport default {\n    mounted(el,binding) {\n        //将dom与回调的关系塞入map\n        map.set(el,binding.value)\n        //监听el元素的变化\n        ob.observe(el)\n    },\n    unmounted(el) {\n        //取消监听\n        ob.unobserve(el)\n    }\n}\n```\n\n### 例子2：监听是否出现在视口\n>vite提供了批量导入的方法 `import.meta.glob`\n>`eager:true`表示静态导入\n\n```javascript\nlet imageList: Record<string,{default: string}> = import.meta.glob('../../../assets/images/*.*',{eager:true})\nlet arr = Object.values(imageList).map(v=>v.default)\n```\n\n```javascript\n/**\n * IntersectionObserver:监听元素与视口交叉的API\n * 返回一个监听集合，集合每一项有intersectionRatio表示在视口存在的比例\n */\nexport default {\n    // @ts-ignore\n     async mounted(el,binding){\n         const def = await import('../../assets/vue.svg')\n        el.src = def.default\n         let ob = new IntersectionObserver((entries) => {\n            if (entries[0].intersectionRatio >0){\n                el.src = binding.valueOf()\n                ob.unobserve(el)\n            }\n         })\n        ob.observe(el)\n\n    },\n    unmounted(el){\n    }\n}\n```\n\n---\n\n# 总结\n此文章主要讲了vue3中自定义指令的使用，以及一些WebAPI的使用。如 ResizeObserver、IntersectionObserver API的使用\n\n","tags":["前端","Vue3","自定义指令","WebAPI","拖拽","鉴权","图片懒加载","监听宽高"],"categories":["Vue","前端","Vue3","自定义指令"]},{"title":"Vue3 学习-组件通讯（二）","url":"/2023/09/12/Vue3 学习-组件通讯（二）/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n本文主要记录Vue3的九种组件通信方式\n\n---\n\n\n# 一、props通信\n>子组件需要用defineProps方法接收父组件传递的数据,该方法不用引入，为Vue3自带，直接使用\n- 父组件\n\n```java\n<script setup lang=\"ts\">\nimport Son from \"./Son.vue\";\nimport {ref} from \"vue\";\nlet money = ref<Number>(1000)\n</script>\n\n<template>\n  <Son info=\"我是父组件\" :money=\"money\"/>\n</template>\n```\n\n- 子组件\n\n```java\n<script setup lang=\"ts\">\n//需要用defineProps方法接收父组件传递的数据\n//该方法不用引入，为Vue3自带，直接使用\n//通过props获取的数据是代理对象\n//props的数据是只读的，不可修改\nlet props = defineProps(['info','money'])\nconsole.log(props)\n</script>\n\n<template>\n  <div>\n    <p>{{info}}</p>\n    <p>{{money}}</p>\n  </div>\n</template>\n```\n\n>通过props获取的数据是代理对象\nprops的数据是只读的，不可修改\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bdcf8242771e4bc685f23d842e3c7e68.png)\n\n# 二、自定义事件（emit）\n>子组件需要用defineEmits方法接收父组件传递的自定义事件，引入后可向父组件传值,该方法不用引入，为Vue3自带，直接使用\n\n\n\n**前置**\n\n- 在vue2中在子组件添加原生事件时默认为自定义事件，需要通过.native修饰符变为原生DOM事件\n- 在Vue3中组件添加原生事件时为原生事件,当子组件绑定时变为自定义事件\n- 原生事件会带一个event回调函数用来记录当前事件的一些属性。\n\n```javascript\nconst handler2 = (event) => {\n  //event为事件对象\n  console.log(event)\n}\n\n <h1>事件</h1>\n    <pre @click=\"handler2\">\n      点击原生事件event\n    </pre>\n```\n\n![事件event](https://img-blog.csdnimg.cn/8818ac34b1094cfb816affdffaa716ab.png)\n\n\n---\n\n>父组件在子组件标签上绑定自定义事件，当绑定的为原生事件时，如果子组件没有使用，则默认为原生事件，二子组件使用则为自定义事件。\n\n```javascript\n<hr>\n  <Event1 @click=\"handler3\"/>\n  <hr>\n  <Event2 @event2=\"handler4\"/>\n```\n>通过defineEmits接收自定义事件\n\n```javascript\nlet emit = defineEmits(['click'])\n\nlet emit = defineEmits(['event2']);\n```\n\n>利用回调函数向父组件传值，其中第一个参数为自定义事件名，之后可带多个参数\n\n```javascript\nconst handler =()=>{\n  emit('click','向父组件传值1')\n}\n\nconst handler = () => {\n  emit('event2','传给父组件2')\n}\n```\n![回调参数](https://img-blog.csdnimg.cn/cd66548881cf4d36946bdded2c50202a.png)\n>父组件使用，用函数接收参数\n\n```javascript\nconst handler3 = (param) => {\n  console.log('接收到子组件1的值:'+param)\n}\nconst handler4 = (param) => {\n  console.log('接收到子组件2的值:'+param)\n}\n```\n![自定义事件](https://img-blog.csdnimg.cn/acc015dc097c4a03bbf1d3f5853c51ca.png)\n\n\n---\n\n\n# 三、全局事件总线(EventBus)\n`不提倡使用`\n>Vue2中使用$bus可进行全局事件的通讯\n\n使用步骤:\n-  创建vue实例\n```javascript\nimport Vue from 'vue'\nexport const bus = new Vue()\n```\n- 在B组件想发送数据，定义`this.$bus.$emit`\n\n```javascript\nimport {bus} from \"../../utils/bus.js\"\n// 这里自己修改路径，且bus.js文件中导出的是export所以使用import {bus}\n...\n// 发送数据\nbus.$emit(参数1：'定义一个方法名', 参数2：'要发送的数据')\n```\n\n- 在A组件想接收数据，定义`this.$bus.$on`和`this.$bus.$off `\n\n```javascript\nimport {bus} from \"../../../utils/bus.js\"\n...\n// 接收数据\nbus.$on(参数1：'$emit的方法名', 参数2：'function(value){\n    // value是接收到的数据\n}')\n```\n\n- 清除\n\n```javascript\neventBus.$off('方法名', {})\n```\n\n---\n\n\n>在Vue3中没有全局事件总线，可通过插件**mitt**来实现全局总线事件，mitt不依赖 Vue 实例，所以可以跨框架使用，mitt里面封装了4个方法：\n>  - all：所有的全局事件\n>   - emit：发布事件\n>   - off：移除事件监听\n>   - on  ：接收事件\n\n\n![mitt方法](https://img-blog.csdnimg.cn/0af963f915ff469d9625d0aa10de596a.png)\n\n **使用**\n\n- 安装并创建文件挂载\n\n```javascript\npnpm add mitt\n\n//引入mitt插件：mitt一个方法，触发执行会返回bus对象\nimport mitt from 'mitt';\n//挂在在$bus变量上\nconst $bus = mitt();\n//导出\nexport default $bus;\n```\n\n- 组件发布事件\n\n```javascript\n<script setup lang=\"ts\">\nimport $bus from \"../../bus\";\nconst handler = () => {\n  $bus.emit('car',{car:\"法拉利\"})\n}\n</script>\n\n<template>\n  <div class=\"child2\">\n    <p>我是子组件2</p>\n    <button @click=\"handler\">点击给兄弟组件1传值</button>\n  </div>\n  <div></div>\n</template>\n```\n\n- 组件使用接收\n\n```javascript\nimport $bus from '../../bus'\nimport {onMounted} from \"vue\";\n//组件挂载完成时，为荡秋千组件绑定一个事件，接收兄弟组件传递的数据\nonMounted(()=>{\n  //第一个参数：事件类型\n  //第二个参数：事件回调\n  $bus.on('car',(car)=>{\n    console.log(car)\n  })\n})\n\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/286931e0e1994af5bbc5d864e0675e1e.png)\n\n>可以看到该插件使用map来存事件的，key就是事件名称，value则是一个回调函数,所以，all也继承了map的方法，可以通过其方法对事件进行操作。\n\n```javascript\n//取消监听\n$bus.off(\"car\")\n//如果发送了多个，可监听全部\n$bus.on(\"*\",(type,val) = >{\n   console.log(type,val)   //type就是类型 之前注册的getDetail\n})\n//取消所有监听\n$bus.all.clear();\n```\n\n\n---\n\n# 四、v-model\n在Vue3.3中，简化了子传父的代码，利用defineModel完成defineEmit的代码。\n\nv-model为组件注册了自定义事件**update:modelValue**，并在props的setter调用了该事件**modelValue**，从而实现v-model的语法糖。\n\n\n>父组件代码：\n\n```javascript\n<template>\n  <div>\n    {{msg}}\n  </div>\n  <Child1 v-model=\"msg\"/>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport Child1 from \"../04_v-model/Child1.vue\";\n// 第一次父组件传给子组件的值\nconst msg =ref(4)\n</script>\n```\n\n>子组件代码：\n\n```javascript\n<template>\n  <input type=\"text\" v-model=\"msg\">\n</template>\n<script setup>\nimport { defineModel } from 'vue'\nlet msg = defineModel('msg')\n</script>\n```\n\n\n可以在一个组件上绑定多个v-model\n相当于给组件绑定了 **update:pageNo**  和 **update:pageSize** 的自定义事件\n\n```javascript\n<Child2 v-model:pageNo=\"pageNo\" v-model:pageSize=\"pageSize\"/>\n```\n\n子组件代码\n\n```javascript\n<script setup lang=\"ts\">\nimport { defineModel } from 'vue'\nlet No = defineModel()\n\n// 接收参数\nlet props = defineProps(['pageNo','pageSize'])\nlet page = defineEmits(['update:pageNo','update:pageSize'])\n\n// 子组件回调传值\nconst headler = () => {\n  page(\"update:pageNo\",props.pageNo +6)\n  page(\"update:pageSize\",props.pageSize +6)\n}\n</script>\n\n<template>\n  <div class=\"child2\">\n    <p>同时绑定多个v-model</p>\n    <div>{{props.pageNo}}</div>\n    <div>{{props.pageSize}}</div>\n    <Button @click=\"headler\"></Button>\n  </div>\n  <div></div>\n</template>\n```\n\n---\n\n\n# 五、userAttrs\n\nvue3框架提供一个方法useAttrs方法，它可以获取组件身上的属性与事件\n\n该方法可以获取在组件 标签上的原生和自定义事件，\n\n```javascript\n<HintButton type=\"primary\" size=\"small\" :icon=\"Edit\"></HintButton>\n```\n![userAttrs](https://img-blog.csdnimg.cn/f2d6480697d44cf9a673b807aac2db2e.png)\n\n例子：\n>父组件\n\n```javascript\n<script setup lang=\"ts\">\n// vue3框架提供一个方法useAttrs方法，它可以获取组件身上的属性与事件\nimport {Edit} from '@element-plus/icons-vue'\nimport HintButton from \"./HintButton.vue\";\n\n</script>\n\n<template>\n<div>\n  <h1>userAttrs</h1>\n  <el-button type=\"primary\" size=\"small\" :icon=\"Edit\" ></el-button>\n<!--  自定义组件-->\n  <HintButton type=\"primary\" size=\"small\" :icon=\"Edit\"></HintButton>\n</div>\n</template>\n\n<style scoped>\n\n</style>\n```\n>子组件 \n\n```javascript\n<script setup lang=\"ts\">\n//引入useAttrs方法：获取标签上属性与事件\nimport {useAttrs} from \"vue\"; //返回对象\nlet $attrs = useAttrs();\n\n// 如果使用props接收属性和属性值，则useAttrs是接收不到的\n//因为props的优先级高于useAttrs\nconsole.log($attrs)\n</script>\n\n<template>\n<div>\n  <el-button :=\"$attrs\">子组件</el-button>\n</div>\n</template>\n\n<style scoped>\n\n</style>\n```\n\n`被props获取的属性和属性值不会被useAttrs获取到`\n\n---\n\n# 六、ref和$parent\n\n通过ref和$parent可以获取DOM实例对象，就可以进行通讯了\n\n`ref和$parent获取到的DOM实例是获取不到内部定义的数据的，所以要通过 defineExpose 暴露出去`\n\n- **ref（父传子）**\n\n在子标签上添加ref\n\n```javascript\n<Son ref=\"son\"/>\n```\n再声明同名变量，此时son就是子组件实例\n\n```javascript\nlet son = ref()\n```\n在子组件中暴露需要传递的数据或者方法\n\n```javascript\ndefineExpose({\n  money,\n  fly\n})\n```\n在父组件中使用\n\n```javascript\nconst handler = () => {\n  money.value+=10;\n  console.log(son)\n  //操作子组件数据\n  son.value.money-=10\n  son.value.fly()\n}\n```\n\n- **$parent（子传父）**\n\n在子组件中定义事件并传入 `$parent` 作为参数，此时$parent就是父组件实例\n\n```javascript\n<button @click=\"handler($parent)\">我是子组件2按钮</button>\n\nconst handler = ($parent) => {\n  money.value+=1000\n  console.log($parent)\n  //操作父组件数据\n  $parent.money-=1000\n}\n```\n\n父组件对外暴露数据或者方法\n\n```javascript\n//对外暴露\ndefineExpose({\n  money\n})\n```\n\n\n>完整代码\n\n父组件\n\n```javascript\n<script setup lang=\"ts\">\n//ref:获取真实DOM结点，可以获取到子组件实例VC\n//$parent:可以在子组件内部获取到父组件的实例\nimport {ref} from 'vue'\nimport Son from \"./Son.vue\";\nimport Daughter from \"./Daughter.vue\";\nlet money = ref(100000000)\n//获取子组件实例\nlet son = ref()\nconst handler = () => {\n  money.value+=10;\n  console.log(son)\n  //操作子组件数据\n  son.value.money-=10\n  son.value.fly()\n}\n//对外暴露\ndefineExpose({\n  money\n})\n\n</script>\n\n<template>\n<div class=\"box\">\n  <h1>ref与$parent</h1>\n  <h2>我是父组件:{{money}}</h2>\n  <button @click=\"handler\">增加父组件数值减少子组件数值</button>\n  <hr>\n<!--  ref形式-->\n  <Son ref=\"son\"/>\n  <hr>\n<!--  $parent形式-->\n  <Daughter />\n</div>\n</template>\n\n<style scoped>\n.box{\n  width: 100vw;\n  height: 500px;\n  background: skyblue;\n}\n</style>\n```\nref子组件\n\n```javascript\n<script setup lang=\"ts\">\nimport {ref} from \"vue\";\n\nlet money = ref(666)\n\nconst fly = ()=>{\n  console.log('我是子内部组件方法')\n}\n//组件内部数据对外是关闭的，其他组件不能访问\n//如果想让外部访问需要通过defineExpose方法对外暴露\ndefineExpose({\n  money,\n  fly\n})\n</script>\n\n<template>\n<div class=\"son\">\n<h2>我是子组件:{{money}}</h2>\n</div>\n</template>\n\n<style scoped>\n.son{\n  width: 300px;\n  height: 200px;\n  background: cyan;\n}\n</style>\n```\n\n$parent子组件\n\n```javascript\n<script setup lang=\"ts\">\nimport {ref} from \"vue\";\n\nlet money = ref(2000)\n//事件回调传入参数 $parent 来获取父组件实例\n//父组件必须将数据对外暴露\nconst handler = ($parent) => {\n  money.value+=1000\n  console.log($parent)\n  //操作父组件数据\n  $parent.money-=1000\n}\n</script>\n\n<template>\n<div class=\"dau\">\n  <h1>我是子组件2</h1>\n  <button @click=\"handler($parent)\">我是子组件2按钮</button>\n</div>\n</template>\n\n<style scoped>\n.dau{\n  width: 300px;\n  height: 300px;\n  background: hotpink;\n}\n</style>\n```\n\n---\n\n\n# 七、Provide与Inject\n依赖注入\nvue3 提供了provide(提供)与inject(注入)，可以实现隔辈组件通讯\n利用了原型链，在父组件provides上创建新对象：Object.create().parentProvides\n子组件使用时在原型链上查找\n- provide是个方法提供两个参数,提供数据\n    提供数据的key\n    组件提供的数据\n- inject通过注入祖先提供的数据，利用key值来获取数据\n\n`注：后辈组件是可以修改祖先组件传过来的的值，并影响祖先组件的数据`\n>个人建议：对于子改变父组件数据尽量不要用，保证数据的单向流动，防止父组件数据更改后影响其他组件\n以下为提供的两个将数据变为非响应式数据的方法\n- toRaw：把一个响应式对象转化为普通对象\n- markRaw：把某个数据，标记为普通对象，当我们把它放到响应式对象中，也依然是非响应式的\n\n在任意组件中注入数据\n\n```javascript\nlet car = ref<String>(\"大众\")\ntype Car = {\n  car:string\n}\ntype CarData = {\n  [index: number]:Car\n}\nlet cars:CarData = reactive([{car:'大众'},{car:'宝马'}])\nconst TOKEN = Symbol() as InjectionKey<CarData>\nprovide(TOKEN,cars)\n```\n\n可以在其他组件中接收数据\n\n```javascript\n<script setup lang=\"ts\">\nimport {inject} from \"vue\";\nlet cars = inject<string>('TOKEN')\nconsole.log(cars)\nconst hander=()=>{\n  cars[0].car = '奔驰'\n}\n</script>\n\n<template>\n  <div class=\"child2\">\n    <h1>孙子组件</h1>\n    <p v-for=\"item of cars\">{{item.car}}</p>\n    <button @click=\"hander\">改变</button>\n  </div>\n</template>\n```\n\n>如果接收的是个响应式数据可以在接收组件改变其数据\n\n---\n# 八、pinia\n在vue3之前状态管理使用VueX来实现，现在官方更加推荐pinia在vue3中实现状态管理\n\nvuex:集中式管理状态容器，可以实现任意组件之间的通讯 核心：\n   1、state 存储数据\n   2、mutations 唯一修改数据\n   3、actions 处理异步、处理业务\n   4、getters 计算属性\n   5、modules 模块式开发\n \n ---\n   pinia:集中式管理状态容器，可以实现任意组件之间的通讯 核心：\n   1、state 存储数据\n   2、actions 修改数据、处理异步、处理业务\n   3、getters 计算属性\n \n利用createPinia方法创建大仓库\n并对外暴露该仓库\n在全局引入(文件位置：./src/store)\n\n```javascript\nimport {createPinia} from \"pinia\";\nlet store = createPinia()\nexport default store\n```\n选择式API仓库\ndefineStore方法定义小仓库，带两个参数\n  1、仓库名称\n  2、仓库配置对象\ndefineStore返回一个函数，让组件可以获取到仓库数据\n存储数据：state\n需对外暴露方法\n\n```javascript\nimport {defineStore} from \"pinia\";\nlet userInfoStore = defineStore(\"info\",{\n    state:()=>{\n        return {\n            count: 99,\n            arr: [1,2,3,4,5,6,7,8,9,10]\n        }\n    },\n    actions: {\n        //内部没有context上下文对象\n        //没有commit、没有mutations去修改数据\n        updateNum(a:number,b:number){\n            this.count+=(a+b)\n        }\n    },\n    getters: {\n        total() {\n            let result:number = this.arr.reduce((prev,next)=>{\n                return prev+next\n            },0)\n            return result\n        }\n    }\n})\nexport default userInfoStore\n```\n定义组合式API仓库\n务必返回一个对象：属性与方法可以提供给组件使用\n\n```javascript\nimport {defineStore} from \"pinia\";\nimport {computed, reactive} from \"vue\";\nlet userTodoStore = defineStore(\"todo\",()=>{\n\n    let todos = reactive([{id:1,title:'吃饭'},{id:2,title:'睡觉'}])\n   let arr = reactive([1,2,3,4,5,6])\n    const total = computed(()=>{\n        return arr.reduce((prev,next)=>{\n            return prev+next\n        },0)\n    })\n    return {\n        todos,\n        total,\n        updateTodo(){\n            todos.push({id:3,title: '组合式API'})\n        }\n    }\n})\nexport default userTodoStore\n```\n\n   \n  写法：\n   1、选择式\n   修改数据：\n  \n\n - 使用返回的函数直接修改其属性\n             infoStore.count++\n\n \n- 使用返回函数上的 `$patch` 方法\n             infoStore.$patch({count:222})  \n- 使用自定义方法，在actions中定义方法，可传参\n             infoStore.updateNum()\n             仓库：this.count++\n             `注：在方法内部要用this，this指向仓库对象`\n         \n     \n  ![函数上的方法](https://img-blog.csdnimg.cn/bb66bf1911b5408d8d017ac26e5f7c12.png)\n\n             \n 2、组合式\n     修改数据：\n     \n- 使用返回的函数直接修改其属性\n            todoStore.todos[0].title = '喝水'\n            \n- 使用computed计算属性，将计算值返回就能获取\n             const total = computed(()=>{\n               return arr.reduce((prev,next)=>{\n                  return prev+next\n               },0)\n             })\n             \n- 使用自定义方法，在return中定义方法，可传参\n             updateTodo(){\n                todos.push({id:3,title: '组合式API'})\n              }\n             `注：在方法内部要用this，this指向仓库对象`\n\n---\n# 九、slot插槽\n\n插槽分为三种插槽：\n- 默认插槽\n    在子组件直接使用slot标签`<slot></slot>`\n    在父组件中子组件标签里添加传递的结构\n- 具名插槽\n    在子组件直接使用slot标签`<slot name=\"a\"></slot>`\n    在父组件中子组件标签里添加template传递的结构，并用v-slot:（简写: #）指定是那个插槽\n \n```javascript\n<template v-slot:a>\n    <pre>早死晚死都得死</pre>\n  </template>\n```\n\n- 作用域插槽\n     可传递数据的插槽,子组件可以将数据回传给父组件，父组件可以定义该数据以某种方式或者外观在子组件内部展示\n     子组件可以在slot标签上传递数据`<slot :row=\"item\" :index=\"index\"></slot>`\n     父组件在template用v-slot用接收数据并定义子组件内部显示方式\n```javascript\n <template v-slot=\"{row,index}\">\n          <span :style=\"{color:row.done?'green':'red'}\">{{row.title}}--{{index}}</span>\n        </template>\n```\n\n---\n\n# 总结\n\n本文主要记录了vue3中九种组件通讯的方法与示例。\n","tags":["前端","Vue3","组件通讯","slot","pinia","全局事件总线","Provide与Inject","依赖注入"],"categories":["Vue","前端","Vue3","组件通讯"]},{"title":"前端面试题","url":"/2023/09/04/前端面试题/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文主要记录在面试过程中，所遇到的题目。\n\n---\n\n\n# 一、lodash.get方法？\n>问题：\n>object (Object): 要检索的对象。\n>path (string): 要获取属性的路径。\n>[defaultValue] (*): 如果解析值不存在，会返回 default。\n\n>用例：\n\n```javascript\nconst object = { 'a': [{ 'b': { 'c': 3 } }] };\n\nconsole.log(_get(object, 'a[0].b.c'));\n// => 3\n\nconsole.log(_get(object, ['a', '0', 'b', 'c']));\n// => 3\n\nconsole.log(_get(object, 'a.b.c', 'default'));\n// => 'default'\n```\n\n**分析：**\n- lodash.get是用来解决一些链路调用问题，使其能够在各种情况下都返回正确的值，而不是报错。\n-    官方API中path不止是string还可以是Array,也就是使用连续字符串也可以使用。\n - 在这里先将path进行处理，处理成数组['a', '0', 'b', 'c']形式，然后通过迭代去取值\n\n```javascript\nfunction _get(object, path, defaultVal='default') {\n    // 在这里实现\n    let newPath = [] //存放预处理的path\n    if (Array.isArray(path)){// 如果传入路径为数组形式直接赋值不用处理\n        newPath = path\n    }else {// 处理path为数组,利用replace替换'[]'为'.',利用split将字符串分割成字符数组\n        newPath  = path.replace(/\\[/g,'.').replace(/\\]/g,'').split('.')\n    }\n    return newPath.reduce((o,k)=>{//通过reduce迭代newPath找路径没找到则返回defaultVal\n        // { a: [ { b: [Object] } ] } a\n        // [ { b: { c: 3 } } ] 0\n        // { b: { c: 3 } } b\n        // { c: 3 } c\n        return (o ||{})[k]\n    },object) || defaultVal\n}\n```\n\n---\n# 二、实现一个EventEmitter.js\n>问题：\n>实现一个 EventEmitter。\n\n>用例：\n\n```javascript\nconst eventEmitter = new EventEmitter()\n\nfunction callback() {\n    console.log('hit!')\n}\n\n// 监听事件, 其中有一个 once 单次监听\neventEmitter.on('custom-event', callback)\neventEmitter.once('custom-event', callback)\n\n// 连续触发两次\neventEmitter.emit('custom-event')\neventEmitter.emit('custom-event')\n// 预期输出 3 次 \"hit!\"\n\n// 删除并再次=触发\neventEmitter.removeListener('custom-event');\neventEmitter.emit('custom-event')\n// 预期没有输出\n```\n\n这里查了一下EventEmitter属于node服务端events模块对外提供的一个EventEmitter对象，用于对Node.js中对事件进行统一管理，表示没学Node,根本不知道啊，只知道浏览器事件EventTarget，不过二者都差不多，都是用来对事件进行处理的,不过浏览器事件会存在冒泡，因为在Node中不存在层级关系，浏览器DOM是存在层级关系的，且浏览器事件是基于观察者模式的，而EventEmitter的事件是基于发布订阅模式的。\n\n**分析：**\n 需要编写一个类，实现内部方法on、once、emit、removeListener\n  - on:注册事件监听器，接受两个参数，第一个参数是事件名称，第二个参数是事件监听器。\n             先判断是否存在该事件，不存在旧创建空数组并将事件处理函数添加到数组中\n  - once:注册事件监听器，只会触发一次，触发后会自动移除。\n                本质还是调用on方法，只不过事件处理函数会被额外包裹一层，其中事件处理函数最后会调用off方法，\n                off方法，会根据传入事件处理函数名称来去除不是 callback 的函数，这样旧形成了只调用一次\n - emit:按照注册的顺序同步调用为名为传入名称的事件注册的每个侦听器\n                循环遍历事件集合，执行事件处理函数\n - removeListener:移除事件监听器，接受两个参数，第一个参数是事件名称，第二个参数是事件监听器。\n                          直接移除事件对象对应的属性\n\n\n```javascript\nclass EventEmitter {\n    constructor() {\n        this.events = {}// 存储事件\n    }\n    // 在这里实现\n    on(event,callback) {// 监听\n        if (!this.events[event]){// 是否存在该事件\n            this.events[event] = []// 不存在创建一个空数组\n        }\n        this.events[event].push(callback)// 将事件处理函数添加到数组集合中\n    }\n    once(event,callback){// 单次监听\n        const wrapper = () => {// 在外包裹一层，使调用时同时清除该次事件处理函数\n            callback();\n            this.off(event);\n        };\n        this.on(event, wrapper);\n    }\n    off(event){\n        if (!this.events[event]) {\n            return;\n        }\n        this.events[event] = this.events[event].filter((cb) => cb!== callback);\n    }\n    emit(event){// 触发事件\n        if (!this.events[event]) {\n            return;\n        }\n        this.events[event].forEach((callback) => callback());// 循环执行事件\n    }\n    removeListener(event){\n        if (!this.events[event]) {\n            return;\n        }\n        delete this.events[event]// 删除事件\n    }\n}\n```\n\n---\n# 三、渲染VNode.js\n>问题：\n>写个函数用来渲染这个结构\n>就是将一个虚拟DOM渲染成真实DOM的过程\n\n>用例：\n\n```javascript\nconst renderJSON = {\n    type: 'div',\n    props: {\n        className: '',\n    },\n    childrens:[\n        {\n            type: 'p',\n            props: {\n                text:'xxxxx'\n            },\n            childrens:['xxxx']\n        }\n    ]\n}\n```\n\n**分析：**\n- type：标签名\n -  props：属性名，是个集合可能包含许多属性，需要遍历挂载，需要处理行内样式和值的绑定\n  -  childrens：子元素,子元素分为两种：一种为标签元素，另外一种为文本元素\n    查看结构每个对象中都会包含childrens用来储存该DOM下的层级关系，通过递归的形式进行渲染\n\n```javascript\nconst render = (renderJSON) =>{\n    const {type, props, childrens} = renderJSON //将三个参数结构出来\n    let el = document.createElement(type)// 创建标签元素\n    for (let key in props){// 挂载属性\n        el.setAttribute(key,props[key])//设置属性上的值，这里没有考虑行内样式以及绑定值的处理\n    }\n    //创建子节点\n    childrens.forEach(child =>{\n        if (child instanceof Object){//如果为标签元素\n            el.appendChild(render(child))//将子元素添加到父元素内部末尾处，递归创建子元素\n        }else {//如果为文本\n            let textNode = document.createTextNode(child)//创建一个文本节点，将文本塞入\n            el.appendChild(textNode)//添加文本结点到父元素内部\n        }\n    })\n    return el\n}\n\ndocument.body.appendChild(render(renderJSON))// 挂载到body下\n```\n\n---\n# 四、设计一个Cache.js\n>问题：\n>设计一个 Cache\n >支持下列两个基本操作：\n >  - set(id, object), 根据id设置对象;\n  > - get(id): 根据id得到一个对象;\n >同时它有下面几个性质:\n  > 1. x秒自动过期, 如果cache内的对象, x秒内没有被get或者set过, 则会自动过期;\n  > 2. 对象数限制, 该cache可以设置一个n, 表示cache最多能存储的对象数;\n   >3. LRU置换, 当进行set操作时, 如果此时cache内对象数已经到达了n个, 则cache自动将最久未被使用过的那个对象剔除, 腾出空间放置新对象;\n\n>用例：\n\n```javascript\nconst cache = new Cache(2,3)\ncache.set(1,{name:'smz1'})\ncache.set(2,{name:'smz2'})\ncache.set(1,{name:'smz3'})\nsetTimeout(()=>{\n    console.log(cache.get(1))// 已过期\n},4000)\n```\n\n**分析：**\n- set方法,在设置缓存对象时，我们首先将其封装成一个对象 { obj, timestamp }，其中 timestamp 表示缓存对象的时间戳，用于判断对象是否过期。\n      然后，我们将该对象存储在缓存中，当缓存中不存在该缓存时将其唯一标识添加到 LRU 链表的末尾。检查缓存的大小，如果超过了最大大小，则自动删除最早添加的缓存对象；如果存在，则更新 LRU 链表位置，以及缓存时间戳信息。\n - get 方法用于获取缓存对象，它接受一个参数 id，表示要获取的缓存对象的唯一标识。\n      在获取缓存对象时，我们首先检查该对象是否存在，如果不存在，则返回 不存在。\n      如果存在，则检查该对象是否过期，如果过期，则从缓存中删除该对象，并返回 '已过期'。\n      否则，我们将该对象移动到 LRU 链表的首部，并返回缓存对象。\n- delete 方法用于删除缓存对象，它接受一个参数 id，表示要删除的缓存对象的唯一标识。\n      在删除缓存对象时，我们首先从缓存中删除该对象，并从 LRU 链表中删除该对象的唯一标识。\n- delete方法，用于删除缓存及标识\n- _checkSize方法，用于删除最久未使用的\n- _moveToFront方法，用于更新LRU链位置\n\n```javascript\nclass Cache {\n    constructor(maxSize = 10,maxAge = 60) {\n        this.maxSize = maxSize // 最大缓存数\n        this.maxAge = maxAge// 最长过期时间\n        this.cache = {}// 缓存列表\n        this.lruList = [] // 缓存唯一标识\n    }\n    set(id,obj){\n        const item = this.cache[id];// 在缓存中查找是否存在\n        const timestamp = Date.now() // 存储建立的时间\n        this.cache[id] = {obj, timestamp} // 封装成对象存储在缓存中\n        if (!item){// 不存在\n            this.lruList.push(id)// 将唯一标识添加到链表末尾\n            this._checkSize()// 检查缓存大小\n        }else {// 存在\n            this._moveToFront(id);//将该id标识移动到最后面\n        }\n    }\n    get(id){\n        const item = this.cache[id];// 在缓存中查找是否存在\n        if (!item) {// 不存在返回提示\n            return '不存在';\n        }\n        if (Date.now() - item.timestamp > this.maxAge * 1000) {// 判断是否过期,过期删除并返回提示\n            this.delete(id);\n            return '已过期';\n        }\n        this._moveToFront(id);//将该id标识移动到最后面\n        return item.obj;\n    }\n    delete(id){// 过期删除缓存及标识\n        delete this.cache[id];// 删除缓存\n        this.lruList = this.lruList.filter((item) => item!== id);// 移除标识\n    }\n    _checkSize() {// 缓存满删除缓存\n        if (this.lruList.length > this.maxSize) {// 大于了最大储存数时\n            const id = this.lruList.shift();// 返回第一个元素\n            delete this.cache[id];// 在缓存中删除\n        }\n    }\n\n    _moveToFront(id) {// 更新id标识位置\n        const index = this.lruList.indexOf(id);// 指定元素下标\n        if (index!== -1) {// 存在\n            this.lruList.splice(index, 1);//移除id标识旧位置\n            this.lruList.push(id);// 将id标识添加到链表最后面\n        }\n    }\n\n    getList(){// 返回存储集合\n        return this.cache\n    }\n}\n```\n\n\n---\n\n\n\n","tags":["前端","面试","Node","渲染","事件"],"categories":["前端","面试"]},{"title":"微前端-monorepo-无界","url":"/2023/08/31/微前端-monorepo-无界/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\n本文主要记录微前端框架 **[无界](https://wujie-micro.github.io/demo-main-vue/**home)** 的使用与理解以及monorepo代码管理方式。\n\n---\n\n\n# 一、微前端\n如今项目体积越来越大，导致维护成本增加，后端以微服务形式将项目拆成不同的服务，前端也需要对项目进行拆解，以达到长久发展的可能性。\n在我理解中，微前端就是将前端以某种规则进行隔离，在隔离中也能进行远程访问其他小应用，不受技术栈的影响，带来更多的可能性与可维护性。\n\n---\n#  二 、monorepo\n* monorepo是一个单仓库多应用的代码管理方式，多个项目集成到一个仓库下，共享工程配置，同时又快捷地共享模块代码。\n* 中大型项目，多模块项目monorepo更适合管理代码，对调试、开发都有很大的帮助。\n\n`注：在使用monorepo方式管理项目时，会产生诸多问题，如幽灵依赖、依赖安装耗时的问题，需要使用pnpm进行解决这类问题。`\n\n---\n#  三 、pnpm\n- 项目依赖在基于npm时，每个项目都有自己的项目依赖，都需要保存在本地，而pnpm则时将相同依赖项目的依赖包放在同一个位置，让不同项目共享同一个个依赖包，节约硬盘空间，提升了安装速度。\n- 针对不同版本的依赖，则只会保存不同的文件，不会将所有文件都保存\n## 硬链接\n共享了同一个硬盘地址\npnpm通过硬链接直接指向 pnpm仓库 依赖包在硬盘的地址\n## 软链接（符号链接）\n只会记录路径，不占用资源\n如果依赖包之间有相互依赖，则会通过软连接指向该依赖路径，不会指向硬盘地址。\n\n![pnpm](https://img-blog.csdnimg.cn/5c822b9907974450bb94b488dba08d1d.png)\n## 幽灵依赖\nnpm/yarn 安装依赖时，存在依赖提升，某个项目使用的依赖，并没有在其 package.json 中声明，也可以直接使用，这种现象称之为 “幽灵依赖”；随着项目迭代，这个依赖不再被其他项目使用，不再被安装，使用幽灵依赖的项目，会因为无法找到依赖而报错。\n\n>使用pnpm可以解决此类问题\n\n## 依赖安装耗时长\nMonoRepo 中每个项目都有自己的 package.json 依赖列表，随着 MonoRepo 中依赖总数的增长，每次 install 时，耗时会较长。\n\n>MonoRepo 中每个项目都有自己的 package.json 依赖列表，随着 MonoRepo 中依赖总数的增长，每次 install 时，耗时会较长。\n\n## monorepo项目搭建\n项目构建需要一个注应用来搭载各个子应用，在安装依赖时需要在最外层创建 [pnpm-workspace.yaml](https://www.pnpm.cn/pnpm-workspace_yaml) 配置文件，通过配置就可以轻松的下载所有项目的依赖。这样会将子项目中公共的依赖提取到外层modules中\n![项目结构](https://img-blog.csdnimg.cn/b1996883c43b44b7902eeb91c51a6b71.png)\n\n\n```javascript\npackages:\n  # all packages in direct subdirs of packages/\n  - 'main'\n  # all packages in subdirs of components/\n  - 'web/**'\n```\n\n- 在外层目录下可以通过 pnpm -F <子项目文件名> <命令> 的形式执行子项目中的命令\n\n## 子模块复用\n- 在外层创建common文件，将应用公共的模块提取到该文件夹下，比如axios等。\n- 在主项目main目录下，执行 **pnpm -F <项目名称> add common**\n\n![commob依赖](https://img-blog.csdnimg.cn/e078b292092d4607a983afdf420623ae.png)\n\n\n这样就可以直接在项目中使用common中的东西\n\n```javascript\nimport {a} from 'common'\n```\n\n# 四、无界\n\n对于一些常见的微前端框架（qiankun、micro-app、EMP），对vite都不太友好，所以这里采用[无界](https://wujie-micro.github.io/doc/)来搭建微前端框架\n\n\n**特点**\n- 接入简单只需要四五行代码\n- 不需要针对vite额外处理\n- 预加载\n- 应用保活机制\n\n**不足**\n\n- 隔离js使用一个空的iframe进行隔离\n- 子应用axios需要自行适配\n- iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从'about:blank'初始化为主应用的host，这个采- - 用的计时器去等待的不是很优雅。\n- 底层原理 使用shadowDom 隔离css，js使用空的iframe隔离，通讯使用的是proxy\n\n## 接入无界\n- 在主项目main目录下安装wujie\n\n```javascript\npnpm i wujie\n```\n- 在主项目main目录下安装对应类型项目的[封装插件](https://wujie-micro.github.io/doc/pack/),该插件是对wujie的封装，从而使wujie的使用更快捷\n\n```javascript\npnpm i wujie-vue3\n```\n\n- 在主应用main.ts中引入对应的wujie框架，并注册\n\n```javascript\nimport Wujie from 'wujie-vue3'\napp.use(router).use(Wujie)\n```\n\n- 子应用的使用，在主应用中使用WujieVue标签进行使用，在url中传入应用启动地址\n\n```javascript\n  <WujieVue url=\"http://localhost:5174/\" name=\"vue3\"></WujieVue> \n  <WujieVue url=\"http://localhost:5175/\" name=\"react\"></WujieVue> \n```\n![界面效果](https://img-blog.csdnimg.cn/fff7d0882db74e999ddb11ed84121396.png)\n\n`注：官网只对vue和react进行了封装其他框架需要自行封装`\n\n\n## 无界预加载\n预加载能力可以极大的提升子应用打开的首屏时间\n\n只需要在preloadApp中将 exec 设置为true即可\n\n在主项目下main.ts文件中配置exec\n\n```javascript\npreloadApp({url:\"http://localhost:5174/\", name:\"vue3\",exec: true})\npreloadApp({url:\"http://localhost:5175/\", name:\"react\",exec: true})\n```\n由于子应用提前渲染可能会导致阻塞主应用的线程，所以无界提供了类似 react-fiber 方式来防止阻塞线程\nreact-fiber模拟了requestIdleCallback API ，预加载都被requestIdleCallback包裹，在浏览器空闲的时候提前预加载一些内容\n**requestIdleCallback API**会有两种情况：\n\n- 浏览器在每一帧执行一系列任务，如果有剩余时间就执行 requestIdleCallback\n    - 处理用户事件\n    - 执行定时器任务\n    - 执行requestAnimationFrame动画\n    - 执行dom的回流与重绘\n    - 计算更新图层的绘制指令\n    - 绘制指令合并主线程\n- 浏览器没有任务执行，会有50ms空余时间去执行 requestIdleCallback\n\n## 无界传参\n无界的通讯系统又三种方式进行通讯分别是：\n\n- **props通讯**\n\n主应用可以通过props注入数据和方法：\n\n```javascript\n<WujieVue name=\"xxx\" url=\"xxx\" :props=\"{ data: xxx, methods: xxx }\"></WujieVue>\n```\n\n子应用可以通过$wujie来获取：\n\n```javascript\nconst props = window.$wujie?.props; // {data: xxx, methods: xxx}\n```\n![props通讯](https://img-blog.csdnimg.cn/4b55f07612a74022970ed4a3675cc075.png)\n\n\n- **window通讯**\n主应用调用子应用的全局数据\n```javascript\nwindow.document.querySelector(\"iframe[name=子应用id]\").contentWindow.xxx;\n```\n\n子应用调用主应用的全局数据\n\n```javascript\nwindow.parent.xxx;\n```\n![window通讯](https://img-blog.csdnimg.cn/82aecbc1b0174c478b7550c4d19eed59.png)\n\n\n- **eventBus通讯**\n发布订阅模式的通讯\n主应用使用方式:\n\n```javascript\n// 如果使用wujie\nimport { bus } from \"wujie\";\n\n// 如果使用wujie-vue\nimport WujieVue from \"wujie-vue\";\nconst { bus } = WujieVue;\n\n// 如果使用wujie-react\nimport WujieReact from \"wujie-react\";\nconst { bus } = WujieReact;\n\n// 主应用监听事件\nbus.$on(\"事件名字\", function (arg1, arg2, ...) {});\n// 主应用发送事件\nbus.$emit(\"事件名字\", arg1, arg2, ...);\n// 主应用取消事件监听\nbus.$off(\"事件名字\", function (arg1, arg2, ...) {});\n\n```\n子应用使用方式:\n\n```javascript\n// 子应用监听事件\nwindow.$wujie?.bus.$on(\"事件名字\", function (arg1, arg2, ...) {});\n// 子应用发送事件\nwindow.$wujie?.bus.$emit(\"事件名字\", arg1, arg2, ...);\n// 子应用取消事件监听\nwindow.$wujie?.bus.$off(\"事件名字\", function (arg1, arg2, ...) {});\n\n```\n\n---\n\n\n# 总结\n\n本文主要记录了微前端无界的使用与理解。\n","tags":["微前端","无界","monorepo","pnpm","幽灵依赖","依赖安装耗时长"],"categories":["微前端","无界"]},{"title":"Vue3 学习 组合式API setup语法糖 响应式 指令 DIFF（一）","url":"/2023/08/30/Vue3 学习 组合式API setup语法糖 响应式 指令 DIFF（一）/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\n\n本文用于记录学习Vue3的过程\n\n---\n# 一、Composition Api\n>我觉得首先VUE3最大的改变就是对于代码书写的改变，从原来选择式API变成现在的组合式API方式，Vue3也是支持选择式的，他能让我们的代码逻辑不再满屏跳转，让代码更具有逻辑性，当然我觉得也更好调试了。\n\n\n# 二、setup语法糖\n\n    < script setup>  \n     是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。\n     当同时使用 SFC 与组合式 API 时该语法是默认推荐。相比于普通的 <script> 语法，它具有更多优势：\n\n- 更少的样板内容，更简洁的代码。\n- 能够使用纯 TypeScript 声明 props 和自定义事件。\n- 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。\n- 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。\n# 三、响应式\n\n>Vue3中响应式是整个框架的核心，要使用响应式就须通过 **ref** 或者 **reactive**将常量变为响应式\n>其中可以搭配下列API简化开发（在之后的文章中介绍）\ncomputed()\nreadonly()\nwatchEffect()\nwatchPostEffect()\nwatchSyncEffect()\nwatch()\n\n`在进阶响应式还有其他响应式API`\n## ref\nref 可以绑定一些基本数据类型，比如字符串、数字等。ref实际上是通过对象自身value属性的get和set方法来拦截value属性达到响应式的。\n所以使用ref定义的数据的时候，都是以 **xxx.value**来使用。\n\n![ref](https://img-blog.csdnimg.cn/1e447fb4e9134abd9c351c6b1af20029.png)\n\n\n使用ref也是有好处的，在将其封装到一个对象中的时候，所有的基本数据类型格式都是统一的，在数据传输的时候传输的也是对象地址，而不是值，这保证了数据的统一性。\n\n![基本数据类型](https://img-blog.csdnimg.cn/a81eac8b7bd44140b9c1b57870ec83a2.png)\n**ref**:\n    深层次的响应式,一般用来做普通类型的响应式如，除arr\\object的数据类型，底层arr和object实现也是走reactive\n    可以获取dom元素具体使用场景在 组件通讯-->06_ref-children-parent中\n    \n**isRef**:\n    用来判断某个对象是否为响应式对象 传入参数：变量，返回结果为：boolean\n    \n**shallowRef**:\n    浅层次的响应式（只会在响应到 xxx.value）\n    第三方库对象代理不能用proxy时可以用这个\n    注：不能和ref混用，当两者变量同时出现在template中shallowRef会被影响视图的更新\n        ref底层调用triggerRefValue-->triggerEffects 使得强制更新收集的依赖，\n        \n**triggerRef**:\n    强制更新收集的依赖\n    \n**customRef**:\n    自定义响应式，浅层次的响应式\n\n\n---\n\n## reactive \n**reactive**:\n     对类型进行了约束，不能绑定普通数据类型，只能绑定引用类型：Array Object Map Set\n     reactive proxy不能直接赋值，否则破坏响应式对象\n       解决：数组 可以push加解构\n            添加对象将数组当成属性使用\n            \n**readonly**:\n     用来将其变为只读的\n     注：与 reactive一起使用时没有作用\n     \n**shallowReactive**：\n     浅层响应式,与shallowRef类似，存在相同的问题和reactive一起使用会影响响应\n# 四、其他一些关键点\n## v-pre\n跳过该标签以及子标签的编译按照原内容显示\n\n```javascript\n<span v-pre>{{ this will not be compiled }}</span>\n```\n![v-pre](https://img-blog.csdnimg.cn/d72c84f40b4849b6a02c5f2bd094f2a0.png)\n\n## v-once\n使用该命令可以让该标签以及子标签只渲染一次，并在未来跳过更新。\n\n```javascript\n<!-- 单个元素 -->\n<span v-once>This will never change: {{msg}}</span>\n<!-- 带有子元素的元素 -->\n<div v-once>\n  <h1>comment</h1>\n  <p>{{msg}}</p>\n</div>\n<!-- 组件 -->\n<MyComponent v-once :comment=\"msg\" />\n<!-- `v-for` 指令 -->\n<ul>\n  <li v-for=\"i in list\" v-once>{{i}}</li>\n</ul>\n```\n\n\n使用场景：\n\n - 不需要数据响应式的标签上\n\n\n```javascript\n<script setup>\nimport { ref } from 'vue'\n\nconst msg = ref('Hello World!')\n</script>\n\n<template>\n  <h1 v-once>{{ msg }}</h1>\n  <input v-model=\"msg\">\n</template>\n```\n![v-once](https://img-blog.csdnimg.cn/7d9603a5724c4ee580baab49018f5259.png)\n\n## v-memo\nv-memo也具有v-once的功能与v-once不同的是，v-memo可以传 条件，能更好的控制模板的缓存，在其中可以传一个逻辑，也可以传一个变量来控制。\n\n```javascript\n// 当valueA和valueB不变的时候不更新\n<div v-memo=\"[valueA, valueB]\">\n  ...\n</div>\n// 当item.id === selected条件成立不更新\n<div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id === selected]\">\n  <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>\n  <p>...more child nodes</p>\n</div>\n```\n>值得注意的是如果不传任何东西，效果和v-once一样。\n\n`当搭配 v-for 使用 v-memo，确保两者都绑定在同一个元素上。v-memo 不能用在 v-for 内部。`\n## v-cloak\n用于隐藏尚未完成编译的 DOM 模板\n\n使用场景\n- 在数据未完全挂载到实例上时，会出现如v-pre指令的原始内容效果的”未编译模板闪现“的情况\n >搭配 [v-cloak] { display: none } css属性，可以避免这种情况，v-cloak会一直挂载在标签上直到组件编译完成前都隐藏原始模板，最后他会自动移除。\n\n# 五、虚拟Dom\n>虚拟Dom的存在大大降低了 操作真实DOM的代价，因为一个真实DOM结点上的属性有很多，通过对虚拟DOM的预操作让真实DOM以最小的代价更新视图。虚拟DOM是JS对象，里面储存了关于结点的信息。\n\n\n>真实DOM属性\n\n```javascript\n<div></div>\n```\n\n![真实DOM属性](https://img-blog.csdnimg.cn/90912a40bdee4a1d8688dd7d63cba3ab.png)\n\n>虚拟DOM结点\n```javascript\n<div id=\"app\">\n  \t<h1>hello world!</h1>\n</div>\n```\n>对应的虚拟DOM为\n\n```javascript\n{\n    tagName: 'div',\n    props: {\n      \tid: 'app'\n    },\n    children: [\n      \t{\n          \ttagName: 'h1',\n      \t\tprops: {},\n           \tchildren: ['hello world!']\n        }\n    ]\n}\n\n```\n\n# 五、diff算法\n>diff算法的目的就是用来以最少的代价操作DOM，就是能复用的绝不新建，以最少的移动操作DOM。\n\nVue3中diff算法相比Vue2来说，有了很大的提升，主要靠他**最长增长子序列算法**来提升移动Dom代价。\n\n---\nVue2更新结点的操纵主要有（同级对比，深度优先遍历）\n\n- 如果新节点有子节点而老节点没有子节点，则判断老节点是否有文本内容，如果有就清空老节点的文本内容，然后为其新增子节点。\n- 如果新节点没有子节点而老节点有子节点，则先删除老节点的子节点，然后设置文本内容。\n- 如果新节点没有子节点，老节点也没有子节点，则进行文本的比对，然后设置文本内容。\n- 如果新节点有子节点，老节点也有子节点，则进行新老子节点的比对，然后进行新增、移动、删除的操作，这就是diff 算法发生的地方。\n\n\nVue2中是通过双端对比算法来进行DOM的操作，主要操作有：\n\n- 头（新）<===>头（旧）\n- 尾（新）<===>尾（旧）\n- 头（旧）<===>尾（新）\n- 尾（新）<===>头（旧）\n\n在比较过程中如果存在相同就移动复用，出现多的或者少的就进行新增和删除操作。\n\n最后对于旧DOM中多的没有比对的就删除，新DOM没有比对的就新增。\n\n---\n\nVue3中，分为两种情况，有key和没有key的标识，key也就是标签上的key，大多在使用v-for时，key比较常见。\n\n - 没有key\n>没有Key时，，总共分为三步\n\n -     \n        -    头（新）<----> 头（旧）\n        从左到右依次比对，相同就直接复用，一直到不同\n        -    尾（新）<----> 尾（旧）\n        从右到左依次比对，相同就直接复用，一直到不同\n        -  更新和删除操作\n        剩余结点如果多了就删除，少了就新增。（删除在前，新增在后）\n   \n   ---\n     \n - 有key\n >有key时，会经过五步，，其中最重要的为第五步，也是运用了最长递增子序列算法的步骤\n -               \n     -  前序比较\n     从左到右依次比对，相同就直接复用，一直到不同\n     -  后序比较\n     从右到左依次比对，相同就直接复用，一直到不同\n     -  检查新增\n     有需要新增则新增 \n     -  检查删除\n     有需要删除则删除\n     - 剩余结点数新旧一样 （无序）特殊处理\n       - 构建新结点的映射关系\n       - 新增或者删除结点 \n       - move为true求最长递增子序列\n       得到移动结点的最小代价，时间复杂度为O（nlogn）\n        - 移动不在序列里的结点\n\n---\n   \n   \n   >最长递增子序列：\n```javascript\n// 贪心+二分\nfunction getSequence(arr: number[]): number[] {\n  const p = arr.slice() //  保存原始数据\n  const result = [0]    //  存储最长增长子序列的索引数组\n  let i, j, u, v, c\n  const len = arr.length\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i]\n    if (arrI !== 0) {\n      j = result[result.length - 1]  //  j是子序列索引最后一项\n      if (arr[j] < arrI) {            //  如果arr[i] > arr[j], 当前值比最后一项还大，可以直接push到索引数组(result)中去\n        p[i] = j                    //  p记录第i个位置的索引变为j\n        result.push(i)\n        continue\n      }\n      u = 0                          //  数组的第一项\n      v = result.length - 1          //  数组的最后一项\n      while (u < v) {                //  如果arrI <= arr[j] 通过二分查找，将i插入到result对应位置；u和v相等时循环停止\n        c = (u + v) >> 1             //  二分查找\n        if (arr[result[c]] < arrI) {\n          u = c + 1                   //  移动u\n        } else {\n          v = c                      //  中间的位置大于等于i,v=c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1]         //  记录修改的索引\n        }\n        result[u] = i                 //  更新索引数组(result)\n      }\n    }\n  }\n  u = result.length\n  v = result[u - 1]\n  //把u值赋给result\n  while (u-- > 0) {                 //  最后通过p数组对result数组进行进行修订，取得正确的索引\n    result[u] = v\n    v = p[v]\n  }\n  return result\n}\n```\n\n\n\n所以对于key的运用一定程度上能提升性能。\n\n \n\n---\n","tags":["前端","Vue3","指令","DIFF","组合式API"],"categories":["Vue","前端","指令","Vue3"]},{"title":"SpringCloud（学习 商品服务-属性分组的开发）六","url":"/2023/08/11/SpringCloud（学习 商品服务-属性分组的开发）六/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n# 前言\n\n本文主要记录开发商品服务的过程，及查询、新增、修改等功能的开发。\n\n---\n\n\n\n# 一、属性分组表关系\n\n## 属性分组-规格参数-销售属性-三级分类 关联关系\n\n![属性分组关系表](https://img-blog.csdnimg.cn/dde86c40784a4cc6a1766b19f6ec09d9.png)\n\n## 商品属性表关系\n![商品属性关系表](https://img-blog.csdnimg.cn/4f79c6747fe5442798ce30ebbfa582b6.png)\n\n# 二、查询功能的开发\n\n>查询功能的开涉及到多个字段的模糊查询，模糊查询的参数使用key来接收，并通过key来查询列表\n![查询功能](https://img-blog.csdnimg.cn/a66fd340380c4b668e49076c30011d6c.png)\n\n## 1、接口编写\n\n>在controller层编写接口，利用queryPage（）方法来查询列表，catelogId为当前节点id，params为分页、条数、key信息。\n\n```java\n @RequestMapping(\"/list/{catelogId}\")\n    //@RequiresPermissions(\"product:attrgroup:list\")\n    public R list(@RequestParam Map<String, Object> params,\n                  @PathVariable(\"catelogId\")Long catelogId){\n//        PageUtils page = attrGroupService.queryPage(params);\n        PageUtils page = attrGroupService.queryPage(params,catelogId);\n\n        return R.ok().put(\"page\", page);\n    }\n```\n\n## 2、创建方法\n\n>在service层创建queryPage方法\n\n```java\nPageUtils queryPage(Map<String, Object> params, Long catelogId);\n```\n\n## 3、实现方法\n\n>实现该方法\n\n```java\n  @Override\n    public PageUtils queryPage(Map<String, Object> params, Long catelogId) {\n        //模糊查询的参数\n        String key = (String) params.get(\"key\");\n        //select * from pms_attr_group where catelog_id=? and (attr_group_id=key or attr_group_name like %key%)\n        QueryWrapper<AttrGroupEntity> wrapper = new QueryWrapper<AttrGroupEntity>();\n        if (!StringUtils.isEmpty(key)){\n            wrapper.and((obj)->{\n                obj.eq(\"attr_group_id\",key).or().like(\"attr_group_name\",key);\n            });\n        }\n        if (catelogId == 0){\n           IPage<AttrGroupEntity>page = this.page(new Query<AttrGroupEntity>().getPage(params),\n                   wrapper);\n            return new PageUtils(page);\n        }else {\n            wrapper.eq(\"catelog_id\",catelogId);\n            IPage<AttrGroupEntity>page = this.page(new Query<AttrGroupEntity>().getPage(params),\n                    wrapper);\n            return new PageUtils(page);\n        }\n    }\n```\n\n\n# 三、新增和修改功能的开发\n>新增和修改功能主要是其中所属分类的选择和回显的开发。\n\n![新增和修改](https://img-blog.csdnimg.cn/503843c8a73d4a749be9151515954c6f.png)\n## 1、所属分类的连级选择\n>调用之前的三级分类列表的接口，但是该接口会在第三级字段里面添加一个空的子集列表，这会导致组件显示异常，所以需要将该集合从返回数据中去除。\n\n![连级选择异常](https://img-blog.csdnimg.cn/7bc6dc1467004c509f72370e0e9033db.png)\n>在实体类children字段上利用@JsonInclude注解判断该字段是否为空，为空则不返回\n```java\n/**\n\t * 子集合\n\t */\n\t@JsonInclude(JsonInclude.Include.NON_EMPTY) //为空不带\n\t@TableField(exist = false) //不是表中的字段，用来标记排除\n\tprivate List<CategoryEntity>children;\n```\n\n\n|用法  | 解释 |\n|--|--|\n| ALWAYS | 默认策略，任何情况都执行序列化 |\n| NON_NULL | 非空 |\n| NON_ABSENT | null的不会序列化，但如果类型是AtomicReference，依然会被序列化 |\n| NON_EMPTY | null、集合数组等没有内容、空字符串等，都不会被序列化 |\n| NON_DEFAULT | 如果字段是默认值，就不会被序列化 |\n| CUSTOM |此时要指定valueFilter属性，该属性对应一个类，用来自定义判断被JsonInclude修饰的字段是否序列化 |\n| USE_DEFAULTS | 当JsonInclude在类和属性上都有时，优先使用属性上的注解，此时如果在序列化的get方法上使用了JsonInclude，并设置为USE_DEFAULTS，就会使用类注解的设置   |\n\n\n\n## 2、回显\n>由于通过点击事件后，他会回显为第三级的id，但是该组件需要完整的分类id,所以需要返回完整id的字段用于回显。\n>\n![三级分类回显](https://img-blog.csdnimg.cn/94bb25488e554f32b3f5bedc1081238e.png)\n## 1、实体类添加字段\n>实体类添加字段用来返回完整三级分类的id\n\n```java\n/**\n\t * 所属分类全id\n\t */\n\t@TableField(exist = false)\n\tprivate Long[] catelogIds;\n```\n\n## 2、编写接口层\n\n>用于将原来返回的数据添加一个完整id的属性，使用findCatelogPath方法查找完整Id。\n\n```java\n@RequestMapping(\"/info/{attrGroupId}\")\n    //@RequiresPermissions(\"product:attrgroup:info\")\n    public R info(@PathVariable(\"attrGroupId\") Long attrGroupId){\n\t\tAttrGroupEntity attrGroup = attrGroupService.getById(attrGroupId);\n\n        Long catelogId = attrGroup.getCatelogId();\n        Long[]path = categoryService.findCatelogPath(catelogId);\n        attrGroup.setCatelogIds(path);\n        return R.ok().put(\"attrGroup\", attrGroup);\n    }\n```\n\n\n## 3、创建方法\n>在service层创建findCatelogPath方法，catelogId为当前节点id\n\n```java\n Long[] findCatelogPath(Long catelogId);\n```\n\n## 4、实现方法\n>实现findCatelogPath方法，利用传过来的第三级id创建findParentPath方法递归查找父id，并最终返回完整id。\n\n```java\n  @Override\n    public Long[] findCatelogPath(Long catelogId) {\n        List<Long> paths = new ArrayList<>();\n        List<Long> parentPath = findParentPath(catelogId,paths);\n        //逆序返回的id数组\n        Collections.reverse(parentPath);\n        return paths.toArray(new Long[parentPath.size()]);\n    }\n\n    /**\n     * \n     * @param catelogId 当前节点id\n     * @param paths 目前收集的id\n     * @return 完整的id\n     */\n    private List<Long>findParentPath(Long catelogId,List<Long> paths){\n        //1、收集当前节点id\n        //2、当前节点存在父节点就递归本方法\n        //3、收集完返回\n        paths.add(catelogId);\n        CategoryEntity byId = this.getById(catelogId);\n        if (byId.getParentCid()!=0){\n            findParentPath(byId.getParentCid(),paths);\n        }\n        return paths;\n    }\n```\n\n>**Collections工具类方法：**\n\n|方法  | 解释 |\n|--|--|\n| reverse(List list) | 反转列表中元素的顺序 |\n| shuffle(List list)  | 对List集合元素进行随机排序 |\n| sort(List list) | 根据元素的自然顺序 对指定列表按升序进行排序 |\n| sort(List list, Comparator c) | 根据指定比较器产生的顺序对指定列表进行排序 |\n| swap(List list, int i, int j) | 在指定List的指定位置i,j处交换元素 |\n| rotate(List list, int distance) | 当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为 负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度 |\n\n\n---\n\n# 总结\n本文主要讲了属性分组中，查询、新增、修改功能的开发，并记录开发过程中遇到的返回数据去除注解以及Collections工具类的使用。\n\n","tags":["后端","SpringCloud","商品服务","‘@JsonInclude注解’","Collections工具"],"categories":["SpingCloud","微服务","后端","项目","谷粒商城","注解","‘@JsonInclude’","工具","Collections工具"]},{"title":"SpringCloud（学习 商品服务-品牌管理的开发）五","url":"/2023/08/11/SpringCloud（学习 商品服务-品牌管理的开发）五/","content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\n本章内容主要记录品牌服务的开发，重点在于阿里云平台oss对象存储、后端数据参数校验JSR303的使用。\n\n---\n\n\n# 一、品牌服务\n\n>品牌服务用于管理品牌的添加、修改、删除等操作，可上传logo到图片服务器中，数据库存储的是图片地址,对于品牌的操作主要涉及添加和修改的操作，后端对于数据的校验分为普通校验、分组校验、自定义校验三种方式来校验数据。\n\n![品牌服务界面](https://img-blog.csdnimg.cn/adbd23d65c6f41faab8c002a43ab8509.png)\n![新增](https://img-blog.csdnimg.cn/818fc13900f14ee5b29672f159366ae0.png)\n\n\n---\n# 二、图片服务\n## 1.开通oss对象存储服务\n>首先，图片存储服务不止阿里云有，还有像七牛云之类的都有类似的服务，前期使用七牛云主要七牛云存储过程与本项目有点出入，所以这里还是选择阿里云平台进行存储。\n\n - **首先找到oss对象存储并开通服务**\n\n![阿里云平台oss对象存储](https://img-blog.csdnimg.cn/d12223e1ead641219b43dffeb2a9d920.png)\n\n- **创建Bucket**\n![创建Bucket](https://img-blog.csdnimg.cn/bd6c695236bc4bcdb1e5657b353c42d2.png)\n`箭头标注的为比较重要的点，名称在项目中会使用到，而公共读是方便开发，后期可以修改私有`\n\n- **找到AccessKey和SecretKey**\n- **添加权限**\n\n![添加权限](https://img-blog.csdnimg.cn/e36c739ddcd94eb68f2014a88d32c3e9.png)\n\n- **找到外网访问域名**\n\n![外网访问域名](https://img-blog.csdnimg.cn/e8e34df745d844f1a58712bc68bf761f.png)\n\n- **配置跨域**\n![跨域](https://img-blog.csdnimg.cn/23fbee856cb945b6ac38aa20a4ce740d.png)\n`这里是配置了post的所有请求`\n\n- **找到java的示例**\n\n![OSS JAVA](https://img-blog.csdnimg.cn/d660bf52b6a14e7184af569b20f5861a.png)\n\n\n\n---\n>至此阿里云平台的配置就完成了，可以进行图片服务的开发了\n\n## 2.图片储存服务\n\n - **创建图片服务并在注册中心中注册**\n - **添加maven依赖**\n\n```java\n <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alicloud-oss</artifactId>\n            <version>2.2.0.RELEASE</version>\n        </dependency>\n```\n\n`这里的依赖是使用了cloud的依赖，这样可以直接使用ossClient实例，官方依赖如下:`\n\n```java\n<dependency>\n    <groupId>com.aliyun.oss</groupId>\n    <artifactId>aliyun-sdk-oss</artifactId>\n    <version>3.15.1</version>\n</dependency>\n```\n\n- **编写接口类**\n\n```java\n@RequestMapping(\"/oss/policy\")\n    public R policy() {\n        // 填写Host地址，格式为https://bucketname.endpoint。\n        String host = \"https://\" + bucket + \".\" + endpoint;\n        // 设置上传回调URL，即回调服务器地址，用于处理应用服务器与OSS之间的通信。OSS会在文件上传完成后，把文件上传信息通过此回调URL发送给应用服务器。\n        // String callbackUrl = \"https://192.168.0.0:8888\";\n        // 设置上传到OSS文件的前缀，可置空此项。置空后，文件将上传至Bucket的根目录下。\n        String format = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n        String dir = format + \"/\";\n\n        Map<String, String> respMap = null;\n        // 创建ossClient实例。\n        try {\n            long expireTime = 30;\n            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;\n            Date expiration = new Date(expireEndTime);\n            PolicyConditions policyConds = new PolicyConditions();\n            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);\n            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);\n\n            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);\n            byte[] binaryData = postPolicy.getBytes(\"utf-8\");\n            String encodedPolicy = BinaryUtil.toBase64String(binaryData);\n            String postSignature = ossClient.calculatePostSignature(postPolicy);\n\n            respMap = new LinkedHashMap<String, String>();\n            respMap.put(\"accessid\", accessId);\n            respMap.put(\"policy\", encodedPolicy);\n            respMap.put(\"signature\", postSignature);\n            respMap.put(\"dir\", dir);\n            respMap.put(\"host\", host);\n            respMap.put(\"expire\", String.valueOf(expireEndTime / 1000));\n            // respMap.put(\"expire\", formatISO8601Date(expiration));\n\n\n        } catch (Exception e) {\n            // Assert.fail(e.getMessage());\n            System.out.println(e.getMessage());\n        }\n        return R.ok().put(\"data\", respMap);\n    }\n```\n\n- **nacos添加配置**\n\n```yaml\nspring:\n  cloud:\n    alicloud:\n      access-key: My access-key\n      secret-key: My secret-key\n      oss:\n        endpoint: oss-cn-hangzhou.aliyuncs.com\n        bucket: guli-smz\n```\n\n---\n\n>至此图片服务编写完成\n\n---\n\n# 三、后端数据校验\n\n - **首先加入校验的相关依赖**\n\n```java\n <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n            <version>3.1.1</version>\n        </dependency>\n```\n\n## 1、普通校验\n- **给Bean添加注解：javax.validation.constraints，定义自己的message提示**\n\n```java\n@NotNull(message =\"修改必须指定品牌id\")\n\t@Null(message = \"新增不能指定id\")\n\t@TableId\n\tprivate Long brandId;\n```\n\n- **开启校验，在controller层添加注解@Valid**\n\n```java\n@RequestMapping(\"/save\")\n    //@RequiresPermissions(\"product:brand:save\")\n    public R save(@Valid @RequestBody BrandEntity brand/*, BindingResult result*/){\n```\n\n- 由于错误存在于所有服务，所以在common编写一个错误状态码和错误信息定义枚举类\n\n```java\n/**\n * 错误状态码和错误信息定义类\n * 1、错误码定义规则为5位数字\n * 2、前两位表示业务场景，最后三位表示错误码。例如：100001。10：通用 001：系统未知异常\n * 3、维护错误码后需要维护错误描述，将他们定义为枚举形式\n *\n * 错误码列表：\n * 10：通用\n *     001：参数格式校验\n * 11：商品\n * 12：订单\n * 13：购物车\n * 14：物流\n */\npublic enum BizCodeEnume {\n    UNKNOW_EXCEPTION(10000,\"系统未知异常\"),\n    VAILD_EXCEPTION(10001, \"参数格式校验失败\");\n\n    private final int code;\n    private final String msg;\n    BizCodeEnume(int code, String msg){\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public int getCode(){\n        return code;\n    }\n    public String getMsg(){\n        return msg;\n    }\n}\n\n```\n\n- **编写集中异常处理类**\n\n```java\n@Slf4j\n@RestControllerAdvice(basePackages = \"com.smz.guli.product.controller\")\npublic class GuliExceptionControllerAdvice {\n\n    /**\n     *\n     * @param e 捕获的精确异常\n     * @return 返回异常信息集合\n     */\n    @ExceptionHandler(value = Exception.class)\n    public R handleVaildException(MethodArgumentNotValidException e){\n        BindingResult bindingResult = e.getBindingResult();\n        Map<String,String> errorMap = new HashMap<>();\n        bindingResult.getFieldErrors().forEach((fieldError -> {\n            errorMap.put(fieldError.getField(),fieldError.getDefaultMessage());\n        }));\n        return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(), BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(\"data\",errorMap);\n    }\n\n    /**\n     *\n     * @param throwable 其它异常捕获\n     * @return 返回错误\n     */\n    @ExceptionHandler(value = Throwable.class)\n    public R handleException(Throwable throwable){\n        log.error(\"错误\", throwable);\n        return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(), BizCodeEnume.UNKNOW_EXCEPTION.getMsg());\n    }\n\n}\n```\n\n---\n\n>在规则中**regexp**为正则校验，**message**为自定义信息，**groups**为规则组\n\n```java\n\t@Pattern(regexp = \"^[a-zA-Z]$\",message = \"检索首字母必须为字母\",groups = {AddGroup.class, UpdateGroup.class})\n```\n**常用注解如下：**\n\n|注解| 作用 |\n|--|--|\n| @Null| 被注释的元素必须为null |\n| @NotNull | 被注释的元素不能为null，可以为空字符串 |\n| @AssertTrue | 被注释的元素必须为true |\n| @AssertFalsel | 被注释的元素必须为false |\n| @Min(value) | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| @Max(value) | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| @DecimalMin(value) | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| @DecimalMax(value) | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| @Size(max,min) | 被注释的元素的大小必须在指定的范围内 |\n|@Digits(integer,fraction)  | 被注释的元素必须是一个数字，其值必须在可接受的范围内 |\n| @Past | 被注释的元素必须是一个过去的日期 |\n| @Future | 被注释的元素必须是一个将来的日期 |\n| @Pattern(value) | 被注释的元素必须符合指定的正则表达式 |\n| @Email | 被注释的元素必须是电子邮件地址 |\n| @Length | 被注释的字符串的大小必须在指定的范围内 |\n| @Range | 被注释的元素必须在合适的范围内 |\n| @NotEmpty | 用在集合类上，不能为null，并且长度必须大于0 |\n| @NotBlank | 只能作用在String上，不能为null，而且调用trim()后，长度必须大于0 |\n\n\n## 2、分组校验\n>分组校验的场景用于同一接口的不同操作来进行校验，不同操作也适用于其它接口。\n\n- **在common编写接口用于区分不同的分组**\n\n```java\n/**\n * 添加分组\n */\npublic interface AddGroup {\n}\n\n/**\n * 修改分组\n */\npublic interface UpdateGroup {\n}\n\n```\n\n- **在实体类添加注解用于区分不同操作对应的分组**\n\n```java\n/**\n\t * 品牌id\n\t */\n\t@NotNull(message =\"修改必须指定品牌id\", groups = {UpdateGroup.class})\n\t@Null(message = \"新增不能指定id\", groups = {AddGroup.class})\n\t@TableId\n\tprivate Long brandId;\n\t/**\n\t * 品牌名\n\t */\n\t@NotBlank(message = \"品牌名不能为空\", groups = {AddGroup.class})\n\tprivate String name;\n```\n\n- **更换controller层注释为@Validated并添加校验分组**\n\n```java\n @RequestMapping(\"/update\")\n    //@RequiresPermissions(\"product:brand:update\")\n    public R update(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand){\n\t\tbrandService.updateById(brand);\n\n        return R.ok();\n    }\n\n@RequestMapping(\"/save\")\n    //@RequiresPermissions(\"product:brand:save\")\n    public R save(@Validated(AddGroup.class) @RequestBody BrandEntity brand/*, BindingResult result*/){\n\t\tbrandService.save(brand);\n\n        return R.ok();\n    }\n```\n\n\n## 3、自定义校验\n>自定义校验用于复杂的校验逻辑，用于处理内置校验规则处理不了的数据校验。\n\n- 创建一个配置文件用于存放自定义消息\n`文件名必须为 ValidationMessages.properties 会自动从该文件找配置项` \n\n```java\ncom.smz.common.valid.ListValue.message=必须填写该项\n```\n\n- **创建一个自定义注解类**\n\n```java\n@Documented\n@Constraint(\n        validatedBy = {ListValueConstraintValidator.class}\n)\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ListValue {\n    // 自定义消息指向\n    String message() default \"{com.smz.common.valid.ListValue.message}\";\n\n    //实现规则的选取\n    Class<?>[] groups() default {};\n\n    //接收的消息体\n    Class<? extends Payload>[] payload() default {};\n\n    //自定义接收参数\n    int[] vals() default {};\n\n}\n```\n- **创建一个校验器**\n\n```java\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport java.util.HashSet;\nimport java.util.Set;\n/**\n * @ListValue 校验器\n * ListValue 校验注解\n * Integer 校验类型\n * initialize 初始化方法 （获取详细信息）\n * isValid 判断是否校验成功\n */\npublic class ListValueConstraintValidator implements ConstraintValidator<ListValue,Integer> {\n    private final Set<Integer>set = new HashSet<>();\n\n    /**\n     *\n     * @param constraintAnnotation 初始化方法\n     */\n    @Override\n    public void initialize(ListValue constraintAnnotation) {\n       int[] vals = constraintAnnotation.vals();\n       for (int val : vals){\n           set.add(val);\n       }\n    }\n\n\n    /**\n     *\n     * @param value 需要校验的值\n     * @param context 定义是否包含\n     * @return 返回是否包含\n     */\n    @Override\n    public boolean isValid(Integer value, ConstraintValidatorContext context) {\n        return set.contains(value);\n    }\n}\n\n```\n\n\n- **使用自定义校验**\n\n```java\n/**\n\t * 显示状态[0-不显示；1-显示]\n\t */\n\t@ListValue(vals={0,1},groups = {AddGroup.class})\n\tprivate Integer showStatus;\n```\n\n---\n\n# 总结\n\n本文主要讲了阿里OSS对象储存的对接以及后端JSR303数据校验的三种使用。\n","tags":["后端","SpringCloud","品牌服务","参数校验","oss对象存储"],"categories":["SpingCloud","微服务","后端","项目","谷粒商城","oss对象存储","参数校验","JSR303"]},{"title":"SpringCloud（学习 商品服务-三级分类的开发）四","url":"/2023/08/11/SpringCloud（学习 商品服务-三级分类的开发）四/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\n\n本文主要记录商品服务的开发，以及过程中遇到的知识点等。\n\n---\n\n\n# 一、三级分类\n## 表结构\n>其中最顶级的**parent_cid**（父分类id）为**0**\n>\n![商品三级分类表](https://img-blog.csdnimg.cn/0cdea9b2f4d144f6b6b2fbcee4decdb9.png)\n\n---\n\n## Controller编写\n>用于返回所有分类以及子分类，以树型结构组装起来\n\n```java\n @RequestMapping(\"/list/tree\")\n    public R list(){\n        List<CategoryEntity> entities = categoryService.listWithTree();\n        return R.ok().put(\"data\", entities);\n    }\n```\n\n---\n\n## Service编写\n\n - Service接口编写\n >定义listWithTree方法用于返回树型结构\n\n```java\n List<CategoryEntity> listWithTree();\n```\n\n - 实体类加入子类集合属性\n \n\n```java\n\t@TableField(exist = false) //不是表中的字段，用来标记排除\n\tprivate List<CategoryEntity>children;\n```\n\n - 实现类实现方法\n    \n   - 查询出所有分类\n   - 过滤出最顶层分类\n   - 将剩余分类传入方法进行递归查找子菜单\n   \n\n```java\n @Override\n    public List<CategoryEntity> listWithTree() {\n        //1.查出所有分类\n        List<CategoryEntity>entities = baseMapper.selectList(null);\n        //2.组装成树形结构\n        //2.1 找到所有的一级分类\n        return entities\n                .stream()//将集合转换为流\n                .filter(categoryEntity -> categoryEntity.getParentCid() == 0)//过滤最高层菜单\n                //返回一个新的流\n                .peek((menu)-> menu.setChildren(getChildrens(menu,entities)))//查找子菜单\n                .sorted(Comparator.comparingInt(menu -> (menu.getSort() == null ? 0 : menu.getSort())))//根据sort字段排序\n                // 1.toList()转换为List集合（允许重复，有顺序）\n                // 2.toSet()转换为Set集合（不允许重复，没有顺序）\n                // 3.joining()直接将结果拼接\n                // 4.joining(\" | \")每个输出结果之间加拼接符号“|”\n                // 5.joining(\" || \", \"Start--\", \"--End\")开始头为Start--，结尾为--End，中间用拼接符号“||”\n                // 6.collectingAndThen()收集后做其它处理\n                .collect(Collectors.toList());\n    }\n\n    //递归查找所有菜单的子菜单\n    private List<CategoryEntity>getChildrens(CategoryEntity root,List<CategoryEntity>all){\n        return all.stream()\n                .filter(categoryEntity -> Objects.equals(categoryEntity.getParentCid(), root.getCatId()))//比较父与子菜单是否对应\n                .peek(categoryEntity -> categoryEntity.setChildren(getChildrens(categoryEntity,all)))// 递归找子菜单\n                .sorted(Comparator.comparingInt(menu -> (menu.getSort() == null ? 0 : menu.getSort())))// 根据sort字段排序\n                .collect(Collectors.toList());\n    }\n```\n\n\n![树型结构返回](https://img-blog.csdnimg.cn/96af8d6db8234044b9cffe67faeace84.png)\n\n---\n\n\n\n\n# 二、请求通过网关转发\n\n>Spring Cloud 2020版本以后，默认移除了对Netflix的依赖，其中就包括Ribbon，官方默认推荐使用Spring Cloud Loadbalancer正式替换Ribbon，并成为了Spring Cloud负载均衡器的唯一实现\n\n```java\n<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-loadbalancer</artifactId>\n\t\t</dependency>\n```\n\n - **将renren-fast 后台服务注册到注册中心**\n - **在网关服务中拦截renren-fast前端请求并控制和修改**\n \n\n```java\nspring:\n  cloud:\n    gateway:\n      routes: #是个集合\n        - id: admin_route\n          uri: lb://renren-fast  #负载均衡到 renren-fast服务 springcloud2020后需要加Loadbalancer的依赖 作为负载均衡\n          predicates:\n            - Path=/api/**   #‘/api’ 下的所有请求\n          filters:\n            - RewritePath=/api/(?<segment>.*),/renren-fast/$\\{segment}\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/da98d39b0147404ab5169923fbda2b0c.png)\n\n---\n# 三、网关配置跨域\n>问题描述：\n>当在请求登录接口时会发生CORS跨域问题。\n>不满足同源策略的都会发生跨域问题\n\n>**同源策略**：协议、域名、端口都要相同，其中有一个不同都会产生跨域\n>\n![CORS跨域问题](https://img-blog.csdnimg.cn/0c298dd7644b4862a913a0cd61122627.png)\n\n\n ##  跨域流程\n \n [跨域访问控制详解](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n>非简单请求会产生CORS问题，其中简单请求是指：\n   - GET\n   - HEAD\n   - POST\n   - Content-Type 标头所指定的媒体类型的值仅限于下列三者之一：\n      - text/plain\n      - multipart/form-data\n      - application/x-www-form-urlencoded\n    \n>非简单请求，需要先发送预检请求（OPTIONS）\n\n![CORS请求流程](https://img-blog.csdnimg.cn/086a1f099bdf41e7bf66388a02ebf8db.png)\n## 解决跨域\n\n \n\n - **使用nginx部署为同一域**\n >将前端和后端部署在nginx服务器上，当静态请求先给nginx服务器，再由nginx服务器给前端；当为动态请求时，nginx会将请求转发给网关，然后网关再去找对应服务\n >\n ![nginx解决跨域](https://img-blog.csdnimg.cn/a92b4fdcf33342788e2861deba8c0809.png)\n - **通过网关配置请求头使服务器允许跨域**\n >添加响应头\n \n ![添加跨域请求头](https://img-blog.csdnimg.cn/f589f9dc0e0a42b093a34b21e83144a7.png)\n\n---\n>这里使用第二种方式\n\n 首先在网关服务中创建配置类，并进行配置，最后注入到容器中\n \n\n```java\n@Configuration //配置类标识\npublic class GuliCorsConfiguration {\n\n    @Bean //注入容器\n    public CorsWebFilter corsWebFilter(){\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\n\n       //1.配置跨域\n        corsConfiguration.addAllowedHeader(\"*\"); //允许哪些头跨域\n        corsConfiguration.addAllowedMethod(\"*\"); //允许哪些请求跨域\n        corsConfiguration.addAllowedOriginPattern(\"*\"); //允许哪些请求来源跨域\n        corsConfiguration.setAllowCredentials(true); //是否允许携带cook进行跨域\n\n        source.registerCorsConfiguration(\"/**\",corsConfiguration); //path：进行配置跨域的路径\n        return new CorsWebFilter(source);\n    }\n}\n```\n---\n\n# 四、将分类请求转发给商品服务\n\n - 将商品服务注册到注册中心\n - 在nacos新建商品服务的命名空间\n - 在网关服务配置转发路由\n \n\n```java\nspring:\n  cloud:\n    gateway:\n      routes: #是个集合\n        - id: product_route\n          uri: lb://guli-product  #负载均衡到 guli-product服务 springcloud2020后需要加Loadbalancer的依赖 作为负载均衡\n          predicates:\n            - Path=/api/product/**   #‘/api/product’ 下的所有请求\n          filters:\n            - RewritePath=/api/(?<segment>.*),/$\\{segment} #去除/api/使转发请求正确\n```\n\n`配置网关路由时将更为准确的predicates放在上边，范围更广的放在后边，避免转发地址错误`\n\n# 五、删除三级分类\n>编写删除接口，删除以数组形式将菜单id传入，可适配批量删除和单独删除\n\n```java\n/**\n     * 删除\n     * @RequestBody 获取请求体\n     */\n    @RequestMapping(\"/delete\")\n   // @RequiresPermissions(\"product:category:delete\")\n    public R delete(@RequestBody Long[] catIds){\n\t\t//categoryService.removeByIds(Arrays.asList(catIds));\n\n        //1.判断是否在其他地方被引用\n        return categoryService.removeMenuByIds(Arrays.asList(catIds));\n    }\n```\n\n\n# 六、新增三级分类\n>编写新增接口，以菜单实体类的形式传入后保存\n\n```java\n/**\n     * 保存\n     */\n    @RequestMapping(\"/save\")\n    //@RequiresPermissions(\"product:category:save\")\n    public R save(@RequestBody CategoryEntity category){\n\t\tcategoryService.save(category);\n\n        return R.ok(200,\"success\");\n    }\n```\n# 七、编辑三级分类\n>编写批量修改接口\n\n```java\n /**\n     * 批量修改\n     */\n    @RequestMapping(\"/update/sort\")\n    //@RequiresPermissions(\"product:category:update\")\n    public R updateSort(@RequestBody CategoryEntity[] category){\n        categoryService.updateBatchById(Arrays.asList(category));\n\n        return R.ok();\n    }\n```\n# 总结\n\n本文主要讲了商品服务三级分类的相关业务功能开发，以及请求转发、跨域配置等。前端请求先通过网关验证后转发给对应服务，其中网关可对请求做出修改，跨域解决就是通过该方法解决，值得一提的是如果进行跨域，请求会先发送一个预检请求，服务器同意后才能将真正的请求发送给服务器。\n\n","tags":["后端","SpringCloud","商品服务","跨域","请求转发"],"categories":["SpingCloud","微服务","后端","项目","谷粒商城","网关","跨域"]},{"title":"开发tips","url":"/2023/07/04/开发小tips/","content":"\n\n\n\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n用于记录开发小tips。\n\n---\n\n\n# 一、css相关\n## 1. 优先使用:not()进行排除元素\n\n```javascript\n<div class=\"nav\" >\n    <li></li>\n    <li></li>\n    <li></li>\n    <li></li>\n</div>\n\n```\n\n---\n\n`不好的做法：`\n\n```javascript\n .nav li {\n        margin-top: 30px;\n        border: 1px solid red;\n    }\n    /*最后一个元素*/\n    .nav li:last-child {\n        border: none;\n    }\n```\n![去掉子元素](https://img-blog.csdnimg.cn/f54d32d3470148f098c79249e950cb08.png)\n\n`较好的做法：`\n\n```javascript\n .nav li {\n        margin-top: 30px;\n        border: 1px solid red;\n    }\n    /*最后一个元素*/\n    .nav li:last-child {\n        border: none;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/59cca974dac74f74babe4e57565d4abe.png)\n## 2. 使用:root定义变量\n\n```javascript\n :root {\n        --bg: #333;\n        --color: red;\n        --height: 300px;\n    }\n    .nav {\n        background-color: var(--color);\n        height: var(--height);\n        color: var(--bg);\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/27bd41d5b2754d768b3346a16fee161c.png)\n## 3. 相同样式用“，”连接\n\n```javascript\n   .nav li, .nav div {\n        color: red;\n    }\n```\n## 4. 单位尽量不使用\"px\"\n## 5. :nth-child的使用\n\n```javascript\n<div class=\"nav\" >\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n    <p>4</p>\n    <p>5</p>\n</div>\n```\n---\n`前几个换色`\n\n```javascript\n .nav :nth-child(-n+3){\n        background-color: red;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8aa2b3eb234241e883b9ec122dee19e4.png)\n`后几个换色`\n\n```javascript\n.nav :nth-last-child(-n+3){\n        background-color: red;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e62d2fa1bd4d4ee89f983384f9ebe764.png)\n`隔行换色`\n\n```javascript\n .nav :nth-child(2n+1){\n        background-color: red;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b0fd38a8af734b2f90cfb368800e75d3.png)\n\n# 二、文档注释\n## 1.使用文档注释\n文档注释能更快的开发。\n\n```javascript\n/**\n * 函数防抖\n * @author SMZ <2240941938@qq.com>\n * @param {Function} func 防抖目标函数\n * @param {Number} duration 执行前等待时间\n * @return {Function} 返回一个防抖后的函数\n * @example\n * f(a,2000);\n */\nfunction f(func, duration = 1000) {\n    \n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d93aa2684c9c42bca9159d784e0d7f83.png)\n---\n---\n# 三、函数防抖\n * 频繁调用某个函数\n * 造成效率问题\n * 需要以最后一次调用为准\n\n```javascript\nfunction debounce(func, duration = 1000) {\n    let timer;\n    return function (...args) {\n        clearTimeout(timer); //清除之前的计时器\n        timer = setTimeout( ()=> {\n            func.apply(this);\n        },duration)\n    }\n}\n```\n---\n# 四、官方API\n不要使用\n\n```javascript\ndocument.getElementsByClassName('nav')\n```\n\n使用\n\n```javascript\ndocument.querySelectorAll('nav')\n```\n---\n\n# 五、位运算实现权限组合\n\n```javascript\nconst READ = 0b1; //（1）可读权限     00001\nconst CREATE = 0b10; //（2）可创建    00010\nconst UPDATE = 0b100; //（4）可更新   00100\nconst DELETE =0b1000; //（8）可删除   01000\n\n// 或运算组合权限\nconst jurisdiction =  READ | UPDATE | DELETE | CREATE\nconsole.log(jurisdiction.toString(2))\n\n//与运算查询是否具有某个权限\nconst smz = 14;\nif ((smz & READ) === 0) console.log(\"无可读权限\")\nelse console.log(\"有可读权限\")\n\n//异或运算删除或者更改权限(原来有权限时是删除，原来没有时是更改，如果是更改时需要判断原来是否具有权限)\nconst smz2 = smz ^ READ\n```\n---\n# 六、JS相关\n\n - 随机颜色\n \n\n```javascript\nlet randomColor = \"#\" +\n    //Math.random() 随机选取大于等于0.0且小于1.0的伪随机 double 值\n\n    //取整\n    //  1.Math.round() 四舍五入\n    //  2.Math.ceil() 向上取整\n    //  3.Math.floor() 向下取整\n    Math.floor(Math.random()*16777215)\n.toString(16)\n```\n\n - 获取浏览器URL参数\n \n\n\n\n```javascript\nlet params = new URLSearchParams(\n    window.location.search\n)\n\nparams.get('参数名')\n```\n\n\n - 生成指定范围的随机整数\n \n\n```javascript\nlet randomInt = (min, max) =>\n    Math.floor(Math.random()* (max - min +1)) +min;\n\n\n```\n\n - 深度复制对象\n\n```javascript\nlet obj = {\n    name: 'smz',\n    age: 18,\n    other: {\n        type: '无',\n        other: {\n            type: '无',\n            other: {\n                type: '无'\n            }\n        }\n    }\n}\n//JSON.parse() 解析JSON字符串，得到对应的JavaScript值或对象\n//JSON.stringify() 将一个JavaScript对象或值转换为JSON格式字符串。\nlet cloneObj = JSON.parse(JSON.stringify(obj));\n\nconsole.log(cloneObj)\n\nif (Object.is(obj,cloneObj)) console.log(\"内存地址相同，为浅拷贝\")\nelse console.log(\"内存地址不同，为深拷贝\")\n```\n>内存地址不同\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d5a461f1b32d4507b19bc33b045bd397.png)\n\n","tags":["其它","tips","css","注释","位运算","函数"],"categories":["其它"]},{"title":"SpringCloud 学习-Nacos","url":"/2023/06/30/SpringCloud(学习 Nacos) 二/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n# 前言\n本文主要讲述微服务组件中的：**注册中心**、**配置中心**\n\n\n\n---\n\n\n# 一、各组件关系与技术选择\n\n![微服务组件关系图](https://img-blog.csdnimg.cn/88a8b667cbe746fdb3e18b673c596f70.png)\n\n **最终的技术搭配方案为：**\nSpringCloud Alibaba - Nacos：注册中心（服务发现/注册）\nSpringCloud Alibaba - Nacos：配置中心（动态配置管理）\nSpringCloud - Ribbon：负载均衡\nSpringCloud - Feign：声明式 HTTP 客户端（调用远程服务）\nSpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）\nSpringCloud - Gateway：API 网关（webflux 编程模式）\nSpringCloud - Sleuth：调用链监控\nSpringCloud Alibaba - Seata：原 Fescar，即分布式事务解决方案\n\n[阿里官方文档](https://spring-cloud-alibaba-group.github.io/github-pages/2021/en-us/index.html)\n\n[中文文档](https://github.com/alibaba/spring-cloud-alibaba/blob/2022.x/README-zh.md)\n\n[各版本对应关系](https://start.spring.io/actuator/info)\n>![springcloud关系对应](https://img-blog.csdnimg.cn/00bcaff35f324c219151a657151945fc.png)\n\n>`其中不止springboot与springcloud版本对应关系，还有其它与springboot的版本对应关系`\n\n在引入组件前引入依赖管理，可以在后续引入组件依赖时忽略版本号，这些依赖都引入公共模块common中。\n\n```java\n <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2021.0.4.0</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n# 二、Nacos\n## 1.Nacos作为注册中心\n>引入相关依赖：\n\n```java\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n---\n- 下载Nacos注册中心 [Nacos Server](https://github.com/alibaba/nacos/releases)\n- 为每个服务配置nacos服务注册配置\n\n>`server.port=8081\nspring.application.name=nacos-provider\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\nmanagement.endpoints.web.exposure.include=*`\n\n- 启动项添加注解@EnableDiscoveryClient开启服务注册/发现\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class GuliCouponApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(GuliCouponApplication.class, args);\n    }\n}\n```\n\n- 启动服务进行服务注册发现\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5cbf5c0b3f0c40feb84eebe71472b463.png)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/99b3ef7c5b91433895c648d4f3657188.png)\n\n---\n\n`如果使用win启动nacos则需要更改win启动脚本文件使用单机启动`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7d5240cba94545bd80a59d61830ee4f3.png)\n`在脚本文件末尾加入pause\nendlocal 可以在启动错误时不闪退，可以看到报错信息`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f3791bfec8844516aa48af647d1a3ba8.png)\n\n## 2.使用openFeign远程调用\n- Feign是一个声明式HTTP客户端，使服务间远程调用更方便，它内置了HTTP请求模板，通过接口和注解就可以定义好HTTP请求的参数等信息。\n- Feign整合了Ribbon（负载均衡）和Hystrix（服务熔断）\n- `这里在微服务版本超过2020时，Feign对负载均衡器做出了调整调整为Spring Cloud Loadbalancer，为此需要引入Spring Cloud Loadbalancer的相关依赖并移除Ribbon引用和增加配置,不然开启远程调用的服务会启动报错`\n\n```java\nspring.cloud.loadbalancer.ribbon.enabled: false\n```\n\n```java\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-loadbalancer</artifactId>\n</dependency>\n```\n---\n\n>引入依赖\n\n```java\n <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n </dependency>\n```\n\n- 远程调用步骤为\n   - 引入open-feign\n   - 在需要远程调用的服务里编写一个接口，这个接口需要调用远程服务\n       - 声明接口的每一个方法都是调用那个远程服务的那个请求\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/40c96b71bf7a4b5cac379ef82dfea0b4.png)\n\n\n   - 开启远程调用功能，在启动类中添加注解@EnableFeignClients(basePackages = \"com.smz.guli.member.feign\")，basePackages表示刚刚创建接口的位置。\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/8099107cd2b841a5a6af9a1700e2b279.png)\n   - 在接口处使用远程调用的接口可获取其它服务接口的值\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/ed8aec878a844c61a60ae62b0a5bce71.png)\n\n\n## 3.Nacos作为配置中心\n- 简介\n>配置中心主要解决的问题是，当需要修改某个服务的配置时，由于服务是集群化和分布式的，修改耗时耗力，配置中心则是统一化，将配置分发给对应的服务，这样就只用配置一遍而使所有服务都读取到配置。\n- 在公共服务中添加依赖\n\n```java\n<dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n```\n\n`如果微服务版本大于2020，则以下形式将需要引入bootstrap的依赖才可以，不导入依赖的方式比较麻烦这里不再赘述`\n\n```java\n <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bootstrap</artifactId>\n            <version>3.1.0</version>\n        </dependency>\n```\n\n- 为了使配置中心的读取在配置文件之前需要创建**bootstrap.properties**文件，springboot中**bootstrap.properties**文件会在**application.yml**之前。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2501289836b7426a87176b9838f4e133.png)\n- 配置配置中心信息\n\n```java\nspring.application.name=guli-coupon\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\n```\n- 给配置中心默认添加一个数据集（Data Id）guli-coupon.properties。默认规则，应用名.properties。\n- 在guli-coupon.properties添加配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/838e45960e804773b1f2def46d96789d.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fd2e36dbcc4d4c519b347172a50ac649.png)\n\n- 动态获取配置\n  - 动态刷新配置注解 **@RefreshScope**\n  - 获取配置值 **@Value(\"${配置项名}\")**\n\n`如果配置中心和配置文件中都配置了，优先使用配置中心的`\n\n## 4.配置中心细节\n\n - 命名空间\n  >配置隔离\n  >- 用来隔离不同环境下的配置（开发、测试、生产）\n  >可以在bootstrap.properties配置指定命名空间\n  >`spring.cloud.nacos.config.namespace=c700d749-47f7-4b10-9116-4fe586a1a2a2`\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/3581a8623fee40ffbed21168d531f6a5.png)\n>- 各个服务间配置隔离\n>每个微服务创建自己的命名空间\n\n\n  `默认：public（保留空间）;默认新增的所有配置都在public空间`\n  \n - 配置集\n >所有的配置的集合\n - 配置集ID\n >Data ID\n - 配置分组\n >`默认所有的配置集都属于DEFAULT_GROUP`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3cb5104cfa4449bcb1b8c17159ef0dda.png)\n>配置分组可以用来区分环境\n>  可以在bootstrap.properties配置指定配置分组\n  >`spring.cloud.nacos.config.group=1111`![在这里插入图片描述](https://img-blog.csdnimg.cn/ea9efc4f1acb4633918b9211ea39bc80.png)\n - 同时加载多个配置集\n在**bootstrap.properties**文件中配置如下代码\n\n```java\nspring.cloud.nacos.config.extension-configs[0].data-id=datasource.yml // Data ID\nspring.cloud.nacos.config.extension-configs[0].group=dev // 配置分组\nspring.cloud.nacos.config.extension-configs[0].refresh=true // 是否动态更新\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/13c5484fbdf84e01bf1b27f515878322.png)\n>微服务中所有的配置都可以交给nacos配置中心管理。配置中心有的优先使用配置中心的\n\n---\n\n# 总结\n本章主要讲了微服务的注册发现和配置中心两个组件。\n\n","tags":["后端","SpringCloud","Nacos","注册中心","配置中心"],"categories":["SpingCloud","Nacos","微服务","后端","组件","项目","谷粒商城"]},{"title":"SpringCloud 学习-Gateway","url":"/2023/06/30/SpringCloud（学习 Gateway）三/","content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\n网关的存在就是让请求动态路由到正确的服务，也可以在网关层做鉴权、限流、日志输出等功能的实现。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b98238e28fbf49bc95586327348b2fb0.png)\n\n\n本次网关采用 **Gateway** 进行，不使用**Zuul**。\n\n---\n\n# 一、三大概念\n## 1. Route（路由）\n>请求通过网关路由到对应的服务中。\n\n - ID：通过不同的ID来区分不同路由\n - URI：请求到服务的地址\n - 断言集合\n - 过滤器集合\n \n`注：只要断言为真视为匹配成功`\n## 2. Predicate（断言）\n在请求经过网关时会根据请求头、参数等判断出是否符合某个路由规则\n>官方提供了12种断言规则\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ec6e3a42ccdc4ee384dc8e09faf74732.png)\n![请添加图片描述](https://img-blog.csdnimg.cn/ca30dddbd8cb46959872a58aff458be4.png)\n\n## 3. Filter（过滤器）\n在路由到指定地址时会经过一系列过滤器，当响应请求时也会经过一系列过滤器。\n>官方提供了37种过滤器规则\n---\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf96131760534903874c9e829ec6a554.png#pic_center)\n\n\n\n# 二、整合Gateway\n`建议不要继承common中的依赖，会有很多依赖问题`\n- 1.引入依赖\n>代码如下：微服务的版本为 **2021.0.5**\n\n```java\n<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n<!--        服务注册/发现-->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n<!--        配置中心-->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n<!--        网关依赖-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n            <version>3.1.5</version>\n        </dependency>\n<!--        bootstrap.properties依赖文件适配高版本springcloud-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bootstrap</artifactId>\n            <version>3.1.0</version>\n        </dependency>\n```\n\n- 2.网关服务注册\n\n在启动类添加注解 \n\n```java\n@EnableDiscoveryClient\n```\n- 3.创建命名空间并创建配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/de099be1f77f4ec4b046684f07a185cc.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/01852957c9fe4133ac4935f7033f43d4.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761dcd651ae247b5ab1119ee4d5f7c9d.png)\n- 4.配置端口等信息（application.properties）\n\n```java\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\nspring.application.name=guli-gateway\nserver.port=88\n```\n- 5连接nacos配置（bootstrap.properties）\n\n```java\nspring.application.name=guli-gateway\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\nspring.cloud.nacos.config.namespace=4b130b5f-4b59-4aed-b1f8-2efdd14ae549\n```\n- 6配置网关相关配置（application.yml）\n>目前测试阶段配置写在本地上，以后通过nacos配置中心配置\n\n```java\nspring:\n  cloud:\n    gateway:\n      routes: #是个集合\n        - id: baidu_route #ID\n          uri: https://www.baidu.com #路由转发地址\n          predicates: #断言 是个集合 可配置多个断言\n            - Query=url,baidu #参数断言 url参数为baidu时 断言通过 逗号之后可以使用正则\n          filters: #过滤器 是个集合 \n            - AddRequestHeader=X-Request-red, blue #添加请求头过滤器\n\n        - id: qq_route\n          uri: https://www.qq.com\n          predicates:\n            - Query=url,qq\n\n```\n>具体配置方法、断言、过滤器配置可以查看[官方文档](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories)\n\n---\n\n# 总结\n\n本文主要讲了网关Gateway的简介以及如何在SpringCloud中整合Gateway、一些配置。\n\n","tags":["后端","SpringCloud","Gateway","网关"],"categories":["SpingCloud","Gateway","微服务","后端","组件","项目","谷粒商城","网关","Gateway"]},{"title":"SpringCloud 学习-微服务简介","url":"/2023/06/30/SpringCloud(学习 微服务简介) 一/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n本文记录学习SpringCloud微服务学习的过程，通过B站视频《谷粒商城》项目进行学习。\n\n**技术架构为：**\n- 后端：\nSpringboot + SpringCloud + Docker \n- 前端：\nVue + Element-ui\n\n\n---\n# 一、什么是微服务？\n## 1.微服务简介\n>将大型单体应用，基于业务进行服务拆分，每个服务独立部署运行，互不影响。\n\n## 2.集群、分布式、节点\n**集群：**\n>多台服务器，实现相同的业务\n**分布式：**\n>将不同业务部署在不同的服务器上\n\n`分布式中的每一个节点，都可以做集群。而集群并不一定就是分布式`\n\n## 3.远程调用\n在分布式系统中，由于不同服务部署在不同的地方，在服务之间需要进行通讯。\n\n>SpringCloud中使用HTTP+JSON的方式进行远程调用，可以通过不同语言不同平台进行传输，兼容性高。\n\n## 4.负载均衡\n在服务集群中，为了使集群中每个服务器充分利用，采用负载均衡的方式调用独立服务器。\n\n常用负载均衡算法：\n>轮询：从服务器健康池中选择第一个服务器分配给第一个请求，然后按顺序依次向后选择，到最后以后从新开始循环。\n\n>最小连接：优先选择连接数最少的服务器，在会话时间较长优先选择该方式。\n\n>散列：相同IP地址连接相同的服务器，保证特定用户能连接到相同的服务器。如果应用需要处理状态而要求用户连接到相同的服务器，可以采用该方式。\n\n## 5.服务注册/发现、注册中心\n>由于有很多的服务，避免调用到不可用（不在线）的服务，为了感知每个服务的状态，在服务上线时，会在注册中心注册这个服务。在调用某个业务服务时会在注册中心查询相关服务进行调用。\n\n## 6.配置中心\n>每个业务都有大量的配置，而这个业务又会放在多个服务器形成集群，修改配置后需要在大量服务器上修改配置，这样及其不方便。因此才会有配置中心用来给服务进行管理服务配置。\n\n## 7.服务熔断、服务降级\n\n - 服务熔断\n >设置服务的超时，当被调用的服务经常失败达到某个阈值，启用断路保护机制，之后的请求不再去调用这个服务，本地直接返回默认数据。\n - 服务降级\n>在运维期间，当系统处于高压状态，资源紧张，让非核心业务进行降级运行，被降级的业务将不处理或者简单处理（抛异常、返回NULL、调用Mock数据、调用Fallback处理逻辑）\n\n## 8.API网关\n对所有请求进行拦截并处理，保证服务的正常运行，其中处理包括：负载均衡、服务自动熔断、灰度发布、统一认证、限流流控、日志统计等公共功能，解决API管理困难。\n\n![](https://img-blog.csdnimg.cn/2ae8b9442529420894fff1ccb3a8a031.png)\n\n# 二、项目架构\n\n - 微服务架构图\n![项目架构图](https://img-blog.csdnimg.cn/c07c47e2f262426d9a896148367b60c6.png)\n ---\n - 微服务划分图\n\n![微服务划分图](https://img-blog.csdnimg.cn/cd36bb8e4f624796930396c10f01e66a.png)\n\n\n# 三、环境配置\n\n配置开发环境，在虚拟机中进行，虚拟机采用**centos9**这个版本，在虚拟机中安装**docker**，在docker中安装mysql等软件。\n\n - 安装虚拟机\n >我在VM中安装虚拟机，具体安装可网上查询，版本选择centos9这个版本\n \n - 安装Docker-CE(社区版)\n >- Docker官网给了各种虚拟机的安装流程，我安装的是CentOS版本的\n >[CentOS安装流程](https://docs.docker.com/engine/install/centos/)\n >- 启动Docker\n >sudo systemctl start docker（这里sudo是以管理员身份启动，可以使用“su root”命令进入管理员模式）\n >- 设置开机自启\n >sudo systemctl enable docker\n >- 配置镜像加速\n >sudo mkdir -p /etc/docker\n>sudo tee /etc/docker/daemon.json <<-'EOF' { \"registry-mirrors\": [\"https://82m9ar63.mirror.aliyuncs.com\"]\n}\nEOF\n>sudo systemctl daemon-reload\n>sudo systemctl restart docker\n - 在Docker安装mysql\n>- docker pull mysql:5.7\n>- 创建实例并启动\n>docker run -p 3306:3306 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n-v /mydata/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-d mysql:5.7\n参数说明\n-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口\n-v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机\n-v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机\n-v /mydata/mysql/data:/var/lib/mysql/：将配置文件夹挂载到主机\n-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码\n>- 配置自启动\n>docker update mysql --restart=always\n>- 连接mysql \n>查看虚拟机ip使用命令 ：ifconfig -a\n>然后我这里使用navicat连接数据库进行可视化\n\n - 在Docker安装redis\n>- docker pull redi\n>- 创建实例并建立配置文件并启动实例\n>mkdir -p /mydata/redis/conf\n>touch /mydata/redis/conf/redis.conf\n>docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\\n-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n-d redis redis-server /etc/redis/redis.conf\n>- 持久化储存（修改配置文件）\n>docker exec -it redis redis-cli\n>输入“i”进入插入模式\n>appendonly yes（开启持久化）\n>\"ESC\"输入\":wq\"保存退出\n>exit (退出redis)\n>- redis可视化\n>这里我是用IDEA的插件 \"redis\" 可以直接可视化redis\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/ec00eee6ba714276ad58f52cd9a99c18.png)\n\n\n - 新建项目\n>JDK使用1.8，springboot使用2.7.8\n>后台管理使用码云开源项目“[renren-fast](https://gitee.com/renrenio/renren-fast)\"\n>前台使用”[renren-fast-vue](https://gitee.com/renrenio/renren-fast-vue)“\n>后台项目中给了sql的文件\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/9bf6fb953e344dff97b1debdb40c5cef.png)\n - 微服务划分与创建\n >根据服务划分图创建对应服务，其中common为全局服务，储存公共bean和依赖等\n >![在这里插入图片描述](https://img-blog.csdnimg.cn/9ee9df2bc0ff476e85b52572593d51c3.png)\n\n - 利用码云开源项目\"[renren-generator](https://gitee.com/renrenio/renren-generator)\"逆向出每个服务中表的CRUD功能\n >- 在配置文件中配置数据库信息\n >![在这里插入图片描述](https://img-blog.csdnimg.cn/6e5af0ab23e643eab38f3fa4c2fd909c.png)\n >![在这里插入图片描述](https://img-blog.csdnimg.cn/681491be5b4741dea2d26db8fa6a4d43.png)\n\n >- 运行打开web页面后可选择对应表进行生成\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dc099d93e5974d92b40476e8c39a9a15.png)\n>-  将生成的代码替换完成代码生成\n>- 在配置文件配置数据源\n>`spring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://192.168.8.124:3306/guli-pms\n    driver-class-name: com.mysql.jdbc.Driver`\n    >- 配置mybatis-plus(关联xml文件和设置主键自增)\n>`mybatis-plus:\n  mapper-locations: classpath:/mapper/**/*.xml\n  global-config:\n    db-config:\n      id-type: auto`\n      >- 主类扫描实体类\n      >添加注解@MapperScan\n      >@MapperScan(\"com/smz/guli/product/dao\")\n      >- 启动服务\n\n\n","tags":["后端","SpringCloud","Docker"],"categories":["SpingCloud","简介","微服务","后端","Docker","项目","谷粒商城"]},{"title":"用两个栈实现队列","url":"/2023/06/30/用两个栈实现队列/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n\n---\n\n# 例子\n\n示例 1：\n输入：\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n\n示例 2：\n输入：\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n\n\n---\n# 提示：\n\n1 <= values <= 10000\n最多会对 appendTail、deleteHead 进行 10000 次调用\n\n---\n\n\n# 代码实现：\n## 1.双栈元素翻转：\n>模拟示例二\n```java\n /*\n       题目描述：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n       解题思路：利用栈的特性，添加直接在A栈尾部添加，删除时将A的元素依次出栈并入栈到B中，B出栈尾元素后，将剩余元素依次出栈并入栈到A，此时完成删除。\n     */\n    public static void main(String[] args) {\n        CQueue obj=new CQueue();\n        obj.deleteHead();\n        obj.appendTail(5);\n        obj.appendTail(2);\n        obj.deleteHead();\n        obj.deleteHead();\n    }\n     static class CQueue{\n        Stack<Integer>A,B;\n        public CQueue(){\n            A=new Stack<>();\n            B=new Stack<>();\n        }\n\n        public  void appendTail(int value){//直接入栈\n            System.out.println(\"添加的值为\"+value);\n            A.push(value);\n            System.out.println(\"添加后：\"+A.toString());\n        }\n        public  int deleteHead(){\n            if (A.isEmpty()){//如果为空则返回-1\n                System.out.println(\"队列中没有值可以删\"+A);\n                return -1;\n            }\n            System.out.println(\"删除前:\"+A);\n           while (!A.isEmpty()){//出栈所有元素并入栈到B\n               B.push(A.pop());\n           }\n           int value=B.pop();//删除的元素\n           while (!B.isEmpty()){//重新将B中剩于元素入栈到A\n               A.push(B.pop());\n           }\n            System.out.println(\"删除后：\"+A.toString());\n            System.out.println(\"本次删除的是：\"+value);\n            return value;\n        }\n    \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/53fd16a174624d149674c39f7eba557a.png)\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof)\n","tags":["算法","简单","offer","力扣","栈","队列"],"categories":["力扣","栈"]},{"title":"桶排序及其应用","url":"/2023/06/30/桶排及稳定性汇总/","content":"\n\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n桶排序及其应用\n\n---\n\n\n\n# 一、桶排序流程\n\n相比其它排序，桶排序不基于比较的排序，根据数据状况来排序。应用范围不是很广。\n##  （1）计数排序\n定义一个数组，用来记录每个数出现的次数，数组下标就是值，然后根据排序规则，分别输出每种数的个数。最终就得到有序数组。\n\n>代码如下：\n\n```java\npublic class countSort {\n    public static void main(String[] args) {\n        int []arr={21,1,8,15,15,15,1,1,2,2,3,4,4,4,4};\n        System.out.println(\"排序前:\"+Arrays.toString(arr));\n        countSort(arr);\n        System.out.println(\"排序后:\"+Arrays.toString(arr));\n    }\n    public static void countSort(int[]arr){\n        int max=maxNum(arr);// 最大数\n        int[]help=new int[max+1];// 创建出最大数长度的辅助数组\n        for (int i=0;i<arr.length;i++){\n            help[arr[i]]+=1;// 计数\n        }\n        System.out.println(\"桶子：\"+Arrays.toString(help));\n        int temp=0;\n        for (int j=0;j<help.length;j++){// 出桶\n            if (help[j]!=0){\n                for (int d=0;d<help[j];d++){\n                    arr[temp++]=j;\n                }\n            }\n        }\n    }\n    // 找最大数\n    public static int maxNum(int []arr){\n        int max=0;\n        for (int i:arr){\n            max=Math.max(max,i);\n        }\n        return max;\n    }\n}\n\n\n```\n\n>时间复杂度：O（N）\n>结果如下：\n![!\\[在这里插入图片描述\\](https://img-blog.csdnimg.cn/2ebd86fbfe2e4e97b0bcda10696f326d.png](https://img-blog.csdnimg.cn/de45363093ec4a3c908d058a94d52b8b.png)\n\n\n## （2）基数排序\n准备十个桶，分别对应数字0~9，桶就是个容器，可以是队列，数组，栈等...,最开始将所有数按最多位的数以0补齐位数（【34，789，444】补全为：【034，789，444】），从个位数将数放入对应桶中（034就放入4号桶，789就放入9号桶），然后依次从0 ~ 9号桶的顺序取出一个桶里的遵循先进先出。然后从十位重复，最后到最高位，出桶后就得到有序数组。（优先级是从最高位开始依次递减）。\n>代码如下：\n\n```java\npublic class radixSort {\n    public static void main(String[] args) {\n        int []arr={63,21,80,91,23,42,444,382,45};\n        System.out.println(\"排序前:\"+ Arrays.toString(arr));\n        radixSort(arr);\n        System.out.println(\"排序后:\"+Arrays.toString(arr));\n    }\n    public static void radixSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        radixSort(arr,0,arr.length-1,maxbits(arr));\n    }\n    public static void radixSort(int []arr,int L,int R,int maxBit){\n        final int radix=10;// 10个桶子\n        int i=0,j=0;// j=>当前数的第几位\n        int []bucket=new int[R-L+1];// 辅助数组\n        for (int d=1;d<=maxBit;d++){ // 有多少位就进多少次\n            // 桶子共有maxBit个\n            // 桶子的计数与流程有差别，桶子计数的为小于等于当前下标的个数之和\n            // （第6个桶子是【0，1，2，3，4，5，6，7】的数字的总和）\n            int []count =new int [radix];\n            for (i=L;i<=R;i++){// 取出当前位的数字 入桶\n                j=getDigit(arr[i],d);\n                count[j]++;\n            }\n            for (i=1;i<radix;i++){// 桶子的累加和\n                count[i]=count[i]+count[i-1];\n            }\n            for (i=R;i>=L;i--){// 从右到左遍历，取出对应位 桶中对应数--，摆放位置 出桶\n                j=getDigit(arr[i],d);\n                bucket[count[j]-1]=arr[i];\n                count[j]--;\n            }\n            for (i=L,j=0;i<=R;i++,j++){// 将辅助数中的值给arr准备下一次进桶出桶\n                arr[i]=bucket[j];\n            }\n        }\n    }\n    // 取出一个数中的第d位数字\n    public static int getDigit(int x,int d){\n        return ((x/(int)(Math.pow(10,d-1)))%10);\n    }\n    // 找一个数组内最多有多少位\n    public static int maxbits(int []arr){\n        int max=Integer.MIN_VALUE;\n        for (int j : arr) {// 找出最大值\n            max = Math.max(max, j);\n        }\n        int res=0;\n        while (max!=0){// 循环计位数\n            res++;\n            max/=10;\n        }\n        return res;\n    }\n}\n```\n\n>结果如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/564462c2843a44c7b67e7edd0014bcc3.png)\n\n\n# 二、排序算法的稳定性及其汇总\n## 稳定性\n  ****同样的个体间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。****\n\n 1. 不具备稳定性的排序：\n- 选择排序\n- 快速排序\n- 堆排序\n2. 具备稳定性的排序：\n- 冒泡排序\n- 插入排序\n- 归并排序\n- 一切桶排序思想下的排序\n\n目前按没有找到时间复杂度O(N*logN),空间复杂度O(1)又稳定的排序算法。\n\n|  | 时间复杂度 |额外空间复杂度|稳定性|\n|--|--|--|--|\n| 选择 | O(N^2) |O(1)|×|\n| 冒泡 | O(N^2) |O(1)|√|\n| 插入 | O(N^2) |O(1)|√|\n|归并  | O(N*logN) |O(N)|√|\n| 快排（随机） | O(N*logN) |O(logN)|×|\n| 堆 |O(N*logN)  |O(1)|×|\n\n\n## 坑\n\n - 归并排序的额外空间复杂度可以变成O（1）但会丧失稳定性，而且非常难（归并排序，内部缓存法）\n - 原地归并排序，让时间复杂度变成O（N^2）\n - 快速排序可以做到稳定，但空间复杂度会变为O(N)，而且非常难\n - 目前没有找到时间复杂度O(N*logN),额外空间按复杂度O(1)，又稳定的排序。\n - 奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变。\n\n## 工程上堆排序的改进\n- 充分利用O(N*logN)和O（N^2）排序各自优势\n在快排中，当样本容量小于60时使用插入排序更快（综合排序）\n\n\n- 稳定性考虑\n在系统中使用排序，基础类型，系统会使用快排进行排序；而遇到非基础类型排序时，会使用归并保持稳定性。\n# 总结\n以上就是桶排序的所有内容。\n","tags":["算法","数据结构","排序算法","桶排序"],"categories":["算法","数据结构和算法"]},{"title":"旋转数组中的最小数字","url":"/2023/06/30/旋转数组的最小数字/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n\n给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  \n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n\n---\n\n# 例子\n\n示例 1：\n输入：numbers = [3,4,5,1,2]\n输出：1\n\n示例 2：\n输入：numbers = [2,2,2,0,1]\n输出：0\n\n\n---\n# 提示：\n\n- n == numbers.length\n- 1 <= n <= 5000\n- -5000 <= numbers[i] <= 5000\n- numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n\n\n\n---\n\n\n# 代码实现：\n>利用二分的思想，因为经过循环后，在最小值两侧都为单调增的，但是最小值左侧的值永远比最小值右侧的值大于或等于，利用中点值和右顶点值作比较，有如下三种情况：\n-   如果中点值比右端点小，说明最小值在中点左侧；\n- 如果中点值比有顶点大，说明最小值在中点右侧；如果相等，不能判断右顶点是否为最小值，但是可以确定\n- 最小值在这个区间之内，将右顶点往前挪，再判断。最坏情况是全部数都一样。\n## 1.二分：\n>时间复杂度：O（logN）  空间复杂度：O（1）；\n```java\npublic static int minArray(int[] numbers) {\n            int left=0;\n            int right=numbers.length-1;\n            while (left<right){\n                int mid=left+((right-left)>>1);\n                if (numbers[mid]<numbers[right]){\n                    right=mid;\n                } else if (numbers[mid]>numbers[right]) {\n                    left=mid+1;\n                }else right -=1;\n            }\n            return numbers[left];\n        }\n```\n\n## 2.运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/24665d4618934355bd01d9b1689960bc.png)\n\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof)\n","tags":["算法","数组","二分","简单","offer","力扣"],"categories":["力扣","数组","二分"]},{"title":"数组中重复的数字","url":"/2023/06/30/数组中重复的数字/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n限制：2 <= n <= 100000\n\n---\n\n# 例子\n\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n---\n# 提示：\n\n- 数组中的数都不超过数组长度-1\n\n\n---\n\n\n# 代码实现：\n>    用打标签的方式记录是不是重复的，先创建一个标签数组，从0开始到n-1，再遍历数组。出现过一次就在对应标签标记，发现标签元素中某次出现标记过的返回这个数\n\n   >利用哈希表记录值，每次加入前查找是否存在，不能再则加入，存在则返回\n\n>原地交换，某个数如果对应它自己的位置，则跳过，否则将查看该索引下的值是否与当前值相等，相等就返回，不等则交换\n## 1.标签：\n```java\n public static int findRepeatNumber(int[] nums) {\n        if (nums.length==2)return -1;// 如果数组长度位2直接返回-1\n        int[]label=new int[nums.length];// 标签数组\n        for (int num : nums) {\n            if (label[num] == 0) label[num] = 1;// 标签为0 使其变为1\n            else return num;// 不为1说明重复出现\n        }\n        return -1;// 不存在重复的数\n    }\n```\n## 2.原地交换：\n```java\npublic static int findRepeatNumber2(int[] nums) {\n        if (nums.length==2)return -1;// 如果数组长度位2直接返回-1\n        int i=0;\n        while (i<nums.length){\n            if (nums[i]==i){\n                i++;// 只在与索引值相等才往后，避免某些元素遍历不到\n                continue;\n            }\n            if (nums[nums[i]]==nums[i]) return nums[i];\n            else {// 交换位置\n                int temp=nums[i];\n                nums[i]=nums[temp];\n                nums[temp]=temp;\n            }\n        }\n        return -1;// 不存在重复的数\n    }\n\n```\n\n## 3.运行结果\n>两次错误是因为用异或运算交换位置，然后最后一个测试点过不去\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ac93e8b90c4380a412ec555d1b99f3.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)\n","tags":["数组","简单","offer","力扣"],"categories":["力扣","数组"]},{"title":"归并排序，快排变形应用","url":"/2023/06/30/归并排序，快排变形应用/","content":"\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\nO(NlogN)的排序\n\n---\n\n\n\n# 一、数组中点防溢出\n在取一个数组的中点时，传统写法为：\n\n- **mid=(min+max)/2**;  这样会发生（mn+max）溢出。\n- **min+(max-min)/2**; 可以改成这样。\n- **mn+（(max-min)>>1）**;也可以这样。\n\n\n\n\n\n# 二、master公式\n## 1.master公式的使用\n**T（N）=a*T（N/b）+O(N^d)**\n其中T（N）表示母问题规模，a表示子问题调用次数，T（N/b）表示子问题规模，O（N^d）表示其它规模。\n`必须在子问题规模一样的情况下`\n时间复杂度\n- logb^a<d  --->O(N ^ d)\n- logb^a>d   ---> O(N ^logb ^a)\n- logb^a==d  ---> O(N ^d *logN)\n  \n \n\n# 归并排序\n## 1.流程\n将数组沿中点分成两部分,分别将左右两部分先排序，然后申请辅助空间，依次比较 左右两边的数，根据规则将较大或较小数copy到辅助空间，将这一侧往后移一位和另一侧不移动的数比较，以此类推，最终一边越界将另一边剩下的直接copy进辅助空间，就得到了有序数组。\n\n>T（N）=2T（N/2）+O（N）\n>归并排序的时间复杂度为：O（NlogN）\n>额外空间复杂度为：O（N）\n> 代码如下\n\n```java\npublic class mergeSort {\n    public static void process(int []arr,int L,int R){ // 递归\n        if (L==R){\n            return;\n        }\n        int mid=L+((R-L)>>1);// 取中点\n        // 两次递归\n        process(arr,L,mid);\n        process(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n    public static void merge(int []arr,int L,int M,int R){// 比较\n        int[] help=new int[R-L+1];// 辅助空间\n        int i=0;\n        int p1=L; // 左指针\n        int p2=M+1; // 右指针\n        // O（N）\n        while (p1 <= M && p2 <= R){// 比较\n           help[i++]= arr[p1]<=arr[p2]?arr[p1++]: arr[p2++];\n        }\n        // 最终\n        while (p1<=M){\n            help[i++]=arr[p1++];\n        }\n        while (p2<=R){\n            help[i++]=arr[p2++];\n        }\n        // O（N）\n        for (int j=0;j<help.length;j++){\n            arr[L+j]=help[j];\n        }\n    }\n}\n```\n---\n## 2.归并排序拓展\n### （1）求小和问题\n>描述：在一个数组中，每一个数左边比当前的数大累加起来，叫做这个数组的小和。求一个数组的小和。\n例如：\n[1,3,4,2,5],1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、4、2；所以小和为1+1+3+1+1+3+4+2=16。\n\n>思路：转换问题，将求左边比当前数小改为求右边比当前数大的个数，再与该数相乘，最后相加得到小和。\n>例如：\n>1右边比1大的数有4个，就是1*4；3右边比3大的有2个，就是3*2；4右边比4大的有1个，就是4*1；2右边比2大的有1个，就是2*1；5右边没有比5大的数；所以小和为1*4+3*2+4*1+2*1=16。\n\n>利用归并找到小和，在左右两边都排序后，只要左边比右边的小，就要进行小和的累加，当相同时，先复制右边的，这样能更快找完但个数的小和。\n\n```java\npublic class smallSumProblem {\n    public static int process(int []arr, int L, int R){ // 递归\n        if (L==R){\n            return 0;\n        }\n        int mid=L+((R-L)>>1);\n        return process(arr,L,mid) +process(arr,mid+1,R)+merge(arr,L,mid,R); //总小和\n    }\n    public static int merge(int []arr,int L,int M,int R){// 比较\n        int[] help=new int[R-L+1];// 辅助空间\n        int i=0;\n        int p1=L; // 左指针\n        int p2=M+1; // 右指针\n        int res =0;\n        while (p1 <= M && p2 <= R){// 比较 求小和\n            res+=arr[p1]<arr[p2]?(R-p2+1)*arr[p1]:0; // 左边小于右边时，计算小和数\n            help[i++]= arr[p1]<arr[p2]?arr[p1++]: arr[p2++];// 左右两边相等时先拷贝右边的\n        }\n        // 最终\n        while (p1<=M){\n            help[i++]=arr[p1++];\n        }\n        while (p2<=R){\n            help[i++]=arr[p2++];\n        }\n        for (int j=0;j<help.length;j++){\n            arr[L+j]=help[j];\n        }\n        return res;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/4ce416eaf43949438852cdefc3d76419.png)\n\n### （2）逆序对问题\n>描述：在一个数组中，左边的数如果比右边大，则这两个数构成一个逆序对，请打印所有逆序对。\n---\n\n```java\npublic class reversePairProblem {\n    public static void main(String[] args) {\n        int[] arr = {5, 3, 4, 2, 1};\n        process(arr, 0, 4);\n    }\n\n    public static void process(int[] arr, int L, int R) { // 递归\n        if (L == R) {\n            return;\n        }\n        int mid = L + ((R - L) >> 1);\n         process(arr, L, mid);\n         process(arr, mid + 1, R);\n         merge(arr,L,mid,R);\n    }\n    public static void merge(int[] arr, int L, int M, int R) {// 比较\n        int p1 = L; // 左指针\n        int p2 = M + 1; // 右指针\n        while (p1 <= M && p2 <= R) {// 比较\n            if (arr[p1]>arr[p2]){\n                System.out.println(\"[\"+arr[p1]+\",\"+arr[p2]+\"]\");\n                p1++;\n            }else {\n                p2++;\n            }\n\n        }\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/59e2a6119b6b48c69281d8724ff9d01e.png)\n\n## 3.荷兰国旗问题\n### （1）荷兰国旗问题一\n>描述：\n>给定一个数组arr，和一个数num，请把小于等于num的数放在数组左边，大于num的数放在数组的右边，要求额外空间复杂度O(1)，时间复杂度O（N）。\n\n>思路：\n>他并不要求有序，值啊要将小于等于num的数放左边，大于num的数放右边就可以。先规定一个小于等于num的区域area，area起始是arr第一个数的左边，让指针i指向arr第一个数，让arr[i]与num比较，如果比num小或等，就让i+1，让area往右边扩一位，将arr[i]包含其中；如果arr[i]大于num时，i+1,area不变，接着比较下一位，知道有一位比num小时，交换这一位和area下一位数的位置，再将area往下扩一位，以此类推。\n\n```java\npublic class dutchFlagQuestionOne {\n    public static void main(String[] args) {\n        int []arr={3,8,5,3,8,1,2,9,7};\n        int num=5;\n        hollandOne(arr,num);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void hollandOne(int []arr,int num){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        partition(arr,num,0, arr.length-1);\n    }\n    public static void partition(int []arr,int num,int L,int R){\n        int less=L-1;\n        int more=R+1;\n        while (L<more){\n            if (arr[L]<=num){\n                swap(arr,++less,L++);\n            }else {\n                swap(arr,--more,L);\n            }\n        }\n    }\n    //交换方法\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/a75e03cdeb3741b7a111f22f9db649dc.png)\n\n### （2）荷兰国旗问题二\n>描述：\n给定一个数组arr，和一个数num，请把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组的右边，要求额外空间复杂度O(1)，时间复杂度O（N）。\n\n> 思路:\n> 和上一个差不多，只不过多了一个等于的区域\n>  - [i]<num,[i]和小于区下一位交换，小于区右扩一位，i++\n>  -   [i]=num，i++\n>  -  [i]>num,[i]和大于区前一位交换，大于区左扩一位，i不变\n\n```java\npublic class dutchFlagQuestionOne {\n    public static void main(String[] args) {\n        int []arr={3,8,5,3,8,1,2,9,7};\n        int num=5;\n        hollandOne(arr,num);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void hollandOne(int []arr,int num){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        partition(arr,num,0, arr.length-1);\n    }\n    public static void partition(int []arr,int num,int L,int R){\n        int less=L-1;\n        int more=R+1;\n        while (L<more){\n            if (arr[L]<=num){\n                swap(arr,++less,L++);\n            }else {\n                swap(arr,--more,L);\n            }\n        }\n    }\n    //交换方法\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/1e965cf11de343cb8e584ed7a2bdc9c5.png)\n\n## 4.快排\n### （1）快排1（荷兰国旗问题一的递归）\n>将最后一个数作为划分数进行判断，先判断第一个数与划分数的大小关系，如果小于等于划分数，与小于区后一位交换，小于区域右扩一位；如果大于划分数，与大于区前一位数交换，大于区左扩一位，返回小于区与大于区的交界值，进行递归，最终必定能得到一个有序数组。\n>时间复杂度为：O（N^2）\n>空间复杂度为：O（logN）\n\n```java\npublic class quickRowOne {\n    public static void main(String[] args) {\n        int []arr={1,9,4,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        quickSort(arr,0,arr.length-1);\n    }\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            int p=partition(arr,L,R);\n            quickSort(arr,0,p-1);\n            quickSort(arr,p,R);\n        }\n    }\n    public static int partition(int []arr,int L,int R){\n        int less=L-1; // 小于等于区右边界\n        int more=R;// 大于区左边界\n       while (L<more){\n           if (arr[L]<=arr[R]){\n               swap(arr,++less,L++);\n           }else swap(arr,--more,L);\n       }\n        swap(arr,more,R);\n       return more;\n    }\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/e3651b96fdc34e3ba46580ab7af5f008.png)\n\n### （2）快排2（荷兰国旗问题二的递归）\n>在一的基础上添加了=的区域，也就是说=区域的那部分在后面就不用递归排序了。\n>时间复杂度为：O（N^2）\n>空间复杂度为：O（logN）\n```java\npublic class quicksortTwo {\n    public static void main(String[] args) {\n        int []arr={1,9,4,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        quickSort(arr,0,arr.length-1);\n    }\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            int p[]=partition(arr,L,R);\n            quickSort(arr,0,p[0]-1);\n            quickSort(arr,p[1]+1,R);\n        }\n    }\n    public static int[] partition(int []arr,int L,int R){\n        int less=L-1; // 小于等于区右边界\n        int more=R;// 大于区左边界\n        while (L<more){\n            if (arr[L]<arr[R]){\n                swap(arr,++less,L++);\n            }else if (arr[L]>arr[R]){\n                swap(arr,--more,L);\n            }else L++;\n        }\n        swap(arr,more,R);\n        return new int[]{less+1,more};\n    }\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/eeff751387c1457993dbdbba754f4e50.png)\n\n### （3）快排3（随机选取数来划分）\n>选取划分数时，在列表中随机选取一个数，并人为的将其放到列表的最后一位。\n>时间复杂度为：O（N*logN）\n>空间复杂度为：O（logN）\n```java\npublic class quickRowThree {\n    public static void main(String[] args) {\n        int []arr={1,9,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int[]arr){\n       if (arr==null||arr.length<2){\n           return;\n       }\n       quickSort(arr,0,arr.length-1);\n    }\n\n    // 递归排序\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            swap(arr,L+(int)(Math.random()*(R-L+1)),R); // 随机范围数，手动交换到最后一位\n            int[]p=partition(arr,L,R);// 用来确定等于区域边界\n            quickSort(arr,L,p[0]-1);// 小于区域\n            quickSort(arr,p[1]+1,R);// 大于区域\n        }\n    }\n\n    public static int[] partition(int[]arr, int L, int R){\n        int less=L-1; // 小于取右边界\n        int more=R;// 大于区左边界\n        while (L<more){\n            // [i]<num,[i]和小于区下一位交换，小于区右扩一位，i++\n            // [i]=num，i++\n            // [i]>num,[i]和大于区前一位交换，大于区左扩一位，i不变\n            if (arr[L]<arr[R]){\n                swap(arr,++less,L++);\n            }else if (arr[L]>arr[R]){\n                swap(arr,--more,L);\n            }else {\n                L++;\n            }\n        }\n        swap(arr,more,R);\n        return new int[]{less+1,more};\n    }\n    public static void swap(int[]arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/0f4ca14d34364059bafc3a33d8e0af19.png)\n\n---\n# 总结\n\n上文主要讲了master公式的使用，归并排序以及快排逻辑，以及递归解决问题。\n","tags":["算法","数据结构","排序算法","归并排序","快排排序"],"categories":["算法","数据结构和算法"]},{"title":"左旋字符串","url":"/2023/06/30/左旋转字符串/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。\n\n限制：1 <= k < s.length <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入: s = \"abcdefg\", k = 2\n输出: \"cdefgab\"\n\n示例 2：\n输入: s = \"lrloseumgh\", k = 6\n输出: \"umghlrlose\"\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>    使用片段拼接的方式，按照需要反转的的地方一分为二，再将两个片段重新拼接就可以了\n\n>    使用遍历拼接字符串的方式，从第n位开始遍历将字符拼接起来，再从头遍历拼接\n## 1.字符串片段拼接：\n>时间复杂度O（n）,空间复杂度O（n）\n>substrin（）方法是将字符串复制一遍，所以时间复杂度位O（n）\n```java\n public static String reverseLeftWords(String s, int n) {\n        //substring:获取字符串某一段\n        return s.substring(n)+s.substring(0,n);\n    }\n```\n## 2.字符串循环遍历拼接：\n>时间复杂度O（n）,空间复杂度O（n）\n\n```java\n public static String reverseLeftWords2(String s, int n) {\n        StringBuilder sb=new StringBuilder();//拼接字符串容器\n        for (int i=n;i<s.length()+n;i++){\n            sb.append(s.charAt(i%s.length())); // 利用取余来减少一个for循环\n        }\n        return sb.toString();\n    }\n\n```\n\n## 3.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ecd863b94667487fa2118de526dcf8bd.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n","tags":["算法","简单","offer","力扣","字符串"],"categories":["力扣","字符串"]},{"title":"奇偶排序（左边为奇数右边为偶数）","url":"/2023/06/30/奇偶排序（左边为奇数右边为偶数）/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数;并且都要分别有序。\n\n第一行输入整数n。(1<=n<=1000)表示数组大小 第二行输入n个整数a.(1<=n<=100)\n\n---\n\n# 例子\n\n示例 1：\n\n输入：\n6\n3 34 67 89 90 58\n输出：3 67 89 34 90 58\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n## 1.双指针：\n```java\npublic static ArrayList<Integer> solution(int n, ArrayList<Integer> arr){\n        ArrayList<Integer> result = new ArrayList<>();\n        ArrayList<Integer> result2 = new ArrayList<>();\n        int left=0;\n        int right=0;\n        int L=0;\n        int R=n-1;\n        while (L <= R) {// 双指针查找，左指针位偶就去 右指针找奇数，然后交换位置，最后左右指针相遇结束，就得到了左边位奇数，右边为偶数的数组，但是不是有序的的。\n            if (arr.get(L) % 2 == 0) {\n                left = arr.get(L);\n\n                while (true) {\n                    if (L > R) {\n                        break;\n                    }\n                    if (arr.get(R) % 2 != 0) {\n                        right = arr.get(R);\n                        arr.set(L++, right);\n                        arr.set(R--, left);\n\n                        break;\n                    } else {\n                        R--;\n                    }\n                }\n            } else {\n                L++;\n            }\n        }\n        //有序处理\n        for(Integer item:arr){\n            if(item%2==0){\n                break;\n            }\n            result.add(item);\n        }\n        for(int i=n-1;;i--){\n            if(arr.get(i)%2!=0){\n                break;\n            }\n            result2.add(arr.get(i));\n        }\n        arr.clear();\n        Collections.sort(result);\n        Collections.sort(result2);\n        arr.addAll(result);\n        arr.addAll(result2);\n        return arr;\n    }\n```\n---\n## 运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/93bd12f4b9314ecfb304b098108cc3ab.png#pic_center)\n\n---\n题目来源：CSDN\n链接: [CSDN题目](https://edu.csdn.net/skill/program/28795?practiceId=6842155)\n","tags":["算法","数组","简单","offer","力扣"],"categories":["力扣","排序"]},{"title":"复杂链表的复制","url":"/2023/06/30/复杂链表的复制/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n\n\n\n---\n\n# 例子\n\n\n**示例 1：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4f44c4a8168c442fa1d59f911a4446c7.png)\n\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n\n\n**示例 2：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/466e20e591804d579e0d3fe6e3292c08.png)\n\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n\n\n\n**示例 3：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a580fd515b854ae3af2b5d047ae5d483.png)\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n\n\n**示例 4：**\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n\n---\n# 提示：\n\n提示：\n\n- -10000 <= Node.val <= 10000\n- Node.random 为空（null）或指向链表中的节点。\n- 节点数目不超过 1000 。\n\n---\n\n\n# 代码实现：\n>对于简单链表的深拷贝，按照顺序遍历一遍就可以，该题目中存在随机指针，在拷贝时，你不能确定他所指向的结点是否已经创建了。\n\n >所以可以尝试用拆分停留的方式，就是在原链表每个结点后面添加一个和原节点一样的结点，用复制结点的随机指针指向原结点的随机指针的后一个，最后再把两个链表拆开就得到了结果\n## 1.拆分停留：\n>时间复杂度O(N)，空间复杂度O(1)\n```java\npublic Node copyRandomList(Node head) {\n        if (head==null) return null;\n       for (Node node=head;node!=null;node=node.next.next){// 插入每个结点的复制版\n           Node nodeCopy=new Node(node.val);// 创建结点\n           nodeCopy.next=node.next;// 插入\n           node.next=nodeCopy;\n       }\n       for (Node node=head;node!=null;node=node.next.next){// 将复制的随机结点指向原节点指向的下一个结点\n           node.next.random=node.random!=null?node.random.next:null;\n       }\n       Node rt=head.next;// 记录头结点\n       for (Node node=head;node!=null;node=node.next){// 将复制链表和原链表分开\n           Node nodeNew = node.next;\n           node.next=node.next.next;\n           nodeNew.next=node.next!=null?nodeNew.next.next:null;\n       }\n       return rt;\n    }\n```\n---\n\n## 运行截图\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/275d67b0949649c39af91a4bdfe031cc.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n","tags":["算法","数组","offer","力扣","链表","中等"],"categories":["力扣","链表"]},{"title":"复杂度和简单排序算法及位运算的实际问题","url":"/2023/06/30/复杂度和简单排序算法及位运算的实际问题/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n数据结构和算法是每个程序员必不可少的一部分，算法培养思维逻辑，而数据结构提供实现思维的载体。\n# 复杂度和简单排序算法\n\n## 复杂度\n### 1.时间复杂度\n是对一个算法流程中发生的常数操作的总结，在总结出的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分为f（N），那么时间复杂度为O（f(N)。\n\n### 2.空间复杂度\n是对一个算法在运行过程中临时占用存储空间大小的一个量度。在常量空间中空间复杂度为S（n）=O(1)，在线新空间和递归空间中空间复杂度都为 S（n）=O(n),在二维空间中空间复杂度为S（n）=O(n*m)。\n## 简单排序算法\n### 1.选择排序算法\n从第一个数开始在其中找到最小的数与其交换位置，一直到最后交换完成，就完成了排序\n```java\n//选择排序\n    public static void selectionSort(int[] arr){\n        //长度不足2的都直接返回\n        if (arr==null||arr.length<2){\n            return;\n        }\n        for (int i=0;i<arr.length-1;i++){\n            int minIndex=i;\n            //找到最小值的下标和值\n            for (int j=i+1;j<arr.length;j++){\n                minIndex=arr[j]<arr[minIndex]?j:minIndex;\n            }\n            //交换位置\n            swap(arr,i,minIndex);\n        }\n    }\n    // 交换两个数的位置\n    public static void swap(int[] arr,int i,int j){\n        int tmp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=tmp;\n    }\n```\n\n### 2.冒泡排序算法\n从开始两个数开始谁大（小）往右移动，一轮就确定了一位，以此类推就可以得到一个有序队列。\n\n```java\n public static void bubbleSort(int[]arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        for (int i=arr.length-1;i>0;i--){\n            for (int j=0;j<i;j++){\n                if (arr[i]>arr[i+1]){\n                    swap(arr,i,i+1);\n                }\n            }\n        }\n    }\n    //交换函数\n    public static void swap(int[]arr,int i,int j){\n        arr[i]=arr[i]^arr[j];\n        arr[j]=arr[i]^arr[j];\n        arr[i]=arr[i]^arr[j];\n    }\n```\n交换中，异或运算中（无进位相加）\n\n- n^0=n\n- n^n=0\n- a^ b=b^a\n- (a^ b)^c=a ^(b ^ c)\n- 一堆数异或，改变顺序，结果不变\n\n不用其它变量交换两个数\n**a=a ^ b;\nb=a ^ b;\na=a ^ b;**\n`a和b值可以一样但储存的内存地址不能相同`\n\n### 3.插入排序算法\n依次做到从0~1、0 ~2、0 ~3...0 ~n位置上有序，也就是说比较当前位置和前一位置的大小，按照排序要求比较移动（升序就把小的往前挪，降序把大的往前挪），移动完成再和前一个数比较，直到不满足条件则跳到下一组进行排序，到最后一组完成时整个数列就是有序的了。\n`插入排序的时间复杂度，会根据原数组的顺序而发生改变，最坏情况下为O（N^2）最好情况下为O（N）`\n\n```java\n   public static void interpolationSort(int[] arr){\n        if (arr == null||arr.length<2){\n            return;\n        }\n        //0~0已经有序\n        for (int i=1;i<arr.length;i++){//0~i有序\n            for (int j=i-1;j>=0&&arr[j]>arr[j+1];j--){//当前数往前换到不能换或者到第一个位置为止\n                swap(arr,j,j+1);\n            }\n\n        }\n    }\n    public static void swap(int[]arr,int i,int j){\n        arr[i]=arr[i]^arr[j];\n        arr[j]=arr[i]^arr[j];\n        arr[i]=arr[i]^arr[j];\n    }\n```\n\n## 异或问题求解\n### 1.数组中只存在一种数出现了奇数次，其它数出现了偶数次，如何找到这种数？\n因为只有一种数出现了偶数次，根据异或运算规则，偶数次 数异或运算都为0，当到奇数次的数时，最后0 ^ 这个数等于他本身，就找到了。\n```java\npublic static void printOddTimesNum1(int[]arr){\n        int eor=0;\n        for (int cur:arr){\n            eor ^=cur;\n        }\n        System.out.println(eor);\n    }\n```\n### 2.数组中只存在两种数出现了奇数次，其它数出现了偶数次，如何找到这两种数？\n当整个数组异或完后最后等于这两个数的异或，也就是这两个数的异或肯定不等于0，也就是这两个数其中位运算中某一位肯定不相同，提取出两个数异或运算后某一位为1的位置，所有的数在这个位置相同的形成一个集合，这里边一定存在这两种数中的一个，则另一个在另外一边，再将一边的数进行异或，由于只有那种数是奇数个，最后异或结果就是这种数，再将 这种数与两种数异或的结果进行异或就得到了另一种数。\n```java\n public static void printOddTimesNum2(int[]arr){\n        int eor=0;\n        for (int cur:arr){\n            eor ^=cur;\n        }\n        //eor=a^b\n        //eor!=0\n        //eor必定有一位不为0\n        int rightOne=eor & (~eor +1);//提取最右侧为1的数  ~eor取反\n        int onlyOne=0;\n        for (int cur:arr){\n            if ((cur & rightOne)==0){\n                onlyOne ^=cur;\n            }\n        }\n        System.out.println(onlyOne+\" \"+(eor ^onlyOne));\n    }\n```\n\n# 总结\n本文简单的介绍了复杂度和几种简单排序算法以及位运算的基本使用。\n","tags":["算法","数据结构","排序算法","复杂度","选择排序","冒泡排序","插入排序"],"categories":["算法","数据结构和算法"]},{"title":"堆结构、堆排序及其应用","url":"/2023/06/30/堆及堆排序应用/","content":"\n\n\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n堆结构、堆排序及其应用\n\n---\n\n\n\n# 一、堆结构\n堆结构是一个数组对象，就是一颗特殊的完全二叉树或是一颗特殊的满二叉树。\n堆分为**大根堆**和**小根堆**。\n>满二叉树：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7d670002d9db47fe8e6563d0e8608858.png)\n\n>完全二叉树：（）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7ba20f01e1e04dcbb0d55d292d5060c6.png)\n\n---\n\n**某个节点i**\n- 左孩子节点下标索引：i*2+1\n- 右孩子节点下标索引：i*2+2\n- 父节点下标索引：(i-1)/2\n---\n\n## 1、大根堆\n每一棵子树的最大值为头节点的值，就为大根堆\n\n>如下\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/210abc6dad0c43d9998868581c19b4c6.png)\n### （1）向上调整（heapInsert）\n调整某个位置能否往上移动\n\n>代码如下：\n\n```java\n// 某个数在index位置能否往上移动\n    public static void heapInsert(int[]arr,int index){\n        while(arr[index]>arr[(index-1)/2]){\n            swap(arr,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n```\n\n### （2）向下调整（heapify）\n某个位置能否往下移动。\n返回最大值并移除：最大值就是第一个值，用最后边那个数代替头节点，整体堆长度减小一，此时需要对这个头节点进行调整，在子孩子中找到最大的再与头节点比较，如果头节点小于子孩子就交换位置，以此类推当子孩子不大于头结点或者没有子孩子时，停止，此时为大根堆。\n>调整代价为：O（logN）\n\n>代码如下：\n\n```java\n    // 某个数在Index位置，能否往下移动\n    public static void heapify(int[]arr,int index,int heapSize){\n        int left=index*2+1; // 左孩子下标\n        while (left<heapSize){ // 如果当前位置有子节点\n            //将两个子孩子大的下标记录\n            int largest=left+1<heapSize && arr[left+1]>arr[left]?left+1:left;\n            //比较父和子哪个值大，值大的记录\n            largest=arr[largest]>arr[index]?largest:index;\n            if (largest==index){ // 符合跳出循环\n                break;\n            }\n            swap(arr,index,largest);\n            index=largest;\n            left=index*2+1;\n        }\n    }\n```\n### （3）合并应用\n当改变其中某个值，可以分别使用向下调整和向上调整，调整过后得到大根堆。\n\n>调整代价为：O（logN）\n## 2、小根堆\n每一棵子树的最小值为头节点的值，就为小根堆,和大根堆刚好相反。\n>如下\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b7c4ead0562f4d8ca1744e25f7b4a826.png)\n\n\n\n# 二、堆排序\n## 1.过程\n不断的从0~1，0 ~2....做到大根堆或小根堆，heapSize为堆长度，每一次新进来个数heapSize++，最终得到堆，然后将最大的与最后一个位置交换，heapSize--，就将最大位置排在了最后并剔除了堆，利用向下调整得到堆，再重复上述步骤，最终heapSize为0时，这个数组就有序了。\n>时间复杂度为：O（NlogN）\n>额外空间复杂度为：O（1）\n\n>代码如下：\n\n```java\npublic class bigRootPile {\n\n    public static void main(String[] args) {\n        int []arr={2,4,5,1,8,2,9,4,3,6};\n        heapSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void heapSort(int[]arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        // O(NlogN)\n        // 可优化\n        for (int i=0;i<arr.length;i++){\n            heapInsert(arr,i);\n        }\n        int heapSize=arr.length;\n        swap(arr,0,--heapSize);\n        while (heapSize>0){\n            heapify(arr,0,heapSize);// O(logN)\n            swap(arr,0,--heapSize);//O(1)\n        }\n    }\n    // 某个数在index位置能否往上移动\n    public static void heapInsert(int[]arr,int index){\n        while(arr[index]>arr[(index-1)/2]){\n            swap(arr,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n    // 某个数在Index位置，能否往下移动\n    public static void heapify(int[]arr,int index,int heapSize){\n        int left=index*2+1; // 左孩子下标\n        while (left<heapSize){ // 如果当前位置有子节点\n            //将两个子孩子大的下标记录\n            int largest=left+1<heapSize && arr[left+1]>arr[left]?left+1:left;\n            //比较父和子哪个值大，值大的记录\n            largest=arr[largest]>arr[index]?largest:index;\n            if (largest==index){ // 符合跳出循环\n                break;\n            }\n            swap(arr,index,largest);\n            index=largest;\n            left=index*2+1;\n        }\n    }\n    // 交换\n    public static void swap(int[]arr,int index,int fIndex){\n        int temp=arr[index];\n        arr[index]=arr[fIndex];\n        arr[fIndex]=temp;\n    }\n}\n\n```\n>结果如下：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/08f94a79e9034ea6b336895a7d4da8ff.png)\n\n`只让一个不为大根堆的变为大根堆可以将以下代码优化`\n\n```java\n for (int i=0;i<arr.length;i++){\n            heapInsert(arr,i);\n        }\n```\n>优化后：\n\n```java\n  for (int i=arr.length-1;i>=0;i--){\n            heapify(arr,i,arr.length);\n        }\n```\n在最后一个数往下调整，做到依次局部大根堆，最终得到大根堆。\n\n# 三、堆排序扩展\n`如果做到高效的进行堆结构的调整，就必须自己手写，而不用系统自带的堆结构，因为系统自带的堆结构在调整时，是从头开始扫描调整`\n\n>**JAVA**中的堆结构：(默认为小根堆)\n>PraiorityQyueue<Integer>heap=new PriorityQueue<>();\n\n## （1）几乎有序数组排序\n已知一个几乎有序数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对则个数据进行排序。\n> 时间复杂度：O（NlogK）\n> 代码如下：\n\n```java\npublic class almostOrdinal {\n    public static void main(String[] args) {\n        int k=2;\n        int []arr={2,8,6,4,14,12,16,16,18};\n        System.out.println(\"排序前：\"+Arrays.toString(arr));\n        almostOrderedSort(arr,k);\n        System.out.println(\"排序后：\"+Arrays.toString(arr));\n    }\n    public static void almostOrderedSort(int[]arr,int k){\n        PriorityQueue<Integer>heap=new PriorityQueue<>();\n        int index=0;\n        for (;index<=Math.min(arr.length,k);index++){// 把前k+1个数放入小根堆（如果k大于数组长度则把整个数组放入）\n            heap.add(arr[index]);\n        }\n        int i=0;\n        for (;index<arr.length;index++){\n            heap.add(arr[index]);// 新加后一位数放到小根堆中\n            arr[i++]= heap.poll();//小根堆弹出最小的数放到i位置\n        }\n        while (!heap.isEmpty()){// 如果没有可加的新数字 依次弹出就行\n            arr[i++]= heap.poll();\n        }\n    }\n}\n```\n\n> 结果如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0c97ec4ae0241ccab0e030a94dd0cdd.png)\n\n# 四、比较器\n自己定义比较策略的类，实质就是重载比较运算符。\n\n# 总结\n\n以上文章主要讲了堆（大根堆、小根堆）和堆排序的思想，以及扩展，和比较器。\n","tags":["算法","数据结构","排序算法","堆结构","堆排序"],"categories":["算法","数据结构和算法"]},{"title":"在排序数组中查找数字 I","url":"/2023/06/30/在排序数组中查找数字 I/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n 在排序数组中查找数字 I\n\n---\n\n# 例子\n\n示例 1：\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n\n示例 2：\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n\n\n---\n# 提示：\n\n- 0 <= nums.length <= 105\n- -109 <= nums[i] <= 109\n- nums 是一个非递减数组\n- -109 <= target <= 109\n\n\n---\n\n\n# 代码实现：\n>利用二分寻找左边界和右边界，再相减就是个数\n## 1.二分：\n```java\nclass Solution {\n        public int search(int[] nums, int target) {\n            if(nums.length==0) return 0;// 数组长度为0直接返回\n            int L=0;\n            int R=nums.length;\n            return search(nums,L,R,target+1)-search(nums,L,R,target);// 分别调用二分找边界\n        }\n        // 二分\n        public int search (int[]nums,int L,int R,int target){\n            while(L<R){\n                int mid=L+((R-L)>>1);\n                if(nums[mid]<target){\n                    L=mid+1;\n                }else{\n                    R=mid;\n                }\n            }\n            return R;\n        }\n    }\n```\n\n\n## 2.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/33e4ed6d2b0e404ba1fa89e7d9ee0122.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n","tags":["算法","数组","二分","简单","offer","力扣"],"categories":["力扣","数组"]},{"title":"包含min函数的栈","url":"/2023/06/30/包含min函数的栈/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n---\n\n# 例子\n\n示例 1：\n\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.min();   --> 返回 -2.\n\n--- \n# 提示：\n\n各函数的调用总次数不超过 20000 次\n\n---\n\n\n# 代码实现：\n## 1.辅助栈：\n>寻找最小的值，开始时辅助栈入栈一个无穷大数保证在栈中没有元素盗用Min()方法任然是正常的，可以在每一次添加的时候利用辅助栈入栈一个当前最小值min，在出栈时，同时将两个栈出栈并更新min的值为辅助栈顶值，保证min是正确的。\n```java\nstatic class MinStack {\n        Stack<Integer> stack;\n        Stack<Integer> stack2;//辅助栈\n        public int min;//记录最小值\n        public MinStack() {\n            min=Integer.MAX_VALUE;\n            stack=new Stack<>();\n            stack2=new Stack<>();\n            stack2.push(min);\n        }\n\n        public void push(int x) {\n            System.out.println(\"加入的值为：\"+x);\n            stack.push(x);\n            min= Math.min(x, min);//记录最小值\n            stack2.push(min);\n            System.out.println(\"加入后栈为：\"+stack);\n        }\n\n        public void pop() {\n            stack.pop();\n            stack2.pop();\n            min=stack2.peek();//出栈后及时更新min的值\n            System.out.println(\"出栈后栈为:\"+stack);\n        }\n\n        public int top() {\n            System.out.println(\"栈顶元素为：\"+stack.peek());\n            return stack.peek();\n        }\n\n        public int min() {\n            System.out.println(\"最小值为：\"+min);\n            return min;\n        }\n    }\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0ce05eb0fe7452e9c3f1a82912fdcea.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)\n","tags":["算法","简单","offer","力扣","栈"],"categories":["力扣","栈"]},{"title":"从尾到头打印链表","url":"/2023/06/30/从尾到头打印链表/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n限制：\n0 <= 链表长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>解题思路：\n>考虑到数组的方式更快，并且限制长度也不是很长，所以一开始想到辅助数组的方式，利用一个辅助数组先将数加入到数组，通过计数得到长度，再从辅助数组末尾依次把数加到返回           数组中，缺点是辅助数组的长度必须为10001；\n            或者利用辅助栈先进后出的特点，先将数压入栈中，最后出栈放入返回数组。\n## 1.辅助数组：\n```java\n  public static int[] reversePrint(ListNode head) {\n          if (head==null) return new int[0];\n          int [] aid = new int[10001];\n          int i=0;\n          while (head != null){\n              aid[++i]= head.val;\n              head=head.next;\n          }\n          int []res=new int[i];\n          for (int j=0;i>0;j++){\n              res[j]=aid[i--];\n          }\n          return res;\n        }\n```\n## 2.辅助栈：\n```java\npublic static int[] reversePrint2(ListNode head) {\n        if (head==null) return new int[0];\n        Stack<Integer>stack=new Stack<Integer>();\n        while (head != null){\n            stack.push(head.val);\n            head=head.next;\n        }\n        int []res=new int[stack.size()];\n        int i=0;\n        while (!stack.isEmpty()){\n            res[i++]=stack.pop();\n        }\n        return res;\n    }\n\n```\n\n## 运行结果：\n>发现数组方式确实要比栈快一点\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a166ae362024fb39e39da0caca8f415.png)\n\n\n\n---\n\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\n","tags":["算法","数组","简单","offer","力扣","栈"],"categories":["力扣","链表"]},{"title":"二进制加法","url":"/2023/06/30/二进制加法/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。\n            输入为 非空 字符串且只包含数字 1 和 0。\n\n---\n\n# 例子\n\n示例 1：\n\n输入: a = \"11\", b = \"10\"\n输出: \"101\"\n\n示例 2：\n输入: a = \"1010\", b = \"1011\"\n输出: \"10101\"\n\n示例 3：\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n\n---\n# 提示：\n\n- 每个字符串仅由字符 '0' 或 '1' 组成。\n- 1 <= a.length, b.length <= 10^4\n- 字符串如果不是 \"0\" ，就都不含前导零。\n\n---\n\n\n# 代码实现：\n## 对位相加：\n>通过对位相加满2进1的思路进行计算，不足位用0代替。\n>字符运算时是通过ASCII码进行计算的，所以在计算时结果应“ -‘0’ ”，取余时应“ +‘0’ ”\n```java\npublic static String addBinary(String a,String b){\n         StringBuilder ans=new StringBuilder();//存字符的\n         int n= Math.max(a.length(), b.length());//选择最长的字符长度\n         int carry=0;//进位计数\n         for (int i=0;i<n;i++){//从最右边开始＋，没有的用0代替\n             carry+=a.length()>i?(a.charAt(a.length()-i-1)-'0'):0;// 字符运算时通过ASCII码进行计算的所以这里要“-‘0’”使其值是对的\n             carry+=b.length()>i?(b.charAt(b.length()-i-1)-'0'):0;\n             ans.append((char)(carry%2+'0'));//取余查看剩下是0还是1\n             carry /=2;//进位是否为1\n         }\n         if (carry==1){//最终最高位判定\n             ans.append('1');\n         }\n         ans.reverse();//翻转\n         return ans.toString();\n     }\n```\n## 运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/57cd83457cbc4d6480be4fc6f8f062ae.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/JFETK5/)\n","tags":["算法","简单","offer","力扣","字符串"],"categories":["力扣","字符串"]},{"title":"二维数组中查找","url":"/2023/06/30/二维数组中的查找/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n限制：0 <= n <= 1000       0 <= m <= 1000\n\n\n---\n\n# 例子\n\n示例 1：\n现有矩阵 matrix 如下：\n\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n给定 target = 5，返回 true。\n\n给定 target = 20，返回 false。\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n\n## 1.循环二分：\n>每一行用二分查找\n\n>时间复杂度：O（MlogN）    空间复杂度：O（1）\n```java\npublic static boolean findNumberIn2DArray(int[][] matrix, int target) {\n            if (matrix.length == 0 || matrix[0].length == 0) return false;\n            for (int[] ints : matrix) {// 行\n                int left = 0;\n                int right = matrix[0].length - 1;\n                while (left <= right) {// 二分\n                    int half = left + ((right - left) >> 1);\n                    if (ints[half] < target) {\n                        left = half + 1;\n                    } else if (ints[half] > target) {\n                        right = half - 1;\n                    } else return true;\n                }\n            }\n            return false;\n        }\n```\n## 2.仿搜索树：\n>从左下角或者右上角开始找，因为每行开头和结尾的值是极端，相当于搜索二叉树的节点；从左下角找，比目标数大就往上一行找，比目标数小就往下一列找\n\n>时间复杂度：O（M+N）    空间复杂度：O（1）\n\n```java\npublic static boolean findNumberIn2DArray2(int[][] matrix, int target) {\n            if (matrix.length == 0 || matrix[0].length == 0) return false;\n            int i = 0;\n            int j = matrix.length - 1;\n            while (j >= 0) { // 从左下角开始找（也可以从右上角，i--,j++）\n                if (matrix[j][i] > target) j--;// 开头的值大于目标数，往上一行找\n                else if (matrix[j][i] < target) {// 开头的数小于目标数，往下一列找\n                    ++i;\n                    if (i > matrix[0].length - 1) return false;\n                } else return true;\n            }\n            return false;\n        }\n\n```\n\n## 3.运行结果\n###  1、循环二分\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9e58b867aefd439897d82d6fd0c44ad5.png)\n\n###  2、仿搜索树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/053aa26636e248558a7781d77a0a767c.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)\n","tags":["算法","数组","二分","offer","力扣","中等"],"categories":["力扣","数组"]},{"title":"二叉树的识别与应用","url":"/2023/06/30/二叉树的识别与应用/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n>二叉树节点结构：\n\n```java\n  public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data){\n            this.value=data;\n        }\n    }\n```\n\n`代码中实现的二叉树都为图片所示二叉树`\n\n\n# 一、二叉树的先序、中序、后序遍历\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b5239a183a8245ae80862c62bbf94599.png)\n二叉树递归序：1->2->3->3->3->2->4->4->4->2->1->6->7->7->7->6->1\n\n先序：1->2->3->4->6->7\n中序：3->2->4->1->7->6\n后序：3->4->2->7->6->1\n## 1、递归方式（先序、中序、后序）\n```java\npublic class traverse {\n    public static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n\n        System.out.println(\"==============二叉树遍历===============\");\n        System.out.print(\"pree-order: \");\n        preorderTraversal(head);\n\n        System.out.println();\n        System.out.print(\"in-order: \");\n        inorderTraversal(head);\n\n        System.out.println();\n        System.out.print(\"pos-order: \");\n        postOrderTraversal(head);\n\n    }\n    // 树节点\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    //先序遍历\n    public static void preorderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        System.out.print(head.value+\" \");\n        preorderTraversal(head.left);\n        preorderTraversal(head.right);\n    }\n\n    //中序遍历\n    public static void inorderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        inorderTraversal(head.left);\n        System.out.print(head.value+\" \");\n        inorderTraversal(head.right);\n    }\n\n    //后序遍历\n    public static void postOrderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        postOrderTraversal(head.left);\n        postOrderTraversal(head.right);\n        System.out.print(head.value+\" \");\n    }  \n}\n\n```\n\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/dc5e3ca1645e40538685bd0032bae0e0.png)\n\n## 2、非递归（先序、中序、后序）\n\n```java\npublic static void main(String[] args) {\n        traverse.Node head=new traverse.Node(1);\n        head.left=new traverse.Node(2);\n        head.right=new traverse.Node(6);\n        head.left.left=new traverse.Node(3);\n        head.left.right=new traverse.Node(4);\n        head.right.left=new traverse.Node(7);\n\n        System.out.println(\"==============二叉树非递归遍历===============\");\n        preOrderUnRecur(head);\n\n        System.out.println();\n        inOrderUnRecur(head);\n\n        System.out.println();\n        posOrderUnRecur1(head);\n\n\n    }\n    // 树节点\n    public static class Node{\n        public int value;\n        public traverse.Node left;\n        public traverse.Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    //先序遍历\n    public static void preOrderUnRecur(Node head){\n        System.out.print(\"pre-order: \");\n        if (head!=null){\n            Stack<Node> stack=new Stack<Node>();\n            stack.add(head);\n            while (!stack.isEmpty()){\n                head=stack.pop();\n                System.out.print(head.value+\" \");\n                if (head.right!=null){\n                    stack.push(head.right);\n                }\n                if (head.left!=null){\n                    stack.push(head.left);\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    //中序遍历\n    public static void inOrderUnRecur(Node head){\n        System.out.print(\"in-order: \");\n        if (head!=null){\n            Stack<Node>stack=new Stack<Node>();\n            while (!stack.isEmpty() || head != null){\n                if (head!=null){// 把左边界都入栈\n                    stack.push(head);\n                    head=head.left;\n                }else {// 依次弹节点并跳到右结点\n                    head=stack.pop();\n                    System.out.print(head.value+\" \");\n                    head=head.right;\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    // 后序遍历\n    // 用先序遍历的 头右左 逆序输出就是后序遍历\n    public static void posOrderUnRecur1(Node head){\n        System.out.print(\"pos-order: \");\n        if (head!=null){\n            Stack<Node>s1=new Stack<Node>();\n            Stack<Node>s2=new Stack<Node>();\n            s1.push(head);\n            while (!s1.isEmpty()){\n                head=s1.pop();\n                s2.push(head);\n                if (head.left!=null){\n                    s1.push(head.left);\n                }\n                if (head.right!=null){\n                    s1.push(head.right);\n                }\n            }\n            while (!s2.isEmpty()){\n                System.out.print(s2.pop().value+\" \");\n            }\n        }\n        System.out.println();\n    }\n```\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f7d15bb9db1a4283b9b6c6071afd36ac.png)\n\n# 二、宽度优先遍历\n## 1.遍历\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n        System.out.println(\"==========宽度优先遍历===========\");\n        w(head);\n    }\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n    public static void w(Node head){\n        if (head==null){\n            return;\n        }\n        Queue<Node>queue=new LinkedList<>();\n        queue.add(head);\n        while (!queue.isEmpty()){\n            Node cur=queue.poll();\n            System.out.print(cur.value+\" \");\n            if (cur.left!=null){\n                queue.add(cur.left);\n            }\n            if (cur.right!=null){\n                queue.add(cur.right);\n            }\n        }\n    }\n```\n\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/70d8b13a66ac4607b713b277166f4f11.png)\n## 2、最大宽度查找\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n\n        System.out.println(\"==========最大宽度===========\");\n        System.out.println(\"该树最大宽度为： \"+w(head));\n    }\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n    public static int w(Node head){\n        if (head==null){\n            return 0;\n        }\n        Queue<Node> queue=new LinkedList<>();\n        queue.add(head);\n        HashMap<Node,Integer>levelMap=new HashMap<>();\n        levelMap.put(head,1);\n        int curLevel=1;\n        int curLevelNodes=0;\n        int max=Integer.MIN_VALUE;\n        while (!queue.isEmpty()){\n           Node cur=queue.poll();\n           int curNodeLevel=levelMap.get(cur);\n           if (curNodeLevel==curLevel){\n               curLevelNodes++;\n           }else {\n               max=Math.max(max,curLevelNodes);\n               curLevel++;\n               curLevelNodes=1;\n           }\n            if (cur.left!=null){\n                levelMap.put(cur.left,curNodeLevel+1);\n                queue.add(cur.left);\n            }\n            if (cur.right!=null){\n                levelMap.put(cur.right,curNodeLevel+1);\n                queue.add(cur.right);\n            }\n        }\n        max=Math.max(max,curLevelNodes);\n        return max;\n    }\n```\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/eecd7eb2fb0a484f911ab85d7a26fb12.png)\n\n# 三、是否为搜索二叉树\n## 1、搜索二叉树\n>整棵树右子树要大于左子树的值，称该树为搜索二叉树，如图:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b36f09f405b94d3b8eac45d054a76b76.png)\n\n\n## 2、判断搜索二叉树\n利用中序遍历的特点（左中右），如果为是搜索二叉树，则中序遍历是逐渐增大的。\n\n>分为递归和非递归方式\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(8);\n        head.left=new Node(3);\n        head.right=new Node(10);\n        head.left.left=new Node(1);\n        head.left.right=new Node(6);\n        head.left.right.left=new Node(4);\n        head.left.right.right=new Node(7);\n        head.right.right=new Node(14);\n        head.right.right.left=new Node(13);\n        System.out.print(\"递归方式： \");\n        System.out.println(checkBST(head)?\"是一颗搜索二叉树\":\"不是一颗搜索二叉树\");\n        System.out.print(\"非递归方式： \");\n        System.out.println(checkBST2(head)?\"是一颗搜索二叉树\":\"不是一颗搜索二叉树\");\n    }\n\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    public static int preValue=Integer.MIN_VALUE;\n\n    //递归 判断是否为搜索二叉树\n    public static Boolean checkBST(Node head){\n        if (head==null){\n            return true;\n        }\n        boolean isLeftBst=checkBST(head.left);\n        if (!isLeftBst){\n            return false;\n        }\n        if (head.value<=preValue){\n            return false;\n        }else {\n            preValue= head.value;\n        }\n        return checkBST(head.right);\n    }\n\n    //非递归\n    public static int preValue2=Integer.MIN_VALUE;\n    public static Boolean checkBST2(Node head){\n        if (head!=null){\n            Stack<Node>stack=new Stack<Node>();\n            while (!stack.isEmpty() || head != null){\n                if (head!=null){// 把左边界都入栈\n                    stack.push(head);\n                    head=head.left;\n                }else {// 依次弹节点并跳到右结点\n                    head=stack.pop();\n                    if (head.value<=preValue2){\n                        return false;\n                    }else {\n                        preValue2= head.value;\n                    }\n                    head=head.right;\n                }\n            }\n        }\n       return true;\n    }\n```\n\n> 运行结果：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8fa6e7de492b4ea2beca81132842e6f3.png)\n\n\n---\n  >套路递归：\n  >每一颗子树都应该满足：**左子树<父节点<右子树**\n\n>构建信息体：\n\n```java\n public static class ReturnData{// 信息体\n        public boolean isBST;\n        public int min;\n        public int max;\n\n        public ReturnData(boolean is,int min,int max){\n            this.isBST=is;\n            this.min=min;\n            this.max=max;\n        }\n    }\n```\n>加工信息：\n\n```java\npublic static ReturnData process(Node x){\n        if (x==null){\n            return null;\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n        int min=x.value;\n        int max= x.value;\n        if (leftData!=null){// 左子树中最大和最小\n            min=Math.min(min, leftData.min);\n            max=Math.max(max, leftData.max);\n        }\n        if (rightData!=null){// 右子树中最大和最小\n            min=Math.min(min, rightData.min);\n            max=Math.max(max, rightData.max);\n        }\n\n        boolean isBST=true;\n        // 左子树不为空和（左子树>=父节点 或 左子树不为搜索二叉树）\n        if (leftData!=null && (!leftData.isBST || leftData.max>=x.value)){\n            isBST=false;\n        }\n        // 右子树不为空和（右子树<=父节点 或 右子树不为搜索二叉树）\n        if (rightData!=null && (!rightData.isBST ||x.value>=rightData.min)){\n            isBST=false;\n        }\n        return new ReturnData(isBST,min,max);//最终返回\n    }\n```\n\n# 四、是否为完全二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3f9a09e29a6446b9bff0d49d4650b5f4.png)\n\n## 完全二叉树的两个条件\n 1. 某个节点左孩子为空右孩子不能为空\n 2. 在一的条件下遇到过左右两孩子不双全的节点，当前节点不能有叶子节点\n\n> 代码如下\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(3);\n        head.left.left=new Node(4);\n        head.left.right=new Node(5);\n        head.right.left=new Node(6);\n        head.right.right=new Node(7);\n        head.left.left.left=new Node(8);\n        head.left.left.right=new Node(9);\n        head.left.right.left=new Node(10);\n        head.left.right.right=new Node(11);\n        head.right.left.left=new Node(12);\n        System.out.println(\"是否为完全二叉树： \"+isBCT(head));\n    }\n\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data ){\n            this.value=data;\n        }\n    }\n\n    /*\n      判断是否为完全二叉树需要两个条件\n      1、左孩子为空右孩子不能为空\n      2、在一的条件下遇到过左右两孩子不双全的节点，当前节点不能有叶子节点\n     */\n    public static Boolean isBCT(Node head){\n        if (head==null){\n            return true;\n        }\n        LinkedList<Node>queue=new LinkedList<>();\n        boolean leaf=false;// 是否遇到过左右两个孩子不双全的节点\n        Node l=null;\n        Node r=null;\n        queue.add(head);\n        while (!queue.isEmpty()){\n            head=queue.poll();\n            l=head.left;\n            r=head.right;\n            if(\n                    (leaf && (l != null || r != null))\n                    ||\n                            (l==null && r!=null)\n            ){\n                return false;\n            }\n            if (l!=null){\n                queue.add(l);\n            }\n            if (r!=null){\n                queue.add(r);\n            }\n            if (l==null||r==null){\n                leaf=true;\n            }\n        }\n        return true;\n    }\n```\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d9f014f7e2e45eb98a56086f128163d.png)\n\n# 五、是否为满二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/85e6dac612864a7289c4a6dabc6ca174.png)\n## 满二叉树的条件\n\n >记一棵树最大深度为L，所有节点数为N，满二叉树存在以下关系：\n **N=2^L-1**\n \n>构建信息体，只要知道树的高度和节点个数\n\n```java\n public static class ReturnData{\n        public boolean isF;\n        public int height;\n        public int nodes;\n        public ReturnData(boolean isF ,int height,int nodes){\n            this.height=height;\n            this.nodes=nodes;\n            this.isF=isF;\n        }\n    }\n```\n\n>信息处理\n\n```java\n//加工信息\n    public static ReturnData process(Node x){\n        if (x==null){\n            return new ReturnData(true,0,0);\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n\n        boolean isF=true;\n        int height=Math.max(leftData.height,rightData.height)+1;\n        int nodes=leftData.nodes+ rightData.nodes+1;\n        // 是否符合 N=2^L-1\n        if (nodes!=Math.pow(2,height)-1){\n            isF=false;\n        }\n        return new ReturnData(isF,height,nodes);\n    }\n}\n```\n\n>完整代码\n\n```java\n public static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(3);\n        head.left.left=new Node(4);\n        head.left.right=new Node(5);\n        head.right.left=new Node(6);\n        head.right.right=new Node(7);\n        head.left.left.left=new Node(8);\n        head.left.left.right=new Node(9);\n        head.left.right.left=new Node(10);\n        head.left.right.right=new Node(11);\n        head.right.left.left=new Node(12);\n        head.right.left.right=new Node(13);\n        head.right.right.left=new Node(14);\n        head.right.right.right=new Node(15);\n        System.out.println(\"节点数： \"+process(head).nodes);\n        System.out.println(\"高度： \"+process(head).height);\n        System.out.println(\"是否为满二叉树： \"+process(head).isF);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n\n    /*\n    构建信息体\n     */\n    public static class ReturnData{\n        public boolean isF;\n        public int height;\n        public int nodes;\n        public ReturnData(boolean isF ,int height,int nodes){\n            this.height=height;\n            this.nodes=nodes;\n            this.isF=isF;\n        }\n    }\n\n    //加工信息\n    public static ReturnData process(Node x){\n        if (x==null){\n            return new ReturnData(true,0,0);\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n\n        boolean isF=true;\n        int height=Math.max(leftData.height,rightData.height)+1;\n        int nodes=leftData.nodes+ rightData.nodes+1;\n        // 是否符合 N=2^L-1\n        if (nodes!=Math.pow(2,height)-1){\n            isF=false;\n        }\n        return new ReturnData(isF,height,nodes);\n    }\n```\n\n# 六、是否为平衡二叉树\n## 平衡二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/989fe7c9037d492db12bb38368924acb.png =300x300)\n\n>对任何一个子树来说，左数和右树的高度差不超过1。\n\n 1. 左子树为平衡二叉树\n 2. 右子树为平衡二叉树\n 3. |左子树高度-右子树高度|<=1\n \n\n```java\n public static ReturnType process(Node x){\n        if (x==null){\n            return new ReturnType(true,0);\n        }\n        // 递归左右子树返回信息\n        ReturnType leftData=process(x.left);\n        ReturnType rightData=process(x.right);\n\n        // 整颗树高度\n        int height=Math.max(leftData.height, rightData.height)+1;\n        // 三个条件判断\n        boolean isBalanced= leftData.isBalanced && rightData.isBalanced\n                && Math.abs(leftData.height- rightData.height)<2;\n\n        return new ReturnType(isBalanced,height);//最终返回总的\n    }\n```\n\n---\n>在递归结构中左子树和右子树需要的信息都为高度和是否平衡：\n\n```java\npublic static class ReturnType{ // 子树信息结构体\n        public boolean isBalanced;// 是否平衡\n        public int height;// 树高度\n        public ReturnType(boolean isB,int height){// 构造函数\n            this.isBalanced=isB;\n            this.height=height;\n        }\n    }\n```\n\n>完整代码：\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(5);\n        head.left=new Node(3);\n        head.right=new Node(7);\n        head.left.left=new Node(2);\n        head.left.right=new Node(4);\n        head.right.left=new Node(6);\n        System.out.println(\"树高为：\"+isBalanced(head).height);\n        System.out.println(\"是否为平衡二叉树：\"+isBalanced(head).isBalanced);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    public static ReturnType isBalanced(Node  head){// 主函数\n        return process(head);\n    }\n    public static class ReturnType{ // 子树信息结构体\n        public boolean isBalanced;// 是否平衡\n        public int height;// 树高度\n        public ReturnType(boolean isB,int height){// 构造函数\n            this.isBalanced=isB;\n            this.height=height;\n        }\n    }\n    public static ReturnType process(Node x){\n        if (x==null){\n            return new ReturnType(true,0);\n        }\n        ReturnType leftData=process(x.left);\n        ReturnType rightData=process(x.right);\n\n        int height=Math.max(leftData.height, rightData.height)+1;\n        boolean isBalanced= leftData.isBalanced && rightData.isBalanced\n                && Math.abs(leftData.height- rightData.height)<2;\n\n        return new ReturnType(isBalanced,height);\n    }\n```\n\n>运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a54e916bd034bad90c77ec428e10dc7.png)\n# 七、二叉树题目应用\n## 1、最低公共祖先节点\n>题目描述：\n>给定两个二叉树的节点node1和node2,找到他们最低公共祖先节点\n>如图G和F节点的最低公共祖先节点为C，E和G的 最低公共祖先为E。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n\n\n>解题思路：\n>理解版：\n>将其中一个节点往上回溯的其余节点和他本身放到一个集合中，如F节点往上回溯将A、C、F三个节点放入集合中，再将另一个节点往上回溯，每次回溯都去第一个集合查询是否存在该节点，没有就往上回溯，直到第一个出现在第一集合中的节点就是最低公共祖父节点，如G节点往上回溯，发现G、E不存在，最终找到C，C就是该最低祖父节点。\n\n>储存关系集合：\n\n```java\n //迭代将整个树关系储存\n    public static void process(Node head, HashMap<Node,Node>fatherMap){\n        if (head==null){\n            return;\n        }\n        fatherMap.put(head.left,head);\n        fatherMap.put(head.right,head);\n\n        process(head.left,fatherMap);\n        process(head.right,fatherMap);\n    }\n\n```\n\n>回溯查找：\n\n```java\npublic static Node lca(Node head,Node o1,Node o2){\n        HashMap<Node,Node>fatherMap=new HashMap<>();\n        fatherMap.put(head,head);\n        process(head,fatherMap);//储存整棵树各个节点的回溯关系\n        HashSet<Node>set1=new HashSet<>();\n        HashSet<Node>set2=new HashSet<>();\n\n        Node cur=o1;\n        while (cur!=fatherMap.get(cur)){//第一个节点回溯添加\n            set1.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        set1.add(head);// 将头节点添加\n\n        cur=o2;\n        while (cur!=fatherMap.get(cur)){//第二个节点回溯添加\n            set2.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        for (Node node1:set2){\n            for (Node node2 : set1) {\n                if (node1==node2){\n                    return node2;\n                }\n            }\n        }\n```\n\n>**简易版:**\n>  1、当o1是 o2的最低公共祖先或当o2是 o1的最低公共祖先\n        2、o1和o2不互为公共祖先，必须向上回溯才能找到\n\n```java\npublic static Node lca2(Node head,Node o1,Node o2){\n        if (head==null || head==o1 || head==o2){\n            return head;\n        }\n        //以头节点分成左右两个树\n        Node left=lca2(head.left, o1, o2);//左树返回\n        Node right=lca2(head.right, o1, o2);//右树返回\n        if (left!=null && right!=null){// 条件二判断\n            return head;\n        }\n        //左右两棵树，并不都有返回值（条件一）\n        return left!=null ? left:right;\n    }\n```\n\n>完整代码：\n\n```java\n public static void main(String[] args) {\n        Node head=new Node(\"A\");\n        head.left=new Node(\"B\");\n        head.right=new Node(\"C\");\n        head.left.left=new Node(\"D\");\n        head.right.left=new Node(\"E\");\n        head.right.right=new Node(\"F\");\n        head.right.left.left=new Node(\"G\");\n        System.out.println(\"理解版最低祖父公共节点为：\"+lca(head,head.right.left.left,head.right.right).value);\n        System.out.println(\"简洁版最低祖父公共节点为：\"+lca2(head,head.right.left.left,head.right.right).value);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public String value;\n\n        public Node(String data){\n            this.value=data;\n        }\n    }\n\n    /*\n    易理解版\n     */\n    public static Node lca(Node head,Node o1,Node o2){\n        HashMap<Node,Node>fatherMap=new HashMap<>();\n        fatherMap.put(head,head);\n        process(head,fatherMap);//储存整棵树各个节点的回溯关系\n        HashSet<Node>set1=new HashSet<>();\n        HashSet<Node>set2=new HashSet<>();\n\n        Node cur=o1;\n        while (cur!=fatherMap.get(cur)){//第一个节点回溯添加\n            set1.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        set1.add(head);// 将头节点添加\n\n        cur=o2;\n        while (cur!=fatherMap.get(cur)){//第二个节点回溯添加\n            set2.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        for (Node node1:set2){\n            for (Node node2 : set1) {\n                if (node1==node2){\n                    return node2;\n                }\n            }\n        }\n\n        return head;\n    }\n    //迭代将整个树关系储存\n    public static void process(Node head, HashMap<Node,Node>fatherMap){\n        if (head==null){\n            return;\n        }\n        fatherMap.put(head.left,head);\n        fatherMap.put(head.right,head);\n\n        process(head.left,fatherMap);\n        process(head.right,fatherMap);\n    }\n\n\n    /*\n    简洁版：\n        1、当o1是 o2的最低公共祖先或当o2是 o1的最低公共祖先\n        2、o1和o2不互为公共祖先，必须向上回溯才能找到\n     */\n    public static Node lca2(Node head,Node o1,Node o2){\n        if (head==null || head==o1 || head==o2){\n            return head;\n        }\n        //以头节点分成左右两个树\n        Node left=lca2(head.left, o1, o2);//左树返回\n        Node right=lca2(head.right, o1, o2);//右树返回\n        if (left!=null && right!=null){// 条件二判断\n            return head;\n        }\n        //左右两棵树，并不都有返回值（条件一）\n        return left!=null ? left:right;\n    }\n```\n>运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9aa2ac8ab7d04832b63d393c5805fbce.png)\n\n## 2、后继节点\n>题目描述：\n>不通过中序遍历找到某个节点的后继（前继）节点\n>`后继节点就是中序遍历的当前节点的后一个节点，前继相反`\n>如图二叉树中序遍历为：D->B->A->G->E->C->F\n>则B的后继为A，前继为D\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n\n>解题思路：\n\n>后继：\n >1. 当需要找的节点有右子树时，他的后继就是右子树的最左子树（没有最左时就是本身）\n > 2. 当需要找的节点有右子树时，向上寻找节点，直到找到某个节点是该节点头节点的左子树时，该节点的头就是后继\n\n>根据情况一向左一直找最左子树\n\n```java\n // 向左寻找最左子树\n    public static Node getLeftMost(Node node){\n        if (node==null){\n            return null;\n        }\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n```\n\n>根据情况二找\n\n```java\n Node parent=node.parent;\n            while (parent!=null && parent.left!=node){//当前节点是其父亲节点右孩子 情况二\n                node=parent; //往上移动\n                parent=node.parent;\n            }\n            return parent;\n```\n\n>完整代码\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(\"A\");\n        head.left=new Node(\"B\");\n        head.right=new Node(\"C\");\n        head.left.left=new Node(\"D\");\n        head.right.left=new Node(\"E\");\n        head.right.right=new Node(\"F\");\n        head.right.left.left=new Node(\"G\");\n        head.parent=null;\n        head.left.parent=head;\n        head.right.parent=head;\n        head.left.left.parent=head.left;\n        head.right.left.parent=head.right;\n        head.right.right.parent=head.right;\n        head.right.left.left.parent=head.right.left;\n        System.out.println(\"G节点的后继为：\"+getSuccessorNode(head.right.left.left).value);\n    }\n    public static class Node{\n        public String value;\n        public Node left;\n        public Node right;\n        public Node parent;// 指向自己的父节点\n        public Node(String value){\n            this.value=value;\n        }\n    }\n    public static Node getSuccessorNode(Node node){\n        if (node==null){\n            return null;\n        }\n        if (node.right!=null){//情况一\n            return getLeftMost(node.right);\n        }else {//无右子树\n            Node parent=node.parent;\n            while (parent!=null && parent.left!=node){//当前节点是其父亲节点右孩子 情况二\n                node=parent; //往上移动\n                parent=node.parent;\n            }\n            return parent;\n        }\n    }\n    // 向左寻找最左子树\n    public static Node getLeftMost(Node node){\n        if (node==null){\n            return null;\n        }\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n```\n\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c183681319254d358d5bb6a8a3224473.png)\n## 3、二叉树的序列化与反序列化\n>题目描述：\n>从字符串到内存结构的转换叫反序列化，从内存结构到字符串的转换叫序列化\n>以‘#’表示null，节点之间用'_'隔开\n>如图所示二叉树的先序为：A_B_D_C_E_G_F\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n### （1）二叉树的序列化\n\n```java\n public static String serialByPre(Node head){\n        if (head==null){\n            return \"#_\";\n        }\n        String res=head.value+\"_\";\n        res+=serialByPre(head.left);\n        res+=serialByPre(head.right);\n        return res;\n    }\n```\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d29624b16513492997b1126ba55ca39e.png)\n\n### （1）二叉树的反序列化\n\n```java\n//反序列化主函数\n    public static Node reconByPreString(String preStr){\n        String[]values=preStr.split(\"_\");\n        Queue<String> queue = new LinkedList<String>(Arrays.asList(values));//将每一项复制给队列\n        return reconPreOrder(queue);\n    }\n    //反序列化处理\n    public static Node reconPreOrder(Queue<String>queue){\n        String value=queue.poll();\n        if (Objects.equals(value, \"#\")){\n            return null;\n        }\n        Node head=new Node(value);\n        head.left=reconPreOrder(queue);//左树反序列\n        head.right=reconPreOrder(queue);//右树反序列\n        return head;\n    }\n```\n## 4、折纸条问题\n>问题描述：\n>一个纸条向自己的方向向上折N次，依次打印折痕方向（折痕向外为‘凹’，向内为‘凸’）。\n>\n>如折一次时，纸条的折痕为‘凹’；折两次时，折痕为‘凹凹凸’；三次时，折痕为‘凹凹凸凹凹凸凸’。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e99ffb2d6da4b91b3ffdb5dc46f9c7e.png)\n\n\n\n>解题思路：\n>经过模拟发现折痕是一颗总头节点为‘凹’ 左子树为‘凹’，右子树为‘凸’的满树，如果打印折痕就是将这棵树中序遍历。\n\n>代码实现\n\n```java\npublic static void main(String[] args) {\n        int N=3;\n        printAllFolds(N);\n    }\n    public static void printAllFolds(int N){\n        printProcess(1,N,true);\n    }\n    /*\n       i为节点层数\n       N为共几层\n       down == true 凹\n       down == false 凸\n     */\n\n    public static void printProcess(int i,int N,boolean down){\n        if (i>N){// 超过就返回\n            return;\n        }\n        //中序遍历\n        printProcess(i+1,N,true);\n        System.out.println(down?\"凹\":\"凸\");\n        printProcess(i+1,N,false);\n    }\n```\n\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cc2e0bb98867458dac22165e5cedea55.png)\n\n# 总结\n\n\n本文简单介绍了二叉树的三种遍历，以及相关二叉树的识别以及一些二叉树的应用题。\n\n","tags":["二叉树","数据结构","二叉树遍历","搜索二叉树"],"categories":["二叉树","数据结构和算法"]},{"title":"两数之和II-输入有序数组","url":"/2023/06/30/两数之和II-输入有序数组/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n你所设计的解决方案必须只使用常量级的额外空间。\n\n---\n\n# 例子\n\n示例 1：\n\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n示例 2：\n\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n示例 3：\n\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n\n---\n# 提示：\n\n - 2 <= numbers.length <= 3 * 104\n- -1000 <= numbers[i] <= 1000\n- numbers 按 非递减顺序 排列\n- -1000 <= target <= 1000\n- 仅存在一个有效答案\n\n---\n\n\n# 代码实现：\n## 1.双指针：\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n       int left =0;\n       int rigth=numbers.length-1;\n       while(left<rigth){\n           if(numbers[left]+numbers[rigth]==target){\n               return new int []{left+1,rigth+1};\n           }else if(numbers[left]+numbers[rigth]<target){\n               left++;\n           }else rigth--;\n       }\n       return new int[]{};\n    }\n}\n```\n## 2.二分：\n`使用二分时我发现会超时，但是暴力求解不会`\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        for(int i=0;i<numbers.length-1;i++){\n          int left =i+1;\n          int rigth=numbers.length-1;\n          while(left<=rigth){\n               int mid=left+((rigth-left)>>1);\n           if(numbers[mid]==target-numbers[i])return new int[]{i+1,mid+1};\n           else if (numbers[mid] > target - numbers[i]){\n              rigth=mid-1; \n           }\n           else rigth=mid+1;\n           }\n        }\n       return new int[]{-1,-1};\n    }\n}\n\n```\n\n## 3.暴力求解\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int temp2[]=new int[2];\n        for(int i=0;i<numbers.length;i++){\n            int temp=target-numbers[i];\n            for(int j=i+1;j<numbers.length;j++){\n               if(numbers[j]==temp){\n                   temp2[0]=i+1;\n                   temp2[1]=j+1;\n                   return temp2;\n               }\n            }\n        }\n        return temp2;\n    }\n}\n\n```\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)\n","tags":["算法","数组","简单","offer","力扣"],"categories":["力扣","整数"]},{"title":"Webpack5核心原理与应用实践（基础用法)一","url":"/2023/06/30/Webpack5核心原理与应用实践（基础用法）一/","content":"\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n记录Webpack基本配置规则；根据场景、技术栈运用具体方法、工具与技巧。\n主要有：搭建完善的JavaScript、CSS开发环境；搭建微前端、NPM包、桌面应用等。\n\n---\n# 一、Webpack配置项\n##  1.Webpack编译流程\n>Webpak原生配置项数不胜数，最终都会作用于不同阶段\n\n>大致编译流程可分为四个流程：\n>\n>**输入**--->**模块处理**--->**后处理**--->**输出**\n\n - **输入**：从文件系统读入代码文件\n - **模块递归处理**：调用 Loader 转译 Module（模块） 内容，并将结果转换为 **AST**（抽象语法树），从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；\n- **后处理**：所有模块递归处理完毕后开始执行后处理，包括**模块合并**、**注入运行时**、**产物优化**等，最终输出 **Chunk** （按照某种规则的模块集合）集合；\n- ****输出****：将Chunk写出到外部文件系统；\n\n--- \n##  2.Webpack配置\n\n>Webpack配置项可分为两大类\n\n - **流程类**：作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项\n - **工具类**：打包主流程之外，提供更多工程化工具的配置项\n\n###  （1）流程类配置\n>与流程类配置强相关配置有：\n\n - 输入输出：\n   - `entry`：用于定义项目入口文件，**Webpack** 会从这些入口文件开始按图索骥找出所有项目文件；  \n   - `context`：项目执行上下文路径；\n   - `output`：配置产物输出路径、名称等；\n - 模块处理：\n   - `resolve`：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块\n   - `module`：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 **Loader** 进行处理\n   - `externals`：用于声明外部资源，**Webpack** 会直接忽略这部分资源，跳过这些资源的解析、打包操作\n - 后处理：\n    - `optimization`：用于控制如何优化产物包体积，内置 **Dead Code Elimination**、**Scope Hoisting**、代码混淆、代码压缩等功能\n    - `target`：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异\n    - `mode`：编译模式短语，支持 development、production 等值，可以理解为一种声明环境的短语\n\n>**Webpack** **首先**需要根据输入配置(`entry/context`) 找到项目入口文件；**之后**根据按模块处理(`module/resolve/externals` 等) 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，**最后**再根据后处理相关配置项(`optimization/target` 等)合并模块资源、注入运行时依赖、优化产物结构等。\n\n---\n###  （2）工具类配置\n>除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具，大体上可划分为：\n- 开发效率类：\n  - `watch`：用于配置持续监听文件变化，持续构建\n  - `devtool`：用于配置产物 Sourcemap(储存代码转换前后的对应位置信息) 生成规则\n  - `devServer`：用于配置与 HMR(模块热更新) 强相关的开发服务器功能\n- 开发效率类：\n  - `cache`：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果\n  - ` performance`：用于配置当产物大小超过阈值时，如何通知开发者\n- 日志类：\n   - `stats`：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用\n   - `infrastructureLogging`：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件\n\n---\n\n##  3.配置逻辑\n\n>文件结构如下：\n\n```bash\n.\n├── src\n|   └── index.js\n└── webpack.config.js\n```\n>其中，`src/index.js` 为项目入口文件，`webpack.config.js` 为 **Webpack** 配置文件。在配置文件中，首先我们需要声明项目入口：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: \"./src/index\"\n};\n```\n\n>声明产物输出路径：\n\n```javascript\n// webpack.config.js\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: \"./src/index\",\n  output: {\n    filename: \"[name].js\",\n    path: path.join(__dirname, \"./dist\"),\n  }\n};\n```\n>在前端项目中经常需要处理 JS 之外的其它资源，包括 css、ts、图片等，此时需要为这些资源配置适当的加载器：\n\n```javascript\n// webpack.config.js\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: \"./src/index\",\n  output: {\n    filename: \"[name].js\",\n    path: path.join(__dirname, \"./dist\"),\n  },\n  module: {\n    rules: [{\n      test: /\\.less$/i,\n      include: {\n        and: [path.join(__dirname, './src/')]\n      },\n      use: [\n        \"style-loader\",\n        \"css-loader\",\n        // \"./loader\",\n        {\n          loader: \"less-loader\",\n        },\n      ],\n    }],\n  },\n};\n```\n\n# 二、脚手架工具\n>对于项目的推进，配置管理将十分困难。所以社区提供了对应的脚手架工具来管理配置。\n\n - [Vue CLI](https://cli.vuejs.org/zh/guide/index.html)：用于帮助用户快速创建、运行 **Vue.js** 项目脚手架的命令行工具；\n - [create-react-app](https://zh-hans.reactjs.org/)：用于创建 **React** 项目脚手架的命令行工具；\n - @[angular/cli](https://angular.io/cli)：用于创建 **angular** 项目的命令行工具；\n - [webpack-cli](https://www.npmjs.com/package/webpack-cli)：Webpack 官方提供的命令行工具，提供了一套交互式生成配置文件的指令集，以及项目编译、开发、迁移等功能；\n - [Neutrino](https://neutrinojs.org/installation/create-new-project/)：用于快速创建、运行现代 JavaScript 应用的工具，同时支持 React、Preact、Vue、Web、Node.js、Library 等场景；\n - [react-starter-kit](https://github.com/kriasoft/react-starter-kit)：用于创建 React + Relay + GraphQL 应用的脚手架工具，内置 SSR 支持。\n\n## 1. Vue CLI 搭建项目脚手架\n>**Vue CLI** 底层调用 Webpack 实现针对 .vue 等资源的编译打包功能；调用 **webpack-dev-server** 实现包含 **HMR** 功能的开发服务器功能；还能通过插件方式整合 **ESLint**、**Babal**、**Less** 等工具。\n\n>安装依赖：（安装完成后 可以使用 vue -V 测试是否安装成功）\n\n```javascript\nnpm install -g @vue/cli\n\n# 或者使用 yarn\nyarn global add @vue/cli\n```\n\n>创建项目：`vue create` 命令 (可使用 `vue create --help` 命令查看 create 的参数列表 `仅限于 vue3中使用`)\n\n```javascript\nvue create 项目名\n```\n\n>执行 create 命令后，CLI 会进一步询问使用何种脚手架方案：\n>通常使用第三种自定义\n\n```javascript\nVue CLI v4.5.15\n? Please pick a preset: (Use arrow keys)\n❯ Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n  Manually select features\n```\n\n>vue2使用 `vue init webpack 项目名` 来构建项目\n>基本回车就行倒数四项根据自身需求来\n\n```javascript\n Project name webpack5-dispose\n? Project description A Vue.js project\n? Author xxx <邮箱>\n? Vue build standalone\n? Install vue-router? Yes\n? Use ESLint to lint your code? No\n? Set up unit tests No\n? Setup e2e tests with Nightwatch? No\n? Should we run `npm install` for you after the project has been created? (recommended) yarn\n```\n>Vue CLI 底层依赖于 Webpack 实现编译打包等工程化能力，开发者可通过 `configureWebpack` 与 `chainWebpack` 配置项修改 Webpack 配置信息。\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  configureWebpack: {\n    plugins: [\n      new MyAwesomeWebpackPlugin()\n    ]\n  }\n}\n```\n>configureWebpack 的配置规则与 Webpack 一致，同样支持 plugins/module/resolve 等配置项。实际上，Vue CLI 内部最终会调用 webpack-merge 将 configureWebpack 值与其它上下文配置合并，生成最终的 Webpack 配置信息。\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule('vue')\n      .use('vue-loader')\n        .tap(options => {\n          // modify the options...\n          return options\n        })\n  }\n}\n```\n\n\n\n>使用 inspect 命令生成完整的 Webpack 配置信息：\n\n```javascript\nvue inspect > output.js\n```\n---\n\n## 2. CRA 搭建项目脚手架\n>使用如下代码可使用CRA创建一个react项目，webStrom创建react项目时可选CRA创建项目\n```javascript\nnpx create-react-app [项目名称]\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3a38afb0ffb947fd8b580b1e20d4c1e6.png)\n\n---\n\n**默认规则创建的脚手架包含如下工程能力：**\n\n - JSX、ES6、TypeScript、Flow 语法支持\n- CSS 自动添加 --webkit-- 前缀\n- 基于 Jest 的自动化测试能力\n- 支持 HMR 的开发服务器\n- 等等\n\n---\n\n>必要时，也可以通过 `npm run eject` 命令导出完整的项目配置结构：\n>注意：可能有未被管理的文件需要先提交在使用该命令\n>会生成对应的配置：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e44bb85aa894d4f94139ec39e9be2e2.png)\n>导出配置后，直接修改 `webpack.config.js` 等相关配置文件即可控制各项功能行为。\n\n---\n\n# 三、如何借助 Babel+TS+ESLint 构建现代 JS 工程环境\n##  1.使用Babel\n>作用：用于将代码向后兼容，在旧版本JS引擎中运行\n>因为ES6提供了许多JS新特性，这就会导致旧版本的**JS**和**Node**等产生兼容性问题，**Babel**就是解决这个问题，它会将代码转译成旧版本的代码，使得旧版本引擎能正常使用。\n\n```javascript\n// 使用 Babel 转译前\narr.map(item => item + 1)\n\n// 转译后\narr.map(function (item){\n  return item + 1;\n})\n```\n>Webpack 场景下，只需使用 `babel-loader` 即可接入 Babel 转译功能：\n\n 1. 安装依赖\n \n\n```javascript\nnpm i -D @babel/core @babel/preset-env babel-loader\n```\n\n 2. 添加模块处理规则\n\n```javascript\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 规则 表示所有.js后缀文件\n        use: ['babel-loader'], // 使用babel-loader处理\n      },\n    ],\n  },\n};\n```\n\n 3. 执行编译命令\n\n```javascript\nnpx webpack\n```\n4. 可以使用 .babelrc 文件或 rule.options 属性配置 Babel 功能逻辑\n\n```javascript\n// 预先安装 @babel/preset-env\n// npm i -D @babel/preset-env\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              presets: ['@babel/preset-env'],\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n```\n>@babel/preset-env是Babel预设规则集----Preset，可以使用各种Preset资源：\n\n - `babel-preset-react`：包含 React 常用插件的规则集，支持 `preset-flow`、`syntax-jsx`、`transform-react-jsx` 等；\n- `@babel/preset-typescript`：用于转译 TypeScript 代码的规则集\n- `@babel/preset-flow`：用于转译 Flow 代码的规则集\n\n###  vue-cli\n>在文件`build/webpack.base.conf.js`中脚手架已经配置了`相关的配置项，但我们依然可以在`webpack.config.js`中修改一些配置\n>`entry`入口文件\n\n```javascript\nentry: {\n    app: './src/main.js'\n  },\n```\n\n>`output`编译产物的目标位置\n```javascript\noutput: {\n    path: config.build.assetsRoot,\n    filename: '[name].js',\n    publicPath: process.env.NODE_ENV === 'production'// 判断是什么环境\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n```\n>`resolve`解析规则\n```javascript\n  resolve: {\n    extensions: ['.js', '.vue', '.json'],//文件扩展名\n    alias: {// 别名\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n```\n>`modele`解析模块\n\n```javascript\n module: {\n    rules: [\n      {\n        test: /\\.vue$/, // 规则过滤条件，这里表示对所有 .vue 后缀文件\n        loader: 'vue-loader',// vue-loader处理\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('img/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('media/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n        }\n      }\n    ]\n  },\n```\n\n###  CRA\n>在`config/webpack.config.js`中已经有脚手架给我门配置的一些\n```javascript\nmodule: {\n    rules: [\n      {\n        test: /\\.js$/,// 声明该规则过滤文件，只有路径和文件类型对应才会生效，此处为所有的 .js 后缀的文件生效\n        loader: 'babel-loader',// 所有命中文件传入Loader序列做转译\n        include: [resolve('src'), resolve('test'), //包内容路径 这里时src和test下的文件  \n        resolve('node_modules/webpack-dev-server/client')]// 以及node_modules中自己的包\n      }\n    ]\n  }\n```\n>不光配置了程序内的文件，还配置了文件外\n\n```javascript\n{\n              test: /\\.(js|mjs)$/,\n              exclude: /@babel(?:\\/|\\\\{1,2})runtime/,\n              loader: require.resolve('babel-loader'),\n              options: {\n                babelrc: false,\n                configFile: false,\n                compact: false,\n                presets: [\n                  [\n                    require.resolve('babel-preset-react-app/dependencies'),\n                    { helpers: true },\n                  ],\n                ],\n                cacheDirectory: true,\n                // See #6846 for context on why cacheCompression is disabled\n                cacheCompression: false,\n                \n                // Babel sourcemaps are needed for debugging into node_modules\n                // code.  Without the options below, debuggers like VSCode\n                // show incorrect code and set breakpoints on the wrong lines.\n                sourceMaps: shouldUseSourceMap,\n                inputSourceMap: shouldUseSourceMap,\n              },\n            },\n```\n\n---\n\n##  2.使用 TypeScript\n>作用：提供了一系列类型约束，能更早的发现错误，确保运行阶段的类型安全性，适合在多人协作的项目中使用。\n\n>**Webpack** 有很多种接入 TypeScript 的方法，包括 `ts-loader`、`awesome-ts-loader`、 `babel-loader`。通常可使用 `ts-loader` 构建 **TypeScript** 代码：\n\n\n>Vue CLi和 CRA均使用`babel-loader`引入TypeScript\n\n 1. 安装依赖\n \n\n```javascript\nnpm i -D @babel/preset-typescript\n```\n2. 配置 Webpack\n\n```javascript\n// 预先安装 @babel/preset-env\n// npm i -D @babel/preset-env\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              presets: ['@babel/preset-typescript'],\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n```\n>`@babel/preset-typescript`只是做了简单的代码转换，未做类型检查等,可以使用其它Preset\n\n--- \n\n##  3.使用 ESLint\n>js作为一种灵活、弱类型脚本语言，对于一些开发过程中产生的语法、类型导致影响稳定的错误，这对开发效率和质量造成影响，**ESLint**就是为了解决这些问题。\n\n>作用：JS代码风格检查器，能将违反规则的代码修复。\n\n>Webpack 下，可以使用 `eslint-webpack-plugin` 接入 ESLint 工具，步骤：\n\n 1. 安装依赖\n \n\n```javascript\n# 安装 webpack 依赖\nyarn add -D webpack webpack-cli\n\n# 安装 eslint \nyarn add -D eslint eslint-webpack-plugin\n\n# 简单起见，这里直接使用 standard 规范\nyarn add -D eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node\n```\n2. 在项目根目录添加 .`eslintrc` 配置文件，内容：\n\n```javascript\n// .eslintrc\n{\n  \"extends\": \"standard\"\n}\n```\n3. 添加 `webpack.config.js` 配置文件，补充 `eslint-webpack-plugin` 配置：\n\n```javascript\n// webpack.config.js\nconst path = require('path')\nconst ESLintPlugin = require('eslint-webpack-plugin')\n\nmodule.exports = {\n  entry: './src/index',\n  mode: 'development',\n  devtool: false,\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  // 添加 eslint-webpack-plugin 插件实例\n  plugins: [new ESLintPlugin()]\n}\n```\n4. 执行编译命令\n\n```javascript\nnpx webpack\n```\n\n>也可以使用第三方扩展来进行特殊的代码风格检测\n\n - `eslint-config-airbnb`：Airbnb 提供的代码风格规则集，算得上 ESLint 生态第一个成名的规则集合\n- `eslint-config-standard`：Standard.js 代码风格规则集，史上最便捷的统一代码风格的方式\n- `eslint-plugin-vue`：实现对 Vue SFC 文件的代码风格检查\n- `eslint-plugin-react`：实现对 React 代码风格检查\n- `@typescript-eslint/eslint-plugin`：实现对 TypeScript 代码风格检查\n- `eslint-plugin-sonarjs`：基于 Sonar 的代码质量检查工具，提供圈复杂度、代码重复率等检测功能\n\n# 总结\n\n本文主要记录了Webpack配置底层逻辑结构以及如何借助Babel、TS、ESLint构建JS环境\n","tags":["前端","Webpack","Babel","ESLint","TypeScript"],"categories":["前端","Webpack"]},{"title":"vue项目各方面的一些优化","url":"/2023/06/30/vue项目的一些优化/","content":"---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n主要记录vue项目的一些优化\n\n---\n\n\n# 一、渲染优化\n##  v-for\n>避免v-if和v-for的同级使用，v-for的优先级比v-if高，会导致数据渲染错误\n\n>v-for设置key的值，尽量不适用index，使用数据中唯一的标识，有利于dom的定位与diff。\n\n---\n##  v-show和v-if的选择\n>经常复用的组件用v-show来渲染（v-show是隐藏不销毁）\n>相反则用v-if（直接判断是否创建）\n\n---\n##  长列表优化\n###  纯粹做数据展示，不需要热更新\n>处于data中的数据会被监视，发生变化时数据就发生变化\n>所以采用object.freeze（数据）方法冻结数据。\n\n\n###  长列表\n>采用虚拟滚动，只渲染少部分区域的内容\n>只渲染视口部分的数据，也就是说渲染的DOM节点个数是固定的\n\n>页面：\n```html\n<template>\n  <div>\n    <div>\n      <span v-if=\"list.length===0\">暂无数据！！！</span>\n      <div v-else class=\"box\" :style=\"`height:${viewH}px;overflow-y:scroll;`\" @scroll=\"handleScroll\">\n        <ul>\n          <li :style=\"`transform:translateY(${offsetY}px); height:${itemH}px;`\" v-for='i in clist' :key=\"i\">{{ i }}</li>\n        </ul>\n      </div>\n    </div>\n    <button @click=\"gotoCSSLongList\" class=\"but\">CssLongList</button>\n  </div>\n</template>\n```\n\n>逻辑：\n\n```javascript\n<script>\nexport default {\n  name: \"LongListOne\",\n  data() {\n    return {\n      list: [],//上万条总数据\n      clist: [],// 页面展示数据\n      viewH: 500, // 可视box高度\n      itemH: 60, // 单项高度\n      scrollH: '', // 整个滚动列表高度\n      showNum: '',//可视化高度一次能装几个列表\n      offsetY: 0// 动态偏移量\n    }\n  },\n  mounted() {\n    for (let index = 0; index < 100000; index++) {// 10万条数据\n      this.list.push(index)\n    }\n    this.scrollH = this.list.length * this.itemH;// 计算总高度\n    // 计算可视化高度一次能装几个列表, 多设置几个防止滚动时候直接替换\n    this.showNum = Math.floor(this.viewH / this.itemH) + 4\n    // 默认展示几个\n    this.clist = this.list.slice(0, this.showNum);\n    this.lastTime = new Date().getTime()\n  },\n  computed: {},\n  methods: {\n    // 滚动监视器\n    handleScroll(e) {\n      let {lastTime,itemH,list}=this\n      if (new Date().getTime() - lastTime > 10) {\n        let scrollTop = e.target.scrollTop // 滚去的高度\n        // 每一次滚动后根据scrollTop值获取一个可以整除itemH结果进行偏移\n        // 例如: 滚动的scrllTop = 1220  1220 % this.itemH = 20  offsetY = 1200\n        this.offsetY = scrollTop - (scrollTop % itemH)\n        //上面卷掉了多少，就要往下平移多少，不然showNum滚出可视区外了\n        this.clist = list.slice(\n          Math.floor(scrollTop / itemH),  // 计算卷入了多少条\n          Math.floor(scrollTop / itemH) + this.showNum\n        )\n        this.lastTime = new Date().getTime()\n      }\n    },\n\n    // 跳转\n    gotoCSSLongList(){\n      this.$router.replace('/CssLongList')\n    }\n  }\n}\n</script>\n```\n>样式：\n\n```javascript\n<style scoped>\n* {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  box-sizing: border-box;\n}\nli {\n  text-align: center;\n  line-height: 60px;\n  border-bottom: 1px solid red;\n}\n.but{\n  height: 40px;\n  width: 100px;\n  margin-top: 10%;\n}\n</style>\n```\n\n####  插件\nvue-virtual-scroller或者vue-virtual-scroll-list\n\n\n####  自己封装\n **1. 数据一次性给：**\n >\n >- 元素监听scroll事件(滚动事件)\n>- 计算可视化高度一次能装几个列表，然后从总数据中进行slice截取\n>- 每一次滚动后根据scrollTop值获取一个可以整除itemH结果进行偏移（scrollTop：滚动条移动的距离）\n\n\n **2. 数据通过请求：**\n\n`代码实现存在点问题修改后再上传`\n \n---\n##  事件销毁\n>Vue组件在销毁时，会自动解绑它的全部指令事件及监听器，但仅限于组件本身。\n>比如定时器等最好在销毁阶段手动销毁，避免内存泄漏\n\n```javascript\ncreated(){\n  this.timer = setInterval(this.refresh,)\n}\n\nbeforeDestroy(){\n  clearInterval(this.timer)\n}\n```\n---\n##  无状态的组件标记为函数式组件（静态组件）\n>只接收父组件传过来的值，自己不做处理，无状态，不创建实例。\n\n>函数组件没有this\n\n```html\n<template functional> // 函数组件\n <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\"></div>\n    <section v-else class=\"off\"></section>\n <div>\n</template >\n```\n\n```javascript\n<script>\n export default {\n  props: ['value']\n}\n</script>\n```\n\n---\n##  子组件分割\n>将子组件中耗时的任务交给组件自己管理，不影响整体页面的加载\n\n```html\n<template>\n <div>\n   <HelloWorld/>\n </div>\n</template>\n<script>\n```\n\n```javascript\nexport default {\n  // 子组件自己管自己\n  HelloWorld:{\n    methods:{\n      heavy(){/* 耗时任务 */}\n    },\n    render(h) {\n      return h('div', this.heavy());\n    }\n  }\n}\n```\n\n---\n\n##  变量本地化\n>减少使用 **this.数据**  的形式获取数据，减少一些不必要的处理\n>用一个变量先获取数据，在这个变量上处理数据。\n\n>在用this.数据 时会有数据劫持，去调用get/set做处理，浪费了时间。\n\n---\n\n##  模块化、组件化\n- 封装高度复用的模块\n- 拆分高度复用的组件\n- 组件可配置性\n\n```xml\n<template>\n// 可配置\n <button\n   :class=\"['mybtn',`btn-${btnStyle}`]\"\n   @click=\"myBtnClick($event)\"\n   v-show=\"btnShow\"\n >\n   <slot></slot>\n </button>\n</template>\n<script>\n\nexport default {\n  name: 'MyBtn',\n  props: {\n    btnStyle: String,\n    btnShow: Boolean\n  },\n  setup (props,ctx){\n    const myBtnClick = (e)=>{\n      ctx.emit('my-btn-click', e);\n    }\n    return{\n      myBtnClick\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.mybtn {\n  border: none;\n  outline: none;\n  height:34px;\n  padding: 0 15px;\n  background-color: #fff;\n  border: 1px solid #fff;\n}\n&.btn-default{\n  color: #333;\n  background-color: #fff;\n  border-color: #ccc;\n}\n&.btn-primary{\n  color: #fff;\n  background-color: #317DEF;\n  border-color: #317DEF;\n}\n</style>\n```\n\n# 二、懒加载\n## 路由懒加载\n```javascript\nconst router = new VueRouter({\n  routes:[\n    {path:'.foo', component: () =>import('./Foo.vue')}\n ]\n})\n```\n---\n## 图片懒加载\n###  运用插件\n>vue-lazyload\n```html\n<img v-lazy=\"图片地址\">\n```\n\n---\n###  自己封装\n`代码完善后上传`\n\n---\n# 三、keep-alive缓存页面\n##  原理\n>在created周期函数（init初始化后）调用时。将需要缓存VNode节点保存 在this.cache中，在渲染页面前调用render函数时。如果VNodedename符合缓存条件（用include和exclude控制），则会从this.cache中取出缓存的VNode实例进行渲染。\n\n##  参数\n- include：字符或者正则表达式。在名称匹配的组件会被渲染。\n- exclude：字符或者正则表达式。在名称匹配的组件不会被渲染。\n- max：数字。最多可以缓存多少个实例。\n\n##  被keep-alive包裹时具有的周期函数\n##  activated\n- keep-alive组件激活时调用\n- 服务器端渲染不被调用\n\n##  deactivated\n- keep-alive组件停用时调用\n- 服务器渲染期间不调用\n\n##  注意\n- keep-alive会将数据保留在内存中，如果要获取最新数据，则要在activated钩子函数中获取。 \n- include需要的name是组件的name\n- 在多级嵌套兄弟页面时，缓存其中一个页面时会将父级都缓存了，导致所有子页面都缓存了，这时需要手动销毁其它兄弟页面。\n\n```javascript\n<keep-alive>    \n<router-view v-if=\"$route.meta.keepAlive\"></router-view></keep-alive>\n// 销毁不需要的兄弟组件\n<router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n```\n\n##  使用场景\n>如需要在不同组件切换时某个组件需要不改变\n>如：搜索框在输入文字后，切换组件时，输入框文字不消失，返回也不消失。\n\n##  使用方法\n###  使用属性include和exclude\n\n```javascript\n// 只缓存名字为home的组件\n<keep-alive include=\"home\">\n   <router-view />\n</keep-alive>\n```\n\n```java\n// 缓存整个组件\n<keep-alive>\n   <router-view />\n</keep-alive>\n```\n\n###  路由中meta属性来控缓存\n\n```javascript\n// meta属性中keepAlive值设为true\n{\n      path: '/',\n      name: 'home',\n      meta:{\n        keepAlive:true\n      },\n      component: Home\n    }\n```\n\n```javascript\n// 配合 keep-alive进行控制缓存\n<keep-alive>\n      <router-view v-if=\"$route.meta.keepAlive\" />\n</keep-alive>\n```\n\n##  存在的问题\n>组件被缓存后，不存在销毁阶段，在组件切换时，不会调用created等生命周期函数，导致数据不能及时更新。\n\n**解决方法：**\n>使用提供的activated与deactivated函数来获取当前组件是否活跃。\n>在activated函数中获取数据，更新数据（被缓存的组件才会有这两个函数）\n\n\n# 四、打包优化\n## 1.引入库\n>按需引入，避免体积过大\n\n```javascript\nimport {Button , selet}from 'element-ui';\n```\n---\n## 2.引入资源\n>插件cdn、图片cdn、使用CSS图标\n>减少项目体积\n\n---\n## 3.打包配置\n>位置：build/config/index.js \n>属性：productionGzip:  true\n >作用：打包压缩\n\n>位置：truebuild/config/index.js  \n>属性：productionSourceMap: false \n >作用：减小打包体积 定位源码的会生成map文件 可能造成源码泄露\n\n---\n# 五、首屏优化\n## 数据加载使用loding骨架屏\n>在数据加载阶段擦用骨架屏可以给用户带来更好的体验\n\n---\n\n## 首屏采用**SSR**服务端渲染\n- 客户端发送请求给服务器\n- 服务器读取模板，解析成dom节点，返回一个完整的首屏html结构\n- 客户端进行首屏激活（把用户写的交互的代码，在前端激活，重新变成一个spa应用）\n- 这样后续，用户再点击超链接、跳转时，不会再向服务器发送请求了，而是使用前端路由跳转，只会发送一些ajax请求数据\n\n---\n## 使用web worker\n###  作用\n>让JS实现多线程\n\n>给JS创造多线程运行环境，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰，在worker线程运行结束后把结果返回给主线程。\n\n>这并不意味着JS语言本身支持了多线程能力，而是浏览器作为宿主环境提供了JS一个多线程运行的环境。\n\n###  使用\n>Worker()构造函数，第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\n\n```javascript\nvar myWorker = new Worker(jsUrl, options)\n```\n\n###  使用场景\n1. 加密数据\n有些加解密的算法比较复杂，或者在加解密很多数据的时候，这会非常耗费计算资源，导致UI线程无响应，因此这是使用Web Worker的好时机，使用Worker线程可以让用户更加无缝的操作UI。\n\n2. 预取数据\n有时候为了提升数据加载速度，可以提前使用Worker线程获取数据，因为Worker线程是可以是用 XMLHttpRequest 的。\n\n3. 预渲染\n在某些渲染场景下，比如渲染复杂的canvas的时候需要计算的效果比如反射、折射、光影、材料等，这些计算的逻辑可以使用Worker线程来执行，也可以使用多个Worker线程，这里有个射线追踪的示例。\n\n4. 复杂数据处理场景\n某些检索、排序、过滤、分析会非常耗费时间，这时可以使用Web Worker来进行，不占用主线程。\n\n5. 预加载图片\n有时候一个页面有很多图片，或者有几个很大的图片的时候，如果业务限制不考虑懒加载，也可以使用Web Worker来加载图片，可以参考一下这篇文章的探索，这里简单提要一下。\n\n---\n##  优化webpackp配置\n- webpackp的code-split结合vue-router做懒加载\n- webpackp的conthash模式针对文件级别更改做缓存\n# 总结\n以上记录了vue在各个方面的优化，对于webpackp的优化在学完webpackp后完善\n\n","tags":["Vue","优化"],"categories":["Vue","前端","优化"]},{"title":"Vue的生命周期，各个组件间的执行情况","url":"/2023/06/30/Vue生命周期及各组件间的执行情况/","content":"\n\n\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\nVue的生命周期，各个组件间的执行情况。\n`注：本文是以Vue2.x版本展开叙述`\n\n\n---\n\n\n# 一、Vue的生命周期是什么？\nVue的组件都是独立存在的，每个组件都要经历他自己的`生命周期`。Vue的生命周期是指组件：\n**创建**--->**数据初始化**--->**挂载**--->**更新**--->**销毁**\n简单的来说就是组件从创建到销毁之间的过程\n\n\n# 二、Vue生命周期中具体过程\n## 1.Vue生命周期中的函数\n**生命周期钩子**也叫**生命周期函数**也叫**生命周期事件**，vue中他自己携带了八个生命周期函数，如下：\n### 创建Vue实例期阶段：\n\n - **beforeCreate：**\n 实例刚在内存中被创建出来，此时，还没有初始化完成data和methods属性。\n\n- **created：**\n实例已经在内存中创建完成，此时data和menthods以及创建完成，但没有开始编译模板。\n- **beforeMount：**\n此时完成了模板的编译，但没有进行挂载。\n- **mounted：**\n此时已经完成挂载到指定容器中显示了。\n### 运行阶段：\n- **beforeUpdate：**\n状态更新之前调用此函数，此时data中的状态值是最新的，但在界面上并没有得到更新，还没有开始重新渲染DOM节点。\n- **updated：**\n实例更新完成后调用此函数，此时以及重新渲染好DOM节点，界面显示数据也是最新的。\n### 销毁阶段：\n- **beforeDestroy：**\n实例 销毁前调用的函数，此时，实力还是完全可用的。\n- **destroyed：**\n实例销毁后调用，实例锁指示的所有东西都将解绑，所有监听器将移除，所有子实例也将销毁。\n>生命周期流程图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/27c2330b888345dba3fec82144bb8306.png#pic_center)\n\n\n>代码演示：\n\n```c\n var app = new Vue({\n        el: \"#app\",\n        data: {\n            message: \"Hello Vue!\"\n        },\n        methods: {\n            changeMessage() {\n                this.message='改变了！'\n            }\n        },\n        beforeCreate() {\n            console.log(\"---------- 初始化前 beforeCreate-----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n            \n        },\n        created() {\n            console.log(\"---------- 初始化完成 created----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeMount() {\n            console.log(\"---------- 挂载前 beforeMount----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        mounted() {\n            console.log(\"---------- 挂载完成 mounted----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeUpdate() {\n            console.log(\"---------- 更新前 beforeUpdate----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        updated() {\n            console.log(\"---------- 更新完成 updated----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        }\n    });\n```\n>创建阶段运行结果：\n>\n![](https://img-blog.csdnimg.cn/d3c052cebaad48329c13c55b72f25f23.png)\n**可以看到首次加载只会运行前四个周期函数，在挂载前才能拿到el属性，如果要操作DOM节点最早在挂在完成 mounted中操作。**\n>运行阶段运行结果：\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b1907c6374949568f14cccd17df1bbe.png)\n## 2.加入keep-alive后\n### 1）keep-alive的认识：\n\n是vue自带的内部组件，是用**来缓存组件**的，达到**提升性能**的目的。\n当使用keep-alive后会增加两个生命周期函数：\n- activated\n在 **keep-alive 组件激活**时调用， 该钩子函数在**服务器端渲染期间**不被调用。\n承担原来**created**钩子中获取数据的任务\n在第一次进入keep-alive包裹的组件时，会调用 beforeCreate、created、beforeMount、mounted、activated；这五个生命周期函数。\n当第二次或第n次进入时只会调用activated\n\n- deactivated\n在 keep-alive 组件停用时调用，该钩子在服务器端渲染期间不被调用。\n\n### 2）keep-alive的用法：\nProps有三个include、exclude、max。\n  - include\n  使用字符串或者正则表达式，匹配的组件才会被缓存\n  - exclude\n  使用字符串或者正则表达式，匹配的组件都不会被缓存\n  - max\n  以数字的形式记录可以缓存多少个组件实例，到达这个值后再次缓存时将销毁最久未使用的组件实例。\n\n### 3）keep-alive的一些使用心得：\n - 在组件实例中，通过beforeRouteEnter(to, from, next)路由守卫，来判断路由是从哪里跳转的，如果是从详情页跳转的，则将当前路由对象的meta.isBack 设置为true,否则设为false\n```javascript\n  beforeRouteEnter(to, from, next) {\n    if (from.path == \"/detail\") {\n      to.meta.isBack = true;\n    } else {\n      to.meta.isBack = false;\n    }\n    next();\n  }\n```\n- 为了在其他页面进入时，更新页面中的列表数据，我们将在activated钩子函数中挂载页面初次进入时的请求数据：\n```javascript\n   activated() {\n    if (!this.$route.meta.isBack) {\n        this.list = [];\n        this.pageNum = 1;\n        this.getList();\n    }\n    this.$route.meta.isBack = false;\n}\n```\n\n# 各组件间的执行情况\n## 1.加载渲染过程\n\n>过程：\n>**父组件beforeCreate** --> **父组件created** --> **父组件beforeMount** --> **子组件beforeCreate** --> **子组件created** --> **子组件beforeMount** --> **子组件mounted** --> **父组件mounted**\n## 2.子组件更新过程\n>过程：\n> **子组件beforeUpdate**  -->  **子组件updated**  \n## 3.父组件更新过程\n>**父组件beforeUpdate**  -->  **父组件updated**\n## 4.组件销毁过程\n>**父组件beforeDestroy** --> **子组件beforeDestroy** --> **子组件destroyed** --> **父组件destroyed**\n## 5.过程演示\n> 父组件代码\n\n```javascript\n<template>\n  <div style=\"border: 2px #1E1E1E; height: 500px;width: 500px;background-color: blueviolet; text-align: center\">\n    <span>{{message}}</span>\n    <button @click=\"changef\" >父组件改变</button>\n    <Son></Son>\n    <button @click=\"destroy\">点击销毁</button>\n  </div>\n</template>\n\n<script>\nimport Son from './components/Son.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    Son\n  },\n  data() {\n    return {\n      message: \"父组件\"\n    }\n  },\n  methods: {\n    changef(){\n      this.message='父组件改变了'\n    },\n    destroy(){\n      this.$destroy();\n      console.log('销毁完成');\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 父组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 父组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 父组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 父组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 父组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 父组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 父组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 父组件销毁后 destroyed----------')\n  }\n}\n</script>\n\n```\n> 子组件代码\n\n```javascript\n<template>\n  <div>\n    <div style=\"border: 2px #1E1E1E; height: 200px;width:200px;background-color: aqua;\">\n      <span>{{message}}</span>\n      <button @click=\"changes\">子组件改变</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  // eslint-disable-next-line vue/multi-word-component-names\n  name: 'Son',\n  props: {\n\n  },\n  data() {\n    return {\n      message: \"子组件\"\n    }\n  },\n  methods: {\n    changes(){\n      this.message='子组件改变了'\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 子组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 子组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 子组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 子组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 子组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 子组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 子组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 子组件销毁后 destroyed----------')\n  }\n}\n</script>\n```\n\n>加载渲染：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1e0fc120774141659a13fc399163e525.png)\n\n>更新阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/1dbd838712ba4a6cbbb50f8b26c45ef9.png)\n\n>销毁阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/11c316d9bff44e798c70517f11209b53.png)\n# 总结\n - 生命周期：\n   - 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n    -   是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n    -   生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n     -  生命周期函数中的this指向是vm 或 组件实例对象。\n ---\n- 常用的生命周期钩子：\n   -  mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n   - beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n   \n---\n- 关于销毁Vue实例：\n   - 销毁后借助Vue开发者工具看不到任何信息。\n   - 销毁后自定义事件会失效，但原生DOM事件依然有效。\n   - 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n","tags":["Vue","生命周期","组件"],"categories":["Vue","前端"]},{"title":"Vue模板语法","url":"/2023/06/30/Vue模板语法/","content":"\n\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n在Vue中，模板语法 的使用是频繁的。\n\n\n---\n\n\n# 一、插值\n## 1.插值语法\n插值语法用于文本的插入，数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：\n\n```javascript\n<span>Message: {{ msg }}</span>\n```\nMustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。也就是数据的动态绑定。\n值得注意的是插值语法中可以使用JavaScript的表达式。\n主要用于解析标签体内容。\n## 2.指令语法\n用于解析标签（标签属性、标签体内容、绑定事件...）\n### （1）数据绑定指令\n#### v-bind:(单向数据绑定)\n v-bind指令可以用于响应式地更新 HTML attribute。\ndata中的数据改变可以影响页面数据，但反过来不行。\n```javascript\n<a v-bind:href=\"url\">...</a>\n```\n其中href为参数，url是绑定的值，该指令也可以简写为“：”\n\n```javascript\n<a :href=\"url\">...</a>\n```\n#### v-model:双向数据绑定)\n该指令只能用于表单类元素（input、select等），也就是拥有value的标签，v-model实际上是通过标签value值来控制标签内容。\n\n```javascript\n<input type=‘button' v-model:value='name'/>\n```\n>也可以简写为：\n\n```javascript\n<input type=‘button' v-model='name'/>\n```\n\n改变输入框的值也会 影响data中的值，反过来也可以。\n### （2）事件监听指令\n#### v-on:(事件监听）\n用于事件的触发监听来执行对应的JS表达式。\n\n```javascript\n<input type=‘button' v-on:click='num++'/>\n```\n监听了点击事件使num每点击一下+1，也可以是一个函数\n\n```javascript\n<button v-on:click='say()'>Say hi</button>\n```\n该指令也可以简写为“@”\n\n```javascript\n<input type=‘button' @click='num++'/>\n```\n### （3）条件渲染指令\n#### v-if、v-else-if、v-else\n和判断相同根据表达式值在DOM中渲染或销毁元素或组件\nv-else是没有判断条件的，如果你加上去不会影响得到的结果\n```javascript\n  <p v-if=\"flag===‘晴’\">今天大晴天</p>\n  <p v-else-if=\"flag==='多云'\">今天多云</p>\n  <p v-else>今天下雨</p>\n```\n\n#### v-show\n和v-if类似，根据表达式的值控制标签或者组件的显示与隐藏。\n\n```javascript\n  <p v-show=\"flag\">今天要下雨</p>\n  <p v-show=\"!flag\">今天不要下雨</p>\n```\n### （4）内容渲染指令\n#### v-text\nv-text用法简单，只能用来渲染纯文本内容，如下：\n\n```javascript\n<p v-text=\"username\"></p>\n```\n他的缺点是他会直接覆盖掉原来标签里的内容。\n\n---\n\n#### v-html\n如果要渲染带包含html标签的内容，可以使用v-html\n\n```javascript\n<div v-html=\"content\"></div>\n\nconst vm = new Vue({\n            el: \"#app\",\n            data: {\n                content: \"<h1>你好</h1>\"\n            }\n        })\n```\n\n### （5）列表渲染指令\n#### v-for\n需要生成多个某个标签，就可以在该标签上加入v-for进行动态生成,v-for可以遍历**数组、对象、字符串以及指定次数**（将in或of后边换成数字即可）,v-for可以接收两个参数，其中第一个为每一项，第二个是当前索引值。\n具体语法如下：\n\n```javascript\n<ul>\n<li v-for=\"（item,inex） in 某个数据集合\" :key=\"index\">\n{{形参.数据集合的属性}}\n</li>\n</ul>\n```\nin也可以换成of，某些版本可能不行\n对于绑定的key（标识符）的使用存在着一些问题，后面可能会在其它文章中体现。\n## 指令间的小tips\n### 1.v-if和v-show\n\n\n  **（1）v-if和v-show的区别**：\n \n - v-if控制元素是否渲染到页面（是否创建）\n - v-show控制元素是否显示（已经创建，是否显示）\n \n **（2）v-if和v-show如何选择**：\n - 当频繁的切换显隐时使用v-show\n - 只有一次的切换时使用v-if\n \n###  2.v-if和v-for\nv-if的优先级是没有v-for的高的，也就是说将两个指令用在同一个标签上时，会先进行循环，再进行判断。\n这样做会导致性能受到影响。\n在源码中可以发现，他判断的顺序是：once-->for-->if(也就不难理解为什么for的优先级会比if高了)\n```javascript\nexport function genElement(el: ASTElement, state: CodegenState): string {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre\n  }\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      let data\n      const maybeComponent = state.maybeComponent(el)\n      if (!el.plain || (el.pre && maybeComponent)) {\n        data = genData(el, state)\n      }\n\n      let tag: string | undefined\n      // check if this is a component in <script setup>\n      const bindings = state.options.bindings\n      if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {\n        tag = checkBindingType(bindings, el.tag)\n      }\n      if (!tag) tag = `'${el.tag}'`\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c(${tag}${\n        data ? `,${data}` : '' // data\n      }${\n        children ? `,${children}` : '' // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n```\n\n如果想一起使用，可以在标签外层嵌套一层，将v-if绑定在外层。\n###  3.v-on事件修饰符\n事件修饰符可以多个一起用（如：事件.prevent.stop）。\n- @事件.prevent:阻止默认事件\n- @事件.stop:阻止事件冒泡（在包含关系中不同标签上有相同的触发函数，导致这两个被关联起来）\n- @事件.once:事件只触发一次\n- @事件.capture：使用事件捕获模式\n- @事件.self：只有event.target是当前操作的元素才触发事件\n- @事件.passive：事件的默认行为立即执行，无需等待事件回调执行\n\n###  3.v-on键盘事件\n@keyup:按键放开触发\n@keydown：按键按下触发\n\n几个按键也可以同时使用（如：@keyup.ctrl.y）。\n\n根据按键触发:\n**@keyup.按键别名**\n\n常用按键别名：\n\n - 回车：enter\n - 删除：delete\n - 退出：esc\n - 空格：space\n - 换行：tab（只能配合@keydown中使用）\n - 上：up\n - 下：down\n - 左：left\n - 右：right\n\n---\n获取按键名称或者编码：\n\n```javascript\nshow(e){//事件调用函数\ne.key;//按键名称\ne.keyCode;//按键编码\n}\n```\n\n---\n系统修饰键（特殊）：**ctrl、alt、shift、meta**\n配合keyup使用时必须同时按下其它键，释放后才会触发，keydown中正常。\n\n---\nVue自定义别名按键\n**Vue.config.keyCodes.自定义键名=键码；**\n# 总结\n\n\n以上就是今天要讲的内容，本文简单介绍了Vue的模板语法，以及常用的指令语法\n\n","tags":["Vue","指令语法"],"categories":["Vue","前端","指令"]},{"title":"React入门","url":"/2023/06/30/React入门/","content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n\n# 前言\n\nReact是一个用于构建用户界面的JavaScript库,用来为现代的网络构建用户界面。\n\nReact框架可以用[Antd Table](https://ant.design/components/cascader-cn/)\n\n本次学习使用的**React**版本为**18.1.0**\n```c\n\"dependencies\": {\n    \"react\": \"^18.1.0\",\n    \"react-dom\": \"^18.1.0\"\n  }\n```\n---\n\n\n# 一、React的特点\n\n- 虚拟DOM\n- 声明式\n- 基于组件\n- 支持服务器渲染\n- 快速、简单、易学\n\n# 二、HelloReact\n## 1.引入库\n开发web项目，引入两个JS脚本\n\n- **react.js**\nreact.js是react核心库，只要使用react就必须引入\n- **react-dom.js** \n用来管理Dom操作的库。开发web应用必备\n\n## 2.创建React元素\n>**React.createElement()**;\n>-用来创建React元素\n>-参数：\n>     1.元素名\n>     2.元素中的属性\n>     3.元素的子元素（内容）\n代码如下：\n\n```c\nconst div=React.createElement('div',{},'我是div');\n```\n## 3.获取根元素对应的React元素\n>**ReactDOM.createRoot();**\n>需要一个DOM元素作为参数\n\n代码如下：\n\n```c\nconst root=ReactDOM.createRoot(document.getElementById('root');\n```\n\n## 4.渲染React元素到根元素\n\n代码如下：\n\n```c\nroot.render(div);;\n```\n\n---\n\n# 三、3个API\n## 1.React.createElement()\n- React.createElement(type,[props],[...children])\n    参数：\n    1.元素名称（html标签必须小写）\n    2.标签属性\n       设置事件时，属性名需要修改为驼峰命名法,\n    3.标签内容\n- 用来创建React元素\n- React元素无法修改\n## 2.ReactDOM.createRoot()\n- ReactDOM.createRoot(container[,options])\n- 用来创建React的跟容器，容器用来放置React元素\n## 3.root.render()\n- root.render(element)\n- 当首次调用时，容器节点里的所有DOM元素都会被替换，后续的调用则会使用React的DOM差分算法(DOM diffing algorithm)进行高效更新。\n- 不会修改容器节点（只会修改容器的子节点）。可以 在不覆盖现有子节点的情况下，将组件插入已有的DOM节点内。\n# 总结\n\n\n\n\n","tags":["前端","react","API"],"categories":["React","前端"]},{"title":"替换空格","url":"/2023/06/30/offer替换空格/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\n\n限制：0 <= s 的长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>解题思路：在JAVA中字符串是不可更改的，所以通过字符串每个字符的对比来在StringBuilder中加入字符遇到空格就加入'%20'\n\n\n   >  在c中利用字符数组可更改的性质，统计字符串中空格数，新字符长度就为=原字符长度（不包含空格）+空格数*2；用双指针分别指向原字符串最后和新字符串最后，往前寻找并复制不为空格的字符，遇到空格新字符串\n            指针依次往前三格加入‘0’，‘2’，‘%’，直到空格数为零，原指针停止，指针相遇就结束。\n## 1.JAVA：\n```java\npublic static String replaceSpace(String s) {\n        if(s==null)return null;\n        StringBuilder sb=new StringBuilder();\n        for (int i=0;i<s.length();i++){\n            if (s.charAt(i) == ' ') {\n                sb.append(\"%20\");\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n```\n\n\n---\n\n## 2.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/951d0fe3b4254020b0b4f57508baea9b.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/submissions/)\n","tags":["算法","简单","offer","力扣","字符串","栈"],"categories":["力扣","字符串"]},{"title":"offer整数除法","url":"/2023/06/30/offer整数除法/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。\n注意：\n\n - 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1\n\n---\n\n# 例子\n\n示例 1：\n输入: a = \"11\", b = \"10\"\n输出: \"101\"\n解释：15/2 = truncate(7.5) = 7\n\n示例 2：\n输入：a = 7, b = -3\n输出：-2\n解释：7/-3 = truncate(-2.33333..) = -2\n\n示例 3：\n输入：a = 0, b = 1\n输出：0\n\n示例 4：\n输入：a = 1, b = 1\n输出：1\n\n---\n# 提示：\n\n- -231 <= a, b <= 231 - 1\n- b != 0\n\n---\n\n\n# 代码实现：\n## 1.O（n）：\n>用a不断的减去b，然后累加次数，就是结论，但是要考虑越界问题，所以把两个数全弄成负数，再考虑边界问题单独解决\n```java\nclass Solution {\n    public int divide(int a, int b) {\n     // 32 位最大值：2^31 - 1 = 2147483647\n    // 32 位最小值：-2^31 = -2147483648\n    // -2147483648 / (-1) = 2147483648 > 2147483647 越界了\n    if (a == Integer.MIN_VALUE && b == -1)\n        return Integer.MAX_VALUE;\n    int sign = (a > 0) ^ (b > 0) ? -1 : 1;\n    /\n    if (a > 0) a = -a;\n    if (b > 0) b = -b;\n    int res = 0;\n    while (a <= b) {\n        a -= b;\n        res++;\n    }\n    // 因为不能使用乘号，所以将乘号换成三目运算符\n    return sign == 1 ? res : -res;\n\n作者：tangweiqun\n链接：https://leetcode.cn/problems/xoh6Oh/solution/jian-dan-yi-dong-javac-pythonjs-zheng-sh-e8r6/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n    }\n}\n```\n## 2.常数级别（31次循环）：\n>和上面一样，思路就是每次用减法来计算，但是是从最大的数开始找，也就是从2^31（最大）开始找，如果不够将2的指数依次减小，\n```java\nclass Solution {\n    public int divide(int a, int b) {\n       if (a == Integer.MIN_VALUE && b == -1) {\n            return Integer.MAX_VALUE;\n        }\n        int symbol=(a>0)^(b>0)?-1:1;// 符号判断\n        a=Math.abs(a);\n        b=Math.abs(b);\n        int res=0;\n        for(int i=31;i>=0;i--){\n            //右移避免越界\n            // >>>无符号右移， -2147483648看成正的2147483648\n            if ((a>>>i)-b>=0){// 和a>=(b<<i)一样但是有可能越界\n                a-=(b<<i);\n                res+=(1<<i);// 累加结果\n            }\n        }\n        return symbol==1?res:-res;\n    }\n}\n\n```\n\n\n\n```\n\n题目来源：力扣（LeetCode）\n[LeetCode题目](https://leetcode.cn/problems/xoh6Oh/?plan=lcof&plan_progress=gdsixbt)\n","tags":["算法","简单","offer","力扣"],"categories":["力扣","整数"]},{"title":"反转链表","url":"/2023/06/30/offer反转链表/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n限制：\n0 <= 节点个数 <= 5000\n\n\n---\n\n# 例子\n\n示例 1：\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n---\n# 提示：\n无\n\n\n---\n\n\n# 代码实现：\n>利用辅助数组将数记录并计数，然后再将数组中的值从末尾赋值给返回链表，在赋值时要记录下头结点\n>迭代利用指向下一个结点的指针反向指向上一个结点，在左这一步操作时应记录好先前当前结点的下一个结点。\n## 1.辅助数组：\n>时间复杂度为O(n)，空间复杂度为O(5001)\n```java\npublic static ListNode reverseList(ListNode head) {\n        if (head==null) return null;\n        int[] aid =new int[5001];//辅助数组\n        int i=0;\n        while (head!=null){// 将链表值赋给数组并计数\n            aid[++i]= head.val;\n            head=head.next;\n        }\n        ListNode res= new ListNode(aid[i]);// 返回的链表\n        ListNode temp=res;// 记录头结点\n        i-=1;// 去掉头结点\n        while (i>0){// 将数组中的值赋给链表\n            if (res.next==null){\n                res.next=new ListNode(aid[i]);\n            }\n            res=res.next;\n            i--;\n        }\n        res=temp;\n        //res.plant(res);\n        return res;\n    }\n```\n## 2.迭代：\n时间复杂度为O（n），空间复杂度为O（1）\n\n```java\n public static ListNode reverseList2(ListNode head) {\n        if (head==null||head.next==null) return head;\n       ListNode res=null;// 返回链表\n        while (head!=null){\n            ListNode temp=head.next;// 辅助结点\n            head.next=res;// 翻转\n            res=head;\n            head=temp;\n        }\n       // res.plant(res);\n        return res;\n    }\n\n```\n\n## 运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf33725d88574d9392e283e180885752.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)\n","tags":["算法","数组","简单","offer","力扣","链表"],"categories":["力扣","链表"]},{"title":"JS运行机制 Vue全局API nextTick源码分析","url":"/2023/06/30/JS运行机制 Vue全局API nextTick源码分析/","content":"\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n\nVue中nextTick的实现原理和对源码的分析。\n\n---\n\n\n\n# 一、nextTick是什么？\n\n官方文档中，提到nextTick是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n在Vue开发时，有没有遇到这样的情况，在改了data里的数据后获取DOM时里边的值竟然还是原来的值，甚至在循环中，这次获取的DOM永远是上一次的状态，但页面明明都变了呀，但是在使用nextTick后这种情况的到解决，简直摸不到头脑。\n不过，在查看nextTick源码，还有网上的相关资料后，豁然开朗。\n有意思的是官方文档还标注了：\n\n> 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\n\nIE躺着也中枪，源码中确实也体现了官方的这句话。\n\n# 二、为什么会出现这种情况\n## 1.JS的运行机制？\n神XX机制，我真的会谢，能用就行呗，哈哈哈哈，开玩笑，开玩笑。\n说起JS运行机制，还真没了解过，趁这个机会，好好了解一下。\n\n### （1）JS运行机制流程\nJS的执行竟然是单线程的，我不知道，这是为什么，可能是机制吧，他是靠事件循环来执行。具体流程如下：\n\n---\n 1. 在主线程运行时，会形成执行栈，栈中在执行过程中遇到任务源，将任务源中的回调函数加入到任务队列中\n 2. 执行栈执行完成后，会将任务队列中的回调函数放入执行栈依次执行。\n ---\n 经过反复循环这两个操作，就变成了事件循环。\n### （2）同步、异步执行过程\n同（1）中所讲一致，不过**同步任务**是直接放到执行栈中执行，异步任务只能看着，突然发现还有一个**任务队列**，异步任务赶紧把自己的**任务**给他，让任务队列在同步执行**完成后**喊他。\n\n#### 任务：\n在任务里边也有分类，分为**宏任务**和**微任务**\n##### 宏任务：\n- 在宏任务执行过程中，可以创建宏任务加到宏任务队列的最后等待下一次循环执行；也可以创建微任务，加入到本次宏任务下微任务队列的最后，会在本次宏任务结束后顺序执行。（每个宏任务都有个微任务队列）\n- 在本次宏任务执行完成后，这时候才去执行宏任务下的微任务队列，微任务结束后，算一个task执行完成。\n- **在一个task执行完成，页面会进行渲染，然后进入下一个task。**（Event loop）\n- 常见的宏任务：`setTimeout, setInterval, requestAnimationFrame, I/O, script标签内代码，setImmediate`等。\n\n##### 微任务：\n- 微任务创建的宏任务，会被加入到宏任务队列的最后。\n- 微任务创建的微任务会被加入到微任务队列的最后，微任务会在本次task中执行完成。\n- 常见的微任务有：\t`Promise callback， Promise.then，MutationObserver`\n##### 解释场景问题\n到这，大家应该知道为啥获取DOM的状态是上一次的吧，是因为渲染DOM都是异步进行的，在更改数据时，Vue开启了事件队列，数据更改的任务被推进了任务队列，在此时依赖了DOM时获取的肯定是上一次DOM状态，因为那时候DOM还没到重新渲染，只不过这个时间太短，你感觉不出来。\n\n# 三、nextTick源码分析\n## 1.浏览器能力？\nnextTick执行延迟回调，如何实现这个功能，这可离不开浏览器的能力，浏览器的能力决定了nextTick以什么样的方式去实现这个功能，说白了就是最大限度提升性能。\n### 如何判断浏览器能力？\n`微任务的耗时是小于宏任务的`\n- 当然是if（）喽，首先去判断支不支持Promise，在其中把回调函数队列给Promise.then，然后就创建了微任务，值得注意的是在IOS中支持Promise，但他队列不更新，所以要加个空的任务强制刷新下队列。\n\n- 如果不支持Promise也没关系，他会去找有没有原生的MutationObserver的API（ES5中检测DOM节点变化的API），显然它创建的也是个微任务\n- 实在不行就来到了setImmediate，IE可以直接跳过前两个直接来到这，因为自身条件不达标，从这个开始创建的是宏任务了。\n- 最不推荐的就是setTimeout了，他是最慢的。\n\n```javascript\n// 判断浏览器的能力：\n// 顺序：Promise-->MutationObserver-->setImmediate-->setTimeout\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop) // ios具备promise但不会更新队列信息，所以强制加入一个空计时器，强制刷新。\n  }\n  isUsingMicroTask = true\n} else if ( //接下来就是判断有没有原生的MutationObserver，用来检测DOM树变化的API。\n  !isIE &&\n  typeof MutationObserver !== 'undefined' &&\n  (isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]')\n) {\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  // 靠MutationObserver中characterData属性去观察目标节点（textNode）下所有文本类型节点（即子代或后代）的文字变化\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n  // 然后是setImmediate 前两个都是创建微任务，但从这个开始就是创建宏任务了\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  // 最后推荐的是setTimeout，宏任务间也是有差距的\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n```\n## 2.回调队列函数\n回调队列函数中很简单，上锁和循环执行回调队列，\n\n```javascript\n// 执行回调队列函数\nfunction flushCallbacks() {\n  pending = false //重置异步锁\n  // 将回调函数队列复制并清空回调函数队列。防止nextTick中套娃出现错误，防止在回调函数中调用nextTick时将其回调函数加入到这个队列中，也就是不会开启多个异步任务。\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n```\n## 3.nextTick主体\n- 将传进来的回调函数推入对调队列中，再判断异步锁是否上锁，如果未上锁就在上锁后执行异步函数创建异步任务等待同步任务执行完成。\n- 如果没有回调，则在支持Promise的情况下返回一个Promise（IE无语）\n\n```javascript\nexport function nextTick(cb?: (...args: any[]) => any, ctx?: object) {\n  let _resolve\n  // 将回调函数推入回调队列\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e: any) {\n      // 发生错误时，回滚并调用全局API handleError获取错误信息\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  // 如果异步锁未上锁，则锁上异步锁，调用异步函数等待同步函数完成\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n  // $flow-disable-line\n  // 如果没有回调并且支持Promise则返回一个Promise\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n```\n\n# 总结\n\n以上就是今天记录的内容，本文对JS的运行机制和nextTick原理进行了分析，其次除了nextTick外，可以用$forceUpdate ，强制更新，他只会影响到实例本身和插入插槽内容的子组件。\n\n","tags":["JS","API","Vue","源码"],"categories":["JS","Vue","前端"]},{"title":"一些JS的插件库","url":"/2023/06/30/js插件库/","content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n1、[airbnb/lottie-web](https://github.com/airbnb/lottie-web)\n\n一个可以从Adobe After Effects中创建的动画直接导出到你的网站。\n\n适用于Lottie for Web，[Android](https://github.com/airbnb/lottie-android)，[iOS](https://github.com/airbnb/lottie-ios)，[React Native](https://github.com/airbnb/lottie-react-native)和[Windows。](https://aka.ms/lottie)\n\n例子：\n\n![Example4.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example4.gif?raw=true)\n\n![Example2.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example2.gif?raw=true)\n\n\n\n![Community 2_3.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Community%202_3.gif?raw=true)\n\n2、[wagerfield/parallax](https://github.com/wagerfield/parallax)\n\n一个轻量级视差渲染JS库，可以创建视察效果，用鼠标来控制，还可以调整物体移动速度。\n\n示例网站：[parallax.js (wagerfield.com)](http://matthew.wagerfield.com/parallax/)\n\n\n\n3、[e-oj/Magic-Grid](https://github.com/e-oj/Magic-Grid)\n\n一个简单、轻量级的 Javascript 库，用于动态网格布局\n\n效果：\n\n![Magic-Gridv](http://imgconvert.csdnimg.cn/aHR0cHM6Ly92dWVqc2V4YW1wbGVzLmNvbS9jb250ZW50L2ltYWdlcy8yMDE5LzAxL01hZ2ljLUdyaWR2LmdpZg)\n\n\n\n4、[webslides/WebSlides](https://github.com/webslides/WebSlides)\n\n以漂亮的方式制作HTML演示文稿\n\n演示网站：https://webslides.tv/demos.\n\n\n\n5、[svgdotjs/svg.js](https://github.com/svgdotjs/svg.js)\n\n用于操作 SVG 和制作动画的轻量级库，无需任何依赖项。\n\n\n\n6、[dixonandmoe/rellax](https://github.com/dixonandmoe/rellax)\n\n是一个超轻量级，JavaScript视差库。Rellax 现在可以在移动设备上工作 \n\n效果网站：[Demo Website](https://dixonandmoe.com/rellax/)\n\n\n\n7、[Dynamics.js (dynamicsjs.com)](http://dynamicsjs.com/)\n\n用于创建基于物理的动画\n\n\n\n\n\n8、[mojs/mojs](https://github.com/mojs/mojs)\n\n用于 Web 的运动图形工具\n\n演示网址：[mo.js](https://mojs.github.io/)\n\n\n\n9、[metafizzy/zdog](https://github.com/metafizzy/zdog)\n\n圆形，平面，设计师友好的伪3D引擎，用于canvas和SVG\n\n官网：[Zdog · Round, flat, designer-friendly pseudo-3D engine for canvas and SVG (zzz.dog)](https://zzz.dog/)\n\n\n\n10、[leader-line-vue](https://www.npmjs.com/package/leader-line-vue)\n\n用来画引导线:\n\n![前020](https://raw.githubusercontent.com/anseki/leader-line/HEAD/img/ex-020.gif)\n","tags":["前端","JS","插件"],"categories":["JS","前端"]},{"title":"JS一些原理和方法","url":"/2023/06/30/JS一些原理和方法/","content":"\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\nJS一些原理和方法\n\n---\n\n\n# 一、JS深度拷贝\n\n## 1.深度拷贝和浅度拷贝的区别\n对象和数组是通过指针去指向内存地址区来确定其位置。\n\n对于浅拷贝只是复制了其指针，指向了同一块内存区域，在操作新数组或者对象时必然会影响到原数组或对象，也就是说改变新数组时，原数组也会进行改变。\n\n而深度拷贝是完全复制了原数组或对象，也在内存区申请了新空间，改变新数组或对象不会影响到原数组。\n\n## 2.如何进行深度拷贝\n首先是浅度拷贝，浅度拷贝我理解的就是简单的进行赋值\n\n>代码如下（示例）：\n\n```c\nlet arr1=[1,2,3,4,5];\nlet arr2=arr1;\n```\n\n对于深度拷贝可以用ES5或者ES6的语法规则来，当然ES6比较简单快捷，对于单层和多层嵌套的数组或对象ES5和ES6也有不一样的语法。\n>ES5代码如下（示例）：\n\n```c\n//ES5单层嵌套\nlet arr1=[1,2,3,4,5];\nlet arr2= ary1.concat();\n\n//ES5多层嵌套\nlet arr1=[1,2,3,4,5];\n JSON.parse(JSON.stringify(ary1));\n```\n>ES6代码如下（示例）：\n\n```c\n//ES6单层嵌套\nlet arr1=[1,2,3,4,5];\nlet arr2= [...ary1];\n//或者\nlet [...arr2]=arr1;\n\n//ES6多层嵌套\nlet arr1=[1,2,3,4,5];\nvar arr2 = arr1.constructor === Array ? [] : {};  \n        for (var i in arr1) {\n             arr2[i] = deepCopy(arr1[i]);\n        }\n```\n# 二、sort() 排序方法的使用\n`提示：sort()方法会改变原数组或对象`\nsort在没有传入参数时是根据各个字符的Unicode位来进行排序的\n>代码如下（示例）：\n\n```c\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\nmonths.sort();\n// 输出: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\n// 输出: Array [1, 100000, 21, 30, 4]\n\n```\n\nsort可以传入一个排序函数或者两个参数，显而易见排序函数中有两个参数也就是可以直接传的两个参数\n>代码如下（示例）：\n>`提示：为字符串时不排序`\n\n```c\narr=[1,30,4,21,100000];\narr.sort((p1,p2)=>{\n//升序\nreture p1-p2;\n// 输出: Array [1, 4, 21, 30, 100000]\n\n//降序\nreture p2-p1;\n//输出: Array [100000, 30, 21, 4, 1]\n})\n\n```\n\n# 三、判断数据类型\n>ES5数据类型共有6个：数值、字符串、布尔、对象、null、undefind\n\n>ES6又新加了symbol、bigInt\n>symbol（基本数据类型）是指独一无二的值，通过Symbol()生成的值都是唯一的，用来最为对象属性的标识符。\n\n>bigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示，数据必须加后缀n。\n\n`null被称为空对象指针：初始化对象时最好将其初始化为null。`\n\n`undefined:变量没有初始化、函数参数没提供、对象中属性没赋值、函数没有返回值，这些都为undefind`\n\n## 1、 判断基本数据类型\n- typeof x 。\n- x.constructor\n- Object.prototype.toString.call(x)\n\n\n# 四、比较运算\n><=、=、>=、==、!=  、! = =、 ===\n>`在比较运算符中==和===存在比较差异，==只比较值是否一样，而===则是值和类型同时比较；同理!=和!==一样`。\n\n# 五、跳出循环\n>break: 跳出整个大循环\n>continue：只跳出本次循环，开始下一次循环\n\n# 六、字符串方法\n>在字符串中如果要显示单引号或者双引号，需要转义在引号前加‘ \\ ’用来转义。\n\n## charAt（）\n>用来返回字符串中某个位置的字符，允许为负或者比字符串索引大，但返回一个空字符。\n\n## concat ( )\n>用来连接两个字符串，返回一个新字符串，不改变原字符串，可接受多个参数，如果参数不为字符串，则该方法会先将其转换为字符串。\n>用+来也可以代替该方法，字符串拼接。\n\n## substring（）\n>用来从原字符串取出子字符串并返回，不改变原字符串，它的第一个参数表示开始位置，第二个参数表示结束位置（结果不包含）。\n>只传一个参数则会返回该位置到结束的字符串\n>第一个参数比第二个参数，则会自动交换位置\n>如果为负，则会从0开始\n\n##  substr（）\n>与substring（）作用一样，但是参数不同\n>第一个参数为起始位置，第二个参数为长度\n>省略第二个参数则会从开始位置直到结束\n>如果第一个参数为负则会从倒数计算字符位置，第二个参数是负数，将会被自动转为0，返回空字符串\n\n\n##  indexOf（）\n>用来确定一个字符串在另一个字符串中出现的位置，返回结果为匹配开始的位置。\n>也可以传入第二个参数，表示从该位置开始匹配\n\n>在ES6中新增：\n>（1）includes()：返回布尔值，判断是否找到参数字符串。\n（2）startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。\n（3）endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。\n>都支持第二个参数，表示从这个位置开始。\n\n##  trim（）\n>用来去除字符串两端的空格，返回一个新字符串，不改变原字符串\n>去除的包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）\n\n>ES6扩展方法trimEnd()和trimStart()方法，分别是去掉尾部和头部\n\n\n##  split（）\n>利用规则来将字符串分割开，返回一个结果数组\n>如果参数为空字符串，则会分割每一个字符\n>不传参数则返回整个字符串，不做分割\n>第二个参数则是返回结果的个数\n\n##  ES6其它新增字符串方法\n###  repeat（）\n>用来将字符串重复指定次数返回，不改变原字符串\n>参数为正整数，则返回指定次数\n>参数为非负小数，则向下取整\n>如果参数是0~-1之间的数，则取整，为0\n>如果参数是NaN，则为0次\n>如果参数为负数或者Infinity，则报错\n>如果为字符串，则会先转换为数字\n\n###  字符串补全\n>padStart（）:返回新字符串，表示用参数字符串从头补全原字符串。\n>padEnd（）:返回新字符串，表示用参数字符串从后边补全原字符串\n\n>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。\n\n#  七、数组方法\n## 数组静态方法Array.isArray()\n  >用来弥补typeof判断数组返回object的缺陷，该方法会返回布尔值表示参数是否为数组。\n\n##  push()和pop()方法\n>push用来在数组末端添加一个或多个元素，会改变原数组\n>pop用来删除数组最后一个元素并返回，会改变原数组\n\n##  shift（)和unshift()方法\n>shift用来删除数组第一个元素，并返回该元素，会改变原数组\n>unshift用来在数组头部添加元素，并返回添加元素的长度\n\n##  join（）方法\n>用来以参数作为分割符，将所有数组成员连接为一个字符串并返回，如果不提供，默认为逗号。如果数组的成员为Null或undefind或空位，会被转层空字符串。\n\n\n##  concat（）方法\n>用来多个数组合并，将新数组的成员，添加到原数组的后部，返回一个新数组，原数组不变。\n>参数除了数组外，还有可以传入其它类型的参数，并将其添加到原数组后边。\n\n\n##  reverse（）方法\n>用来颠倒数组元素，返回改变的数组，原数组会改变\n\n##  indexOf（）方法\n>用来返回给定元素在数组中第一次出现的位置，不存在返回-1\n>第二个参数表示开始查找的位置\n\n\n#  变量提升（hoisting）\n>在JS引擎工作时，先解析代码，获取所有被声明的变量，然后顺序执行，所有的变量声明语句，都会被提升到代码的头部。\n\n#  函数提升\n>JS引擎会将函数名视同变量一样，采用function声明函数时，整个函数会像变量一样提升到头部。\n\n\n#  Math对象\n##  Math.abs()\n>用来返回参数值的绝对值\n\n##   Math.max()和Math.min()\n>返回参数中最大值或最小值\n>参数为空时，返回-Infinity或Infinity\n\n##  Math.floor（）和Math.ceil（）\n>返回参数向下取整或者向上取整的值\n\n## Math.random()\n>返回一个0~1的随机数\n\n>某个范围的随机整数：\n\n```javascript\nfunction f(min,max) {\n    let result=Math.random()*(max-min)+min;\n    result=Math.floor(result);\n    return result;\n  }\n```\n#  Date对象\n>JS原生的时间库\n\n##  Date.now()\n>返回当前事件距离四件零点（1970年1月1日00：00：00 UTC）的毫秒数，相当于Unix时间戳乘以1000\n\n###  时间戳\n>是指格林威治时间（1970年1月1日00：00：00 ）北京时间（1970年1月1日08：00：00 ）起到现在总秒数。\n\n###  Date提供的get方法\n\n \n\n```javascript\ncost d=new Date('January 6,2022'); \n```\n\n - getTime()：返回实例距离1970年1月1日的毫秒数\n - getDate()：返回实例对象对应每个月的几号\n - getDay()：返回星期几，从0开始\n - getYear()：返回距离1900的年数\n - getFullYear()：返回四位的年份\n - getMonth：返回月份，从0开始\n - getHours：返回小时\n - getMillisecinds：返回毫秒\n - getMinutes：返回分钟\n - getSeconds()：返回秒\n\n","tags":["前端","JS","方法"],"categories":["JS","前端"]},{"title":"JavaScript 设计模式核⼼原理与应⽤实践(一)原则与核心思想","url":"/2023/06/30/JavaScript 设计模式核核心原理与应⽤实践（一）原则于核心思想/","content":"\n---\n\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n\n软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。\n\n---\n\n\n# 一、设计模式的原则\n>面向对象编程和面向对象设计的五个基本原则:\n\n - 单一功能原则（Single Responsibility Principle）\n- 开放封闭原则（Opened Closed Principle）\n- 里式替换原则（Liskov Substitution Principle）\n- 接口隔离原则（Interface Segregation Principle）\n- 依赖反转原则（Dependency Inversion Principle）\n\n>因为JS本身的特点，主要围绕前两个原则展开\n\n---\n# 二、设计模式的核心思想——封装变化\n>设计模式的出现，最主要的原因是因为软件在不停的更新迭代中，不断地产生**变化**\n\n>在开发过程中我们不能保证代码不会发生变化，我们能做的就是将影响降到最低，做到：`**将变化的部分与不变的部分抽离，保证变化的部分灵活，不变的部分稳定**`。这称为“封装”\n\n>我们不仅要考虑功能的实现，还要考虑其可维护性和可拓展性，不能经得起变化的考研的软件终不能长久。\n\n---\n\n# 三、二十三种设计模式\n\n>二十三种设计模式可分为三大类分别是：\n\n - 创建型\n    - 单例模式\n    - 原型模式\n    - 构造器模式\n    - 工厂模式\n    - 抽象工厂模式\n  - 结构型\n      - 桥接模式\n      - 外观模式\n      - 组合模式\n      - 装饰器模式\n      - 适配器模式\n      - 代理模式\n      - 享元模式\n   - 行为型\n        - 迭代器模式\n        - 解释器模式\n        - 观察和模式\n        - 中介者模式\n        - 访问者模式\n        - 状态模式\n        - 备忘录模式\n        - 策略模式\n        - 模板方法模式\n        - 职责链模式\n        - 命令模式\n\n>每一种类型的设计模式都离不开  `封装变化` 只是用了自己的方式去封装不同类型的变化\n\n - 创建型：封装了创建对象过程中的变化\n - 结构型：封装了对象之间组合方式的变化，灵活的表达了对象间的配合与依赖关系\n - 行为型：封装的是对象的行为进行，让我们更安全、方便的对行为进行更改\n\n\n>看似设计模式与我们很远，其实它就在我们身边，可能我们用到，但不知道这个思想就是，某种设计模式的思想。\n---\n\n\n# 总结\n以上记录了设计模式的核心思想，以及原则，简单的介绍了三大类设计模式的作用。\n\n","tags":["前端","设计模式"],"categories":["设计模式","前端"]},{"title":"JavaScript 设计模式核⼼原理与应⽤实践(二)创建型","url":"/2023/06/30/JavaScript 设计模式核心原理与应用实践（二）创建型/","content":"\n---\n<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\n创建型设计模式用于描述“怎么创建对象”。它的主要特点是“将对象的创建与使用分离”。\n\n前端创建型设计模式用到的有：`构造器模式`、`工厂模式`、`抽象工厂模式`\n\n---\n\n\n# 一、构造器模式\n>构造函数想必就是一种构造器如：\n\n\n```javascript\nfunction f(name,age,career) {\n    this.name=name;\n    this.age=age;\n    this.career=career;\n}\nconst user=new f('张三',23,'coder');\n```\n\n>只用传给构造函数对应的值，就可以创建出一个实例对象出来\n\n>总的来说：像这样一个新建对象分配内存后，用来初始化对象的特殊函数，叫做构造器。在JS中，我们通过构造函数去初始化对象，就是应用了构造器模式。\n\n>在整个过程中，改变的是属性的值，而这些属性则是固定不变的。\n>构造器将属性赋值给对象的过程给封装了，使每个对象都具有这些属性，这一部分不可更改使其稳定，而属性赋值的过程开放，可以灵活的给属性赋值。\n\n>构造器模式本质是去抽象每个**对象实例**的变与不变\n\n---\n\n# 二、简单工厂模式\n>工厂模式本质上是抽象不同**构造函数**（类）之间的变与不变，他将创建对象的过程单独封装。\n\n>当不同类中属性相同，但其中的属性会受到其它属性的值而产生对应的值，就比如一个教室中，有学生和老师两种类型，学生类中包含年龄、姓名、职位、工作组成；而老师类也是年龄、姓名、职位、工作组成；但工作会因为职位的值，自动匹配工作的值，学生：学习，老师：授课。\n\n```javascript\nfunction student(name,age){\n    this.name=name;\n    this.age=age;\n    this.position='学生';\n    this.work='学习';\n}\n\nfunction teacher(name,age) {\n    this.name=name;\n    this.age=age;\n    this.position='老师';\n    this.work='授课';\n}\nconst student1=new student('张三',23);\nconst student2=new student('李四',23);\nconst student3=new student('王五',23);\nconst teacher=new student('李',23);\n```\n\n>这样一个教室的角色就可以被构造出来实例，但会发现有个问题就是,得到一条数据后，还得手动判断职业，才能选择对用的构造函数构建。这部分的变可以给一个大函数来管理。\n\n```javascript\nfunction roleManagement(name,age,career) {\n    switch (career) {\n        case '学生':\n            return new student(name,age);\n            \n        case '老师':\n            return new teacher(name,age);\n        ...    \n        \n    }\n}\n```\n>这样判断职业的事交给了`roleManagement`函数管理，但是又有个问题就是假如有一个听课老师，那是不是又得写一个构造函数来构造这个听课老师，`roleManagement`中又得添加一个判断，又来一个校长又得写一个，显然是乏力的。\n\n>可以想到在这两个类中共同的部分依旧是那四个属性，改变的是每个属性的取值与work属性需要根据position属性值来判断，我们何不将 不变的构造函数和，判断改变的逻辑封装在同一个方法中，让他自己判断，从而构建出不同的实例对象。\n\n```javascript\nfunction gather(name,age,position) {\n    function User(name,age,position,work) {\n        this.name = name\n        this.age = age\n        this.position = position\n        this.work = work\n    }\n\n    function roleManagement(name,age,position) {\n        switch (position) {\n            case '学生':\n                work='学习'\n                break\n\n            case '老师':\n                work='授课'\n                break\n            ...\n\n        }\n    }\n    return new User(name,age,position,work);\n}\n\nconst student5=new gather('张三',23,'学生');\nconst teacher2=new gather('李老师',32,'老师');\n```\n>现在就只用传入姓名、年龄、职业就可以创建出对应的实例拉。\n\n>总的说，工厂模式就是把对象的创建过程封装，只给用户提供传参和结果\n\n\n---\n\n# 三、抽象工厂模式\n>对于构造器模式解决的是多个对象实例的问题，而简单工厂模式解决的是多个类的问题。抽象工厂解决的则是多个工厂的共存。\n\n>在JS的语法中，不支持抽象类的直接实现，只能考模拟还原抽象类。\n\n>有以下场景，在之前老师和学生的基础上，又有一个角色类型，但是他的属性完全和老师和学生不同，他多了其它的属性权限，这时候按照刚刚的逻辑又得在`roleManagement`中添加关于这个新角色的相关权限逻辑。这使得整个`roleManagement`在项目的迭代更新中变的越来越庞大，不易于维护。这样显然是没有遵循**开放封闭原则**的。\n\n```javascript\nfunction gather(name,age,position) {\n    function User(name,age,position,work) {\n        this.name = name\n        this.age = age\n        this.position = position\n        this.work = work\n    }\n\n    function roleManagement(name,age,position) {\n        switch (position) {\n            case '学生':\n                work='学习'\n                break\n\n            case '老师':\n                work='授课'\n                break\n             \n            case '新角色':\n                work='发工资'\n                newPrivileges='管理老师'\n                break\n            ...\n\n        }\n    }\n    \n    return new User(name,age,position,work);\n}\n```\n\n>对于开放粉笔原则：我们要对拓展开放，对修改封闭。也就是说实体（类、模块、函数）可以拓展，不可以修改。\n\n>抽象工厂模式会创建一个定义规则抽象工厂类，这个类只会提供具体工厂的接口，可以通过这个接口来扩展具体工厂的逻辑内容。就比如生产汽车，你不知道具体需要生产什么样的汽车，但你知道生产汽车需要发动机、车架、轮胎、玻璃....，这时候就可以创建出一个抽象类表示这辆车需要什么，但具体需要什么样的部件得靠具体工厂提供。\n\n```javascript\nclass automobileProduction {\n    // 提供发动机的接口\n    createTheEngine(){\n        throw new Error(\"抽象工厂方法不允许被直接调用，需要重写该方法！\")\n    }\n\n    //提供车架的接口\n    createTheFrame(){\n        throw new Error(\"抽象工厂方法不允许被直接调用，需要重写该方法！\")\n    }\n}\n```\n>值得注意的是抽象工厂是不能被实例化的，包括里边的方法是不能被调用的，如果能被调用那不就是修改嘛，我们需要的是扩展而不是修改。\n\n>那如何去生产一台车呢，这时候需要用具体工厂来生产需要的型号，也就是定制一个特定具体工厂：\n\n```javascript\n//具体工厂继承抽象工厂\nclass gallop extends automobileProduction{\n    creatingEngine() {\n        //提供奔驰的发动机\n        return new MercedesBenzEngine(); \n    }\n    createTheFrame(){\n        //提供奔驰车架\n        return new MercedesBenzChassis();\n    }\n}\n```\n\n>在具体工厂中调用的构造函数`MercedesBenzEngine`、`MercedesBenzChassis`，分别用于生产具体的发动机和车架实例，这样的类称为具体产品类，具体产品类往往不会孤立存在，而不同的具体产品类往往又相同的功能，比如：奔驰发动机类和大众发动机类都有给汽车带来动力。所以这里可以用一个抽象产品类来声明这些类具有的基本功能，就像最开始汽车生产抽象类一样声明了汽车生产的基本功能。\n\n```javascript\n//具体工厂继承抽象工厂\nclass gallop extends automobileProduction{\n    creatingEngine() {\n        //提供奔驰的发动机\n        return new MercedesBenzEngine();\n    }\n\n    createFrame(){\n        //提供奔驰车架\n        return new MercedesBenzChassis();\n    }\n}\n\n//定义发动机类的抽象产品类\nclass engine {\n    createTheEngine(){\n        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');\n    }\n}\n\n//定义车架类的抽象产品类\nclass frame {\n    createFrame(){\n        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');\n    }\n}\n\n//定义具体发动机的具体产品类\nclass MercedesBenzEngine extends engine{\n    createTheEngine(){\n        console.log(\"奔驰发动机\")\n    }\n}\n\n//定义具体车架的具体产品类\nclass MercedesBenzChassis extends frame{\n    createFrame(){\n        console.log(\"奔驰车架\")\n    }\n}\n\n//我的车\nconst car=new gallop();\n// 选则发动机\nconst myEngine=new MercedesBenzEngine();\n//选择车架\nconst myFrame=new MercedesBenzChassis();\n//组装发动机\nmyEngine.createTheEngine();\n//组装车架\nmyFrame.createFrame();\n```\n>最终组装出来一辆奔驰车\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1c159ac4aa7c4da7a5e7a83069f9e585.png)\n>假设后来我又想生产大众车了，这时候我们不用对抽象工厂做任何改变，只需要拓展他的具体工厂和具体产品的种类就行了。这就完美的实现了拓展。\n---\n\n# 总结\n对于简单工厂和抽象工厂模式来看：\n共同点是：尝试去分离一个系统中变与不变的部分\n不同点：场景的复杂度\n>在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对共性作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分。\n","tags":["前端","设计模式"],"categories":["设计模式","前端"]},{"title":"H5声明和H5基本骨架，各种标签以及H5的新标签","url":"/2023/06/30/HTML5简介和H5新标签/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 前言\nH5声明和H5基本骨架，各种标签以及H5的新标签\n\n---\n\n# 一、HTML5的DOCTYPE声明\n\n>DOCTYPE是document type(文档类型)的缩写，<!DOCTYPE html>是H5的声明，位于文档最前面，他是网页必备组成部分，避免浏览器的怪异模式。\n\n# 二、HTML5的基本骨架\n## 1.html标签\n\n - 包裹其它标签\n - 限定文档的开始和结束\n> `<html lang=\"en\">`表示当前网页语言为英文\n  \n## 2.head标签\n\n - 定义文档的头部，包括文档的各种属性和信息，包括标题\n - 不展示给用户\n - 和其他文档的关系\n - 在Web中的位置\n\n>`<meta charset=\"UTF-8\">`表示当前编码为UTF-8\n## 3.body标签\n\n - 定义文档的主体\n - 包括了文档所有内容（文本、超链接、图像、表格、列表）\n - 直接在页面中显示，用户直观看到的内容\n\n## 4.title标签\n\n - 定义文档标题\n - 显示在浏览器窗口的标题栏或状态栏上\n - 该标签是head标签中唯一必须的标签\n - 有利于SEO优化（浏览器搜索引擎搜索的排名）\n\n---\n\n# 二、标题标签\n>标题（Heading）是通过<h1>~<h6>标签来定义的。\n><h1>定义最大 标题，<h6定义最小标题>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n</body>\n</html>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cbd4185ac2664813b43d2ea3d4e9104d.png)\n>标签位置摆放：\n>在标签中添加属性align=\"left | center | right\"默认居左\n\n```html\n<h1 align=\"center\">一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e0929400b67343b3a6d2ea18c191862f.png)\n\n\n`正确使用标题标签有利于SEO优化`\n\n\n# 三、段落、换行、水平线标签\n## 1、 段落\n>段落用`<p>`标签定义\n\n```html\n<body>\n<p>这是一个段落</p>\n<p>这是另一个段落</p>\n</body>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e0150229b284f5bba4ea22f6a928605.png)\n\n## 2、 换行\n>换行用`<br>`标签定义,为单标签\n\n```html\n<body>\n<p>这是一个段落</p>\n<p>这是<br/>另一个段落</p>\n</body>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7a261b61db7043b38e35e02990225644.png)\n\n## 3、 水平线\n>水平线用`<hr>`标签定义,为单标签\n\n属性：\n\n - color:设置水平线颜色\n - width：设置水平线长度\n - size:设置水平线的高度\n - align:设置水平线对齐方式（默认居中），可取值 left | right\n \n `<hr color=\"red\" width=\"300px\" size=\"5px\" align=\"left\"/>`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/376c5daec6414c94a429fe268a826fbd.png)\n\n# 四、图片标签\n>图片用`<img>`标签定义,为单标签\n\n```html\n<img src=\"\" alt=\"\">\n```\n属性：\n\n - src:图片路径\n - alt:规定图像的替代文本\n - width：规定图像的宽度\n - height：规定图像的高度\n - title：鼠标悬停在图片上的提示文字\n\n路径：\n\n - 绝对路径：电脑中储存的具体位置\n - 相对路径：\n              -  子级关系：/\n              -  父级关系：../\n              -  同级关系：./  \n              \n    \n\n# 五、超文本标签\n>超文本用`<a>`标签定义\n\n```html\n<a href=\"\"></a>\n```\n属性：\n\n - href:跳转链接地址\n \n---\n1. 一个未访问过的链接显示未蓝色字体并带有下划线\n2. 访问过的链接显示未紫色并带有下划线\n3. 点击链接时，链接显示为红色并带有下划线\n\n# 六、文本标签\n>常用文本标签：\n - `<em>`: 定义着重文字\n - `<b>`:定义粗体文本\n - `<i>`:定义斜体字\n - `<strong>`:定义加重语气\n - `<del>`:定义删除字\n - `<span>`:元素没有特定含义\n\n```html\n<em>em</em>\n<br>\n<i>i</i>\n<br>\n<b>b</b>\n<br>\n<strong>strong</strong>\n<br>\n<del>del</del>\n<br>\n<span>span</span>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c72d9e968358449f832b37f03811383b.png)\n# 七、有序列表标签\n>有序列表始于`<ol>`标签，每个列表始于`<li>`标签。\n\n```html\n<ol>\n    <li>123</li>\n    <li>123456</li>\n</ol>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/05aab8e7a6cf46b6baa9a4003b36dfd3.png)\nol属性type的选项：\n - 1\n - a\n - A\n - i\n - I\n \n![在这里插入图片描述](https://img-blog.csdnimg.cn/4f310307420543fa9dd9102a5d70b8d1.png)\n>可嵌套列表：\n\n```html\n<ol type=\"A\">\n    <li>123\n    <ol>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ol>\n    </li>\n    <li>123456</li>\n</ol>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e5637b78c2c41ccb487f3fa73b61f0f.png)\n# 八、无序列表标签\n>无序列表始于`<ul>`标签，每个列表始于`<li>`标签。\n\n```html\n<ul>\n    <li>123</li>\n    <li>123456</li>\n</ul>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1c0b1d670c414977a95ece9c4acee54b.png)\nol属性type的选项：\n\n - disc:默认实心圆\n - circle:空心圆\n - squarer:小方块\n - none:不显示\n \n \n>可嵌套列表：\n\n```html\n<ul>\n    <li>123\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ul>\n    </li>\n    <li>123456</li>\n</ul>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/17db97e3d1f644c7b19a98cfd16c7ef2.png)\n\n# 九、表格标签\n>表格：`<table>`标签\n>行：`<tr>`标签\n>单元格（列）：`<td>`标签\n\n```html\n<tr>\n        <td>1</td>\n        <td>2</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2b2fdcf2f87a4acca2702c43f76bccbe.png)\n>快捷键\n>`table>tr*2>td{内容}`\n\ntable表格属性：\n\n - border: 设置表格的边框\n - width: 设置表格的宽度\n - height: 设置表格的高度\n \n \n\n```html\n<table border=\"1px\" width=\"300px\" height=\"100px\">\n    <tr>\n        <td>1</td>\n        <td>2</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n</table>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/02c1c6efd9d3499f95d8c3978630f317.png)\n\n>单元格合并属性\n>水平合并：colspan 保留左边，删除右边，值为合并单元格个数\n>垂直合并：rowspan 保留上边，删除下边，值为合并单元格个数\n\n```html\n<table border=\"1px\" width=\"300px\" height=\"100px\">\n    <tr>\n        <td colspan=\"2\">1</td>\n        <td rowspan=\"2\">3</td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td>5</td>\n    </tr>\n</table>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/83ac69c89fef4a57a08de68efe985fee.png)\n\n# 十、Form表单\n>用来给用户填写信息，从而能采集用户信息，使网页具有交互的功能。\n>表单是由容器和控件组成，一个表单一般应该包括用户填写信息的输入框，提交按钮等，这些称为控件，表单就是容器，能容纳各种控件。\n\n>`<form action=\"url\" method=\"get | post\" name=\"myForm\">`\n>属性：\n>action:服务器地址\n>name:表单名称\n>meethod：请求方式（get | post）\n\n>表单元素：\n>完整的表单包含三个基本组成部分：表单标签、表单域、表单按钮\n\n```html\n<form action=\"url\" method=\"get | post\" name=\"myForm\">\n    <input type=\"text\">\n    <button type=\"submit\">提交</button>\n</form>\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/10e8dfb02ed4447ebb82ed47cd187397.png)\n\n>文本域：用户输入字母数字等内容\n>`<input type=\"text\">`\n\n>密码框：输入的密码\n>`<input type=\"password\">`\n\n>提交按钮：用来提交表单\n>`<input type=\"submit\" value=\"登录\">`\n\n# 十一、元素分类（块、行内元素）\n块级元素     | 行内元素\n-------- | -----\n块元素会在页面中独占一行（自上而下垂直排列）  | 行内元素不会独占一行，只占自身的大小\n可以设置width,height属性  | 行内元素设置width,height属性无效\n一般块级元素可以包含行内元素和其它块级元素  | 一般行内元素不包含块级元素\n\n## 块元素\n>常见：div、form、h1~h6、hr、p、table、ul、等\n## 行内元素\n>常见：a、b、em、i、span、strong、等\n\n## 行内块级元素\n>不换行、能够识别宽高\n>常见：button、img、input、等\n\n# 十二、HTML5新增标签\n有利于搜索引擎SEO优化\n>传统的页面采用DIV+CSS实现，某个模块最外层用`<div>`标签包裹\n\n```html\n<div>\n    <form action=\"url\" method=\"get | post\" name=\"myForm\">\n        <input type=\"submit\" value=\"登录\">\n        <button type=\"submit\">提交</button>\n    </form>\n</div>\n```\n\n>H5新增标签：\n\n - `<header></header>`头部标签\n - `<nav></nav>`导航栏标签\n - `<section></section>`文档中的节，如章节、页眉、页脚\n - `<article></article>`一个独立的、完整的相关内容块\n - `<aside></aside>`侧边栏标签\n - `<footer></footer>`底部标签\n\n# 总结\n\n本文仅仅简单介绍了HTML和H5，其中包括了H5声明和各种标签\n\n","tags":["HTML","标签"],"categories":["HTML","前端"]},{"title":"0~n-1缺失的数字","url":"/2023/06/30/0～n-1中缺失的数字/","content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n# 问题描述：\n\n\n一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n限制：1 <= 数组长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入: [0,1,3]\n输出: 2\n\n示例 2：\n输入: [0,1,2,3,4,5,6,7,9]\n输出: 8\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>二分：有且只有一个数字不在该数组，且每个数都是唯一的，利用二分查找到第一个数组下标与值不对应的，\n>下标就是缺失的数,在这之前如果数组长度为1要额外判断在左指针到最后时，要判断数组最后一个是否> 与下标对应，如果对应缺失的数就是left+1\n\n>顺序查找：从头开始查找，找到下标与值不对应的就是缺失的数，找到最后则缺失的数为数组长度。\n## 1.二分：\n>时间复杂度：O（logn），空间复杂度：O（1）\n```java\nclass Solution {\n        public static int missingNumber(int[] nums) {\n            if(nums.length==0)return -1;// 数组长度为0返回-1\n            if (nums.length==1)return nums[0]==0?1:0;// 数组长度为1 额外判断\n            int left=0;\n            int right=nums.length-1;\n            while (left<right){\n                int half=left+((right-left)>>2);// 取一半\n                if (nums[half]==half){// 下标对应其值\n                    left=half+1; // 左指针指向中点右边一位\n                    if (left==right && nums[left]==left)return left+1;// 到数组最后一位\n                }else right=half;// 没有对应\n            }\n            return right;// 返回第一个数组与下标不对应的值\n        }\n    }\n```\n## 2.顺序查找：\n>时间复杂度：O（n），空间复杂度：O（1）\n```java\npublic static int missingNumber2(int[] nums) {\n            for (int i=0;i<nums.length;i++){\n                if (i==nums[i]) continue;\n                return i;\n            }\n            return nums.length;\n        }\n\n```\n\n## 3.运行结果\n>二分：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ca52642128834fd6ba071edd53dbb5b2.png)\n\n>顺序查找；\n![在这里插入图片描述](https://img-blog.csdnimg.cn/617424ff8f1e4af48aa609873b9f91ba.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/submissions/)\n","tags":["算法","数组","二分","简单","offer","力扣"],"categories":["力扣","数组","二分"]}]