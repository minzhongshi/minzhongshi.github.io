[{"title":"SpringCloud（学习 商品服务-属性分组的开发）六","url":"/2023/08/11/SpringCloud（学习 商品服务-属性分组的开发）六/","content":"\n# 前言\n\n本文主要记录开发商品服务的过程，及查询、新增、修改等功能的开发。\n\n---\n\n\n\n# 一、属性分组表关系\n\n## 属性分组-规格参数-销售属性-三级分类 关联关系\n\n![属性分组关系表](https://img-blog.csdnimg.cn/dde86c40784a4cc6a1766b19f6ec09d9.png)\n\n## 商品属性表关系\n![商品属性关系表](https://img-blog.csdnimg.cn/4f79c6747fe5442798ce30ebbfa582b6.png)\n\n# 二、查询功能的开发\n\n>查询功能的开涉及到多个字段的模糊查询，模糊查询的参数使用key来接收，并通过key来查询列表\n![查询功能](https://img-blog.csdnimg.cn/a66fd340380c4b668e49076c30011d6c.png)\n\n## 1、接口编写\n\n>在controller层编写接口，利用queryPage（）方法来查询列表，catelogId为当前节点id，params为分页、条数、key信息。\n\n```java\n @RequestMapping(\"/list/{catelogId}\")\n    //@RequiresPermissions(\"product:attrgroup:list\")\n    public R list(@RequestParam Map<String, Object> params,\n                  @PathVariable(\"catelogId\")Long catelogId){\n//        PageUtils page = attrGroupService.queryPage(params);\n        PageUtils page = attrGroupService.queryPage(params,catelogId);\n\n        return R.ok().put(\"page\", page);\n    }\n```\n\n## 2、创建方法\n\n>在service层创建queryPage方法\n\n```java\nPageUtils queryPage(Map<String, Object> params, Long catelogId);\n```\n\n## 3、实现方法\n\n>实现该方法\n\n```java\n  @Override\n    public PageUtils queryPage(Map<String, Object> params, Long catelogId) {\n        //模糊查询的参数\n        String key = (String) params.get(\"key\");\n        //select * from pms_attr_group where catelog_id=? and (attr_group_id=key or attr_group_name like %key%)\n        QueryWrapper<AttrGroupEntity> wrapper = new QueryWrapper<AttrGroupEntity>();\n        if (!StringUtils.isEmpty(key)){\n            wrapper.and((obj)->{\n                obj.eq(\"attr_group_id\",key).or().like(\"attr_group_name\",key);\n            });\n        }\n        if (catelogId == 0){\n           IPage<AttrGroupEntity>page = this.page(new Query<AttrGroupEntity>().getPage(params),\n                   wrapper);\n            return new PageUtils(page);\n        }else {\n            wrapper.eq(\"catelog_id\",catelogId);\n            IPage<AttrGroupEntity>page = this.page(new Query<AttrGroupEntity>().getPage(params),\n                    wrapper);\n            return new PageUtils(page);\n        }\n    }\n```\n\n\n# 三、新增和修改功能的开发\n>新增和修改功能主要是其中所属分类的选择和回显的开发。\n\n![新增和修改](https://img-blog.csdnimg.cn/503843c8a73d4a749be9151515954c6f.png)\n## 1、所属分类的连级选择\n>调用之前的三级分类列表的接口，但是该接口会在第三级字段里面添加一个空的子集列表，这会导致组件显示异常，所以需要将该集合从返回数据中去除。\n\n![连级选择异常](https://img-blog.csdnimg.cn/7bc6dc1467004c509f72370e0e9033db.png)\n>在实体类children字段上利用@JsonInclude注解判断该字段是否为空，为空则不返回\n```java\n/**\n\t * 子集合\n\t */\n\t@JsonInclude(JsonInclude.Include.NON_EMPTY) //为空不带\n\t@TableField(exist = false) //不是表中的字段，用来标记排除\n\tprivate List<CategoryEntity>children;\n```\n\n\n|用法  | 解释 |\n|--|--|\n| ALWAYS | 默认策略，任何情况都执行序列化 |\n| NON_NULL | 非空 |\n| NON_ABSENT | null的不会序列化，但如果类型是AtomicReference，依然会被序列化 |\n| NON_EMPTY | null、集合数组等没有内容、空字符串等，都不会被序列化 |\n| NON_DEFAULT | 如果字段是默认值，就不会被序列化 |\n| CUSTOM |此时要指定valueFilter属性，该属性对应一个类，用来自定义判断被JsonInclude修饰的字段是否序列化 |\n| USE_DEFAULTS | 当JsonInclude在类和属性上都有时，优先使用属性上的注解，此时如果在序列化的get方法上使用了JsonInclude，并设置为USE_DEFAULTS，就会使用类注解的设置   |\n\n\n\n## 2、回显\n>由于通过点击事件后，他会回显为第三级的id，但是该组件需要完整的分类id,所以需要返回完整id的字段用于回显。\n>\n![三级分类回显](https://img-blog.csdnimg.cn/94bb25488e554f32b3f5bedc1081238e.png)\n## 1、实体类添加字段\n>实体类添加字段用来返回完整三级分类的id\n\n```java\n/**\n\t * 所属分类全id\n\t */\n\t@TableField(exist = false)\n\tprivate Long[] catelogIds;\n```\n\n## 2、编写接口层\n\n>用于将原来返回的数据添加一个完整id的属性，使用findCatelogPath方法查找完整Id。\n\n```java\n@RequestMapping(\"/info/{attrGroupId}\")\n    //@RequiresPermissions(\"product:attrgroup:info\")\n    public R info(@PathVariable(\"attrGroupId\") Long attrGroupId){\n\t\tAttrGroupEntity attrGroup = attrGroupService.getById(attrGroupId);\n\n        Long catelogId = attrGroup.getCatelogId();\n        Long[]path = categoryService.findCatelogPath(catelogId);\n        attrGroup.setCatelogIds(path);\n        return R.ok().put(\"attrGroup\", attrGroup);\n    }\n```\n\n\n## 3、创建方法\n>在service层创建findCatelogPath方法，catelogId为当前节点id\n\n```java\n Long[] findCatelogPath(Long catelogId);\n```\n\n## 4、实现方法\n>实现findCatelogPath方法，利用传过来的第三级id创建findParentPath方法递归查找父id，并最终返回完整id。\n\n```java\n  @Override\n    public Long[] findCatelogPath(Long catelogId) {\n        List<Long> paths = new ArrayList<>();\n        List<Long> parentPath = findParentPath(catelogId,paths);\n        //逆序返回的id数组\n        Collections.reverse(parentPath);\n        return paths.toArray(new Long[parentPath.size()]);\n    }\n\n    /**\n     * \n     * @param catelogId 当前节点id\n     * @param paths 目前收集的id\n     * @return 完整的id\n     */\n    private List<Long>findParentPath(Long catelogId,List<Long> paths){\n        //1、收集当前节点id\n        //2、当前节点存在父节点就递归本方法\n        //3、收集完返回\n        paths.add(catelogId);\n        CategoryEntity byId = this.getById(catelogId);\n        if (byId.getParentCid()!=0){\n            findParentPath(byId.getParentCid(),paths);\n        }\n        return paths;\n    }\n```\n\n>**Collections工具类方法：**\n\n|方法  | 解释 |\n|--|--|\n| reverse(List list) | 反转列表中元素的顺序 |\n| shuffle(List list)  | 对List集合元素进行随机排序 |\n| sort(List list) | 根据元素的自然顺序 对指定列表按升序进行排序 |\n| sort(List list, Comparator c) | 根据指定比较器产生的顺序对指定列表进行排序 |\n| swap(List list, int i, int j) | 在指定List的指定位置i,j处交换元素 |\n| rotate(List list, int distance) | 当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为 负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度 |\n\n\n---\n\n# 总结\n本文主要讲了属性分组中，查询、新增、修改功能的开发，并记录开发过程中遇到的返回数据去除注解以及Collections工具类的使用。\n\n","tags":["后端","SpringCloud","商品服务","‘@JsonInclude注解’","Collections工具"],"categories":["SpingCloud","微服务","后端","项目","谷粒商城","注解","‘@JsonInclude’","工具","Collections工具"]},{"title":"SpringCloud（学习 商品服务-品牌管理的开发）五","url":"/2023/08/11/SpringCloud（学习 商品服务-品牌管理的开发）五/","content":"\n# 前言\n\n\n本章内容主要记录品牌服务的开发，重点在于阿里云平台oss对象存储、后端数据参数校验JSR303的使用。\n\n---\n\n\n# 一、品牌服务\n\n>品牌服务用于管理品牌的添加、修改、删除等操作，可上传logo到图片服务器中，数据库存储的是图片地址,对于品牌的操作主要涉及添加和修改的操作，后端对于数据的校验分为普通校验、分组校验、自定义校验三种方式来校验数据。\n\n![品牌服务界面](https://img-blog.csdnimg.cn/adbd23d65c6f41faab8c002a43ab8509.png)\n![新增](https://img-blog.csdnimg.cn/818fc13900f14ee5b29672f159366ae0.png)\n\n\n---\n# 二、图片服务\n## 1.开通oss对象存储服务\n>首先，图片存储服务不止阿里云有，还有像七牛云之类的都有类似的服务，前期使用七牛云主要七牛云存储过程与本项目有点出入，所以这里还是选择阿里云平台进行存储。\n\n - **首先找到oss对象存储并开通服务**\n\n![阿里云平台oss对象存储](https://img-blog.csdnimg.cn/d12223e1ead641219b43dffeb2a9d920.png)\n\n- **创建Bucket**\n![创建Bucket](https://img-blog.csdnimg.cn/bd6c695236bc4bcdb1e5657b353c42d2.png)\n`箭头标注的为比较重要的点，名称在项目中会使用到，而公共读是方便开发，后期可以修改私有`\n\n- **找到AccessKey和SecretKey**\n- **添加权限**\n\n![添加权限](https://img-blog.csdnimg.cn/e36c739ddcd94eb68f2014a88d32c3e9.png)\n\n- **找到外网访问域名**\n\n![外网访问域名](https://img-blog.csdnimg.cn/e8e34df745d844f1a58712bc68bf761f.png)\n\n- **配置跨域**\n![跨域](https://img-blog.csdnimg.cn/23fbee856cb945b6ac38aa20a4ce740d.png)\n`这里是配置了post的所有请求`\n\n- **找到java的示例**\n\n![OSS JAVA](https://img-blog.csdnimg.cn/d660bf52b6a14e7184af569b20f5861a.png)\n\n\n\n---\n>至此阿里云平台的配置就完成了，可以进行图片服务的开发了\n\n## 2.图片储存服务\n\n - **创建图片服务并在注册中心中注册**\n - **添加maven依赖**\n\n```java\n <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alicloud-oss</artifactId>\n            <version>2.2.0.RELEASE</version>\n        </dependency>\n```\n\n`这里的依赖是使用了cloud的依赖，这样可以直接使用ossClient实例，官方依赖如下:`\n\n```java\n<dependency>\n    <groupId>com.aliyun.oss</groupId>\n    <artifactId>aliyun-sdk-oss</artifactId>\n    <version>3.15.1</version>\n</dependency>\n```\n\n- **编写接口类**\n\n```java\n@RequestMapping(\"/oss/policy\")\n    public R policy() {\n        // 填写Host地址，格式为https://bucketname.endpoint。\n        String host = \"https://\" + bucket + \".\" + endpoint;\n        // 设置上传回调URL，即回调服务器地址，用于处理应用服务器与OSS之间的通信。OSS会在文件上传完成后，把文件上传信息通过此回调URL发送给应用服务器。\n        // String callbackUrl = \"https://192.168.0.0:8888\";\n        // 设置上传到OSS文件的前缀，可置空此项。置空后，文件将上传至Bucket的根目录下。\n        String format = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n        String dir = format + \"/\";\n\n        Map<String, String> respMap = null;\n        // 创建ossClient实例。\n        try {\n            long expireTime = 30;\n            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;\n            Date expiration = new Date(expireEndTime);\n            PolicyConditions policyConds = new PolicyConditions();\n            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);\n            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);\n\n            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);\n            byte[] binaryData = postPolicy.getBytes(\"utf-8\");\n            String encodedPolicy = BinaryUtil.toBase64String(binaryData);\n            String postSignature = ossClient.calculatePostSignature(postPolicy);\n\n            respMap = new LinkedHashMap<String, String>();\n            respMap.put(\"accessid\", accessId);\n            respMap.put(\"policy\", encodedPolicy);\n            respMap.put(\"signature\", postSignature);\n            respMap.put(\"dir\", dir);\n            respMap.put(\"host\", host);\n            respMap.put(\"expire\", String.valueOf(expireEndTime / 1000));\n            // respMap.put(\"expire\", formatISO8601Date(expiration));\n\n\n        } catch (Exception e) {\n            // Assert.fail(e.getMessage());\n            System.out.println(e.getMessage());\n        }\n        return R.ok().put(\"data\", respMap);\n    }\n```\n\n- **nacos添加配置**\n\n```yaml\nspring:\n  cloud:\n    alicloud:\n      access-key: My access-key\n      secret-key: My secret-key\n      oss:\n        endpoint: oss-cn-hangzhou.aliyuncs.com\n        bucket: guli-smz\n```\n\n---\n\n>至此图片服务编写完成\n\n---\n\n# 三、后端数据校验\n\n - **首先加入校验的相关依赖**\n\n```java\n <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n            <version>3.1.1</version>\n        </dependency>\n```\n\n## 1、普通校验\n- **给Bean添加注解：javax.validation.constraints，定义自己的message提示**\n\n```java\n@NotNull(message =\"修改必须指定品牌id\")\n\t@Null(message = \"新增不能指定id\")\n\t@TableId\n\tprivate Long brandId;\n```\n\n- **开启校验，在controller层添加注解@Valid**\n\n```java\n@RequestMapping(\"/save\")\n    //@RequiresPermissions(\"product:brand:save\")\n    public R save(@Valid @RequestBody BrandEntity brand/*, BindingResult result*/){\n```\n\n- 由于错误存在于所有服务，所以在common编写一个错误状态码和错误信息定义枚举类\n\n```java\n/**\n * 错误状态码和错误信息定义类\n * 1、错误码定义规则为5位数字\n * 2、前两位表示业务场景，最后三位表示错误码。例如：100001。10：通用 001：系统未知异常\n * 3、维护错误码后需要维护错误描述，将他们定义为枚举形式\n *\n * 错误码列表：\n * 10：通用\n *     001：参数格式校验\n * 11：商品\n * 12：订单\n * 13：购物车\n * 14：物流\n */\npublic enum BizCodeEnume {\n    UNKNOW_EXCEPTION(10000,\"系统未知异常\"),\n    VAILD_EXCEPTION(10001, \"参数格式校验失败\");\n\n    private final int code;\n    private final String msg;\n    BizCodeEnume(int code, String msg){\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public int getCode(){\n        return code;\n    }\n    public String getMsg(){\n        return msg;\n    }\n}\n\n```\n\n- **编写集中异常处理类**\n\n```java\n@Slf4j\n@RestControllerAdvice(basePackages = \"com.smz.guli.product.controller\")\npublic class GuliExceptionControllerAdvice {\n\n    /**\n     *\n     * @param e 捕获的精确异常\n     * @return 返回异常信息集合\n     */\n    @ExceptionHandler(value = Exception.class)\n    public R handleVaildException(MethodArgumentNotValidException e){\n        BindingResult bindingResult = e.getBindingResult();\n        Map<String,String> errorMap = new HashMap<>();\n        bindingResult.getFieldErrors().forEach((fieldError -> {\n            errorMap.put(fieldError.getField(),fieldError.getDefaultMessage());\n        }));\n        return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(), BizCodeEnume.VAILD_EXCEPTION.getMsg()).put(\"data\",errorMap);\n    }\n\n    /**\n     *\n     * @param throwable 其它异常捕获\n     * @return 返回错误\n     */\n    @ExceptionHandler(value = Throwable.class)\n    public R handleException(Throwable throwable){\n        log.error(\"错误\", throwable);\n        return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(), BizCodeEnume.UNKNOW_EXCEPTION.getMsg());\n    }\n\n}\n```\n\n---\n\n>在规则中**regexp**为正则校验，**message**为自定义信息，**groups**为规则组\n\n```java\n\t@Pattern(regexp = \"^[a-zA-Z]$\",message = \"检索首字母必须为字母\",groups = {AddGroup.class, UpdateGroup.class})\n```\n**常用注解如下：**\n\n|注解| 作用 |\n|--|--|\n| @Null| 被注释的元素必须为null |\n| @NotNull | 被注释的元素不能为null，可以为空字符串 |\n| @AssertTrue | 被注释的元素必须为true |\n| @AssertFalsel | 被注释的元素必须为false |\n| @Min(value) | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| @Max(value) | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| @DecimalMin(value) | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| @DecimalMax(value) | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| @Size(max,min) | 被注释的元素的大小必须在指定的范围内 |\n|@Digits(integer,fraction)  | 被注释的元素必须是一个数字，其值必须在可接受的范围内 |\n| @Past | 被注释的元素必须是一个过去的日期 |\n| @Future | 被注释的元素必须是一个将来的日期 |\n| @Pattern(value) | 被注释的元素必须符合指定的正则表达式 |\n| @Email | 被注释的元素必须是电子邮件地址 |\n| @Length | 被注释的字符串的大小必须在指定的范围内 |\n| @Range | 被注释的元素必须在合适的范围内 |\n| @NotEmpty | 用在集合类上，不能为null，并且长度必须大于0 |\n| @NotBlank | 只能作用在String上，不能为null，而且调用trim()后，长度必须大于0 |\n\n\n## 2、分组校验\n>分组校验的场景用于同一接口的不同操作来进行校验，不同操作也适用于其它接口。\n\n- **在common编写接口用于区分不同的分组**\n\n```java\n/**\n * 添加分组\n */\npublic interface AddGroup {\n}\n\n/**\n * 修改分组\n */\npublic interface UpdateGroup {\n}\n\n```\n\n- **在实体类添加注解用于区分不同操作对应的分组**\n\n```java\n/**\n\t * 品牌id\n\t */\n\t@NotNull(message =\"修改必须指定品牌id\", groups = {UpdateGroup.class})\n\t@Null(message = \"新增不能指定id\", groups = {AddGroup.class})\n\t@TableId\n\tprivate Long brandId;\n\t/**\n\t * 品牌名\n\t */\n\t@NotBlank(message = \"品牌名不能为空\", groups = {AddGroup.class})\n\tprivate String name;\n```\n\n- **更换controller层注释为@Validated并添加校验分组**\n\n```java\n @RequestMapping(\"/update\")\n    //@RequiresPermissions(\"product:brand:update\")\n    public R update(@Validated(UpdateGroup.class) @RequestBody BrandEntity brand){\n\t\tbrandService.updateById(brand);\n\n        return R.ok();\n    }\n\n@RequestMapping(\"/save\")\n    //@RequiresPermissions(\"product:brand:save\")\n    public R save(@Validated(AddGroup.class) @RequestBody BrandEntity brand/*, BindingResult result*/){\n\t\tbrandService.save(brand);\n\n        return R.ok();\n    }\n```\n\n\n## 3、自定义校验\n>自定义校验用于复杂的校验逻辑，用于处理内置校验规则处理不了的数据校验。\n\n- 创建一个配置文件用于存放自定义消息\n`文件名必须为 ValidationMessages.properties 会自动从该文件找配置项` \n\n```java\ncom.smz.common.valid.ListValue.message=必须填写该项\n```\n\n- **创建一个自定义注解类**\n\n```java\n@Documented\n@Constraint(\n        validatedBy = {ListValueConstraintValidator.class}\n)\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ListValue {\n    // 自定义消息指向\n    String message() default \"{com.smz.common.valid.ListValue.message}\";\n\n    //实现规则的选取\n    Class<?>[] groups() default {};\n\n    //接收的消息体\n    Class<? extends Payload>[] payload() default {};\n\n    //自定义接收参数\n    int[] vals() default {};\n\n}\n```\n- **创建一个校验器**\n\n```java\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport java.util.HashSet;\nimport java.util.Set;\n/**\n * @ListValue 校验器\n * ListValue 校验注解\n * Integer 校验类型\n * initialize 初始化方法 （获取详细信息）\n * isValid 判断是否校验成功\n */\npublic class ListValueConstraintValidator implements ConstraintValidator<ListValue,Integer> {\n    private final Set<Integer>set = new HashSet<>();\n\n    /**\n     *\n     * @param constraintAnnotation 初始化方法\n     */\n    @Override\n    public void initialize(ListValue constraintAnnotation) {\n       int[] vals = constraintAnnotation.vals();\n       for (int val : vals){\n           set.add(val);\n       }\n    }\n\n\n    /**\n     *\n     * @param value 需要校验的值\n     * @param context 定义是否包含\n     * @return 返回是否包含\n     */\n    @Override\n    public boolean isValid(Integer value, ConstraintValidatorContext context) {\n        return set.contains(value);\n    }\n}\n\n```\n\n\n- **使用自定义校验**\n\n```java\n/**\n\t * 显示状态[0-不显示；1-显示]\n\t */\n\t@ListValue(vals={0,1},groups = {AddGroup.class})\n\tprivate Integer showStatus;\n```\n\n---\n\n# 总结\n\n本文主要讲了阿里OSS对象储存的对接以及后端JSR303数据校验的三种使用。\n","tags":["后端","SpringCloud","品牌服务","参数校验","oss对象存储"],"categories":["SpingCloud","微服务","后端","项目","谷粒商城","oss对象存储","参数校验","JSR303"]},{"title":"SpringCloud（学习 商品服务-三级分类的开发）四","url":"/2023/08/11/SpringCloud（学习 商品服务-三级分类的开发）四/","content":"\n# 前言\n\n\n\n本文主要记录商品服务的开发，以及过程中遇到的知识点等。\n\n---\n\n\n# 一、三级分类\n## 表结构\n>其中最顶级的**parent_cid**（父分类id）为**0**\n>\n![商品三级分类表](https://img-blog.csdnimg.cn/0cdea9b2f4d144f6b6b2fbcee4decdb9.png)\n\n---\n\n## Controller编写\n>用于返回所有分类以及子分类，以树型结构组装起来\n\n```java\n @RequestMapping(\"/list/tree\")\n    public R list(){\n        List<CategoryEntity> entities = categoryService.listWithTree();\n        return R.ok().put(\"data\", entities);\n    }\n```\n\n---\n\n## Service编写\n\n - Service接口编写\n >定义listWithTree方法用于返回树型结构\n\n```java\n List<CategoryEntity> listWithTree();\n```\n\n - 实体类加入子类集合属性\n \n\n```java\n\t@TableField(exist = false) //不是表中的字段，用来标记排除\n\tprivate List<CategoryEntity>children;\n```\n\n - 实现类实现方法\n    \n   - 查询出所有分类\n   - 过滤出最顶层分类\n   - 将剩余分类传入方法进行递归查找子菜单\n   \n\n```java\n @Override\n    public List<CategoryEntity> listWithTree() {\n        //1.查出所有分类\n        List<CategoryEntity>entities = baseMapper.selectList(null);\n        //2.组装成树形结构\n        //2.1 找到所有的一级分类\n        return entities\n                .stream()//将集合转换为流\n                .filter(categoryEntity -> categoryEntity.getParentCid() == 0)//过滤最高层菜单\n                //返回一个新的流\n                .peek((menu)-> menu.setChildren(getChildrens(menu,entities)))//查找子菜单\n                .sorted(Comparator.comparingInt(menu -> (menu.getSort() == null ? 0 : menu.getSort())))//根据sort字段排序\n                // 1.toList()转换为List集合（允许重复，有顺序）\n                // 2.toSet()转换为Set集合（不允许重复，没有顺序）\n                // 3.joining()直接将结果拼接\n                // 4.joining(\" | \")每个输出结果之间加拼接符号“|”\n                // 5.joining(\" || \", \"Start--\", \"--End\")开始头为Start--，结尾为--End，中间用拼接符号“||”\n                // 6.collectingAndThen()收集后做其它处理\n                .collect(Collectors.toList());\n    }\n\n    //递归查找所有菜单的子菜单\n    private List<CategoryEntity>getChildrens(CategoryEntity root,List<CategoryEntity>all){\n        return all.stream()\n                .filter(categoryEntity -> Objects.equals(categoryEntity.getParentCid(), root.getCatId()))//比较父与子菜单是否对应\n                .peek(categoryEntity -> categoryEntity.setChildren(getChildrens(categoryEntity,all)))// 递归找子菜单\n                .sorted(Comparator.comparingInt(menu -> (menu.getSort() == null ? 0 : menu.getSort())))// 根据sort字段排序\n                .collect(Collectors.toList());\n    }\n```\n\n\n![树型结构返回](https://img-blog.csdnimg.cn/96af8d6db8234044b9cffe67faeace84.png)\n\n---\n\n\n\n\n# 二、请求通过网关转发\n\n>Spring Cloud 2020版本以后，默认移除了对Netflix的依赖，其中就包括Ribbon，官方默认推荐使用Spring Cloud Loadbalancer正式替换Ribbon，并成为了Spring Cloud负载均衡器的唯一实现\n\n```java\n<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-loadbalancer</artifactId>\n\t\t</dependency>\n```\n\n - **将renren-fast 后台服务注册到注册中心**\n - **在网关服务中拦截renren-fast前端请求并控制和修改**\n \n\n```java\nspring:\n  cloud:\n    gateway:\n      routes: #是个集合\n        - id: admin_route\n          uri: lb://renren-fast  #负载均衡到 renren-fast服务 springcloud2020后需要加Loadbalancer的依赖 作为负载均衡\n          predicates:\n            - Path=/api/**   #‘/api’ 下的所有请求\n          filters:\n            - RewritePath=/api/(?<segment>.*),/renren-fast/$\\{segment}\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/da98d39b0147404ab5169923fbda2b0c.png)\n\n---\n# 三、网关配置跨域\n>问题描述：\n>当在请求登录接口时会发生CORS跨域问题。\n>不满足同源策略的都会发生跨域问题\n\n>**同源策略**：协议、域名、端口都要相同，其中有一个不同都会产生跨域\n>\n![CORS跨域问题](https://img-blog.csdnimg.cn/0c298dd7644b4862a913a0cd61122627.png)\n\n\n ##  跨域流程\n \n [跨域访问控制详解](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n>非简单请求会产生CORS问题，其中简单请求是指：\n   - GET\n   - HEAD\n   - POST\n   - Content-Type 标头所指定的媒体类型的值仅限于下列三者之一：\n      - text/plain\n      - multipart/form-data\n      - application/x-www-form-urlencoded\n    \n>非简单请求，需要先发送预检请求（OPTIONS）\n\n![CORS请求流程](https://img-blog.csdnimg.cn/086a1f099bdf41e7bf66388a02ebf8db.png)\n## 解决跨域\n\n \n\n - **使用nginx部署为同一域**\n >将前端和后端部署在nginx服务器上，当静态请求先给nginx服务器，再由nginx服务器给前端；当为动态请求时，nginx会将请求转发给网关，然后网关再去找对应服务\n >\n ![nginx解决跨域](https://img-blog.csdnimg.cn/a92b4fdcf33342788e2861deba8c0809.png)\n - **通过网关配置请求头使服务器允许跨域**\n >添加响应头\n \n ![添加跨域请求头](https://img-blog.csdnimg.cn/f589f9dc0e0a42b093a34b21e83144a7.png)\n\n---\n>这里使用第二种方式\n\n 首先在网关服务中创建配置类，并进行配置，最后注入到容器中\n \n\n```java\n@Configuration //配置类标识\npublic class GuliCorsConfiguration {\n\n    @Bean //注入容器\n    public CorsWebFilter corsWebFilter(){\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\n\n       //1.配置跨域\n        corsConfiguration.addAllowedHeader(\"*\"); //允许哪些头跨域\n        corsConfiguration.addAllowedMethod(\"*\"); //允许哪些请求跨域\n        corsConfiguration.addAllowedOriginPattern(\"*\"); //允许哪些请求来源跨域\n        corsConfiguration.setAllowCredentials(true); //是否允许携带cook进行跨域\n\n        source.registerCorsConfiguration(\"/**\",corsConfiguration); //path：进行配置跨域的路径\n        return new CorsWebFilter(source);\n    }\n}\n```\n---\n\n# 四、将分类请求转发给商品服务\n\n - 将商品服务注册到注册中心\n - 在nacos新建商品服务的命名空间\n - 在网关服务配置转发路由\n \n\n```java\nspring:\n  cloud:\n    gateway:\n      routes: #是个集合\n        - id: product_route\n          uri: lb://guli-product  #负载均衡到 guli-product服务 springcloud2020后需要加Loadbalancer的依赖 作为负载均衡\n          predicates:\n            - Path=/api/product/**   #‘/api/product’ 下的所有请求\n          filters:\n            - RewritePath=/api/(?<segment>.*),/$\\{segment} #去除/api/使转发请求正确\n```\n\n`配置网关路由时将更为准确的predicates放在上边，范围更广的放在后边，避免转发地址错误`\n\n# 五、删除三级分类\n>编写删除接口，删除以数组形式将菜单id传入，可适配批量删除和单独删除\n\n```java\n/**\n     * 删除\n     * @RequestBody 获取请求体\n     */\n    @RequestMapping(\"/delete\")\n   // @RequiresPermissions(\"product:category:delete\")\n    public R delete(@RequestBody Long[] catIds){\n\t\t//categoryService.removeByIds(Arrays.asList(catIds));\n\n        //1.判断是否在其他地方被引用\n        return categoryService.removeMenuByIds(Arrays.asList(catIds));\n    }\n```\n\n\n# 六、新增三级分类\n>编写新增接口，以菜单实体类的形式传入后保存\n\n```java\n/**\n     * 保存\n     */\n    @RequestMapping(\"/save\")\n    //@RequiresPermissions(\"product:category:save\")\n    public R save(@RequestBody CategoryEntity category){\n\t\tcategoryService.save(category);\n\n        return R.ok(200,\"success\");\n    }\n```\n# 七、编辑三级分类\n>编写批量修改接口\n\n```java\n /**\n     * 批量修改\n     */\n    @RequestMapping(\"/update/sort\")\n    //@RequiresPermissions(\"product:category:update\")\n    public R updateSort(@RequestBody CategoryEntity[] category){\n        categoryService.updateBatchById(Arrays.asList(category));\n\n        return R.ok();\n    }\n```\n# 总结\n\n本文主要讲了商品服务三级分类的相关业务功能开发，以及请求转发、跨域配置等。前端请求先通过网关验证后转发给对应服务，其中网关可对请求做出修改，跨域解决就是通过该方法解决，值得一提的是如果进行跨域，请求会先发送一个预检请求，服务器同意后才能将真正的请求发送给服务器。\n\n","tags":["后端","SpringCloud","商品服务","跨域","请求转发"],"categories":["SpingCloud","微服务","后端","项目","谷粒商城","网关","跨域"]},{"title":"开发tips","url":"/2023/07/04/开发小tips/","content":"\n\n\n\n---\n\n# 前言\n\n用于记录开发小tips。\n\n---\n\n\n# 一、css相关\n## 1. 优先使用:not()进行排除元素\n\n```javascript\n<div class=\"nav\" >\n    <li></li>\n    <li></li>\n    <li></li>\n    <li></li>\n</div>\n\n```\n\n---\n\n`不好的做法：`\n\n```javascript\n .nav li {\n        margin-top: 30px;\n        border: 1px solid red;\n    }\n    /*最后一个元素*/\n    .nav li:last-child {\n        border: none;\n    }\n```\n![去掉子元素](https://img-blog.csdnimg.cn/f54d32d3470148f098c79249e950cb08.png)\n\n`较好的做法：`\n\n```javascript\n .nav li {\n        margin-top: 30px;\n        border: 1px solid red;\n    }\n    /*最后一个元素*/\n    .nav li:last-child {\n        border: none;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/59cca974dac74f74babe4e57565d4abe.png)\n## 2. 使用:root定义变量\n\n```javascript\n :root {\n        --bg: #333;\n        --color: red;\n        --height: 300px;\n    }\n    .nav {\n        background-color: var(--color);\n        height: var(--height);\n        color: var(--bg);\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/27bd41d5b2754d768b3346a16fee161c.png)\n## 3. 相同样式用“，”连接\n\n```javascript\n   .nav li, .nav div {\n        color: red;\n    }\n```\n## 4. 单位尽量不使用\"px\"\n## 5. :nth-child的使用\n\n```javascript\n<div class=\"nav\" >\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n    <p>4</p>\n    <p>5</p>\n</div>\n```\n---\n`前几个换色`\n\n```javascript\n .nav :nth-child(-n+3){\n        background-color: red;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8aa2b3eb234241e883b9ec122dee19e4.png)\n`后几个换色`\n\n```javascript\n.nav :nth-last-child(-n+3){\n        background-color: red;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e62d2fa1bd4d4ee89f983384f9ebe764.png)\n`隔行换色`\n\n```javascript\n .nav :nth-child(2n+1){\n        background-color: red;\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b0fd38a8af734b2f90cfb368800e75d3.png)\n\n# 二、文档注释\n## 1.使用文档注释\n文档注释能更快的开发。\n\n```javascript\n/**\n * 函数防抖\n * @author SMZ <2240941938@qq.com>\n * @param {Function} func 防抖目标函数\n * @param {Number} duration 执行前等待时间\n * @return {Function} 返回一个防抖后的函数\n * @example\n * f(a,2000);\n */\nfunction f(func, duration = 1000) {\n    \n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d93aa2684c9c42bca9159d784e0d7f83.png)\n---\n---\n# 三、函数防抖\n * 频繁调用某个函数\n * 造成效率问题\n * 需要以最后一次调用为准\n\n```javascript\nfunction debounce(func, duration = 1000) {\n    let timer;\n    return function (...args) {\n        clearTimeout(timer); //清除之前的计时器\n        timer = setTimeout( ()=> {\n            func.apply(this);\n        },duration)\n    }\n}\n```\n---\n# 四、官方API\n不要使用\n\n```javascript\ndocument.getElementsByClassName('nav')\n```\n\n使用\n\n```javascript\ndocument.querySelectorAll('nav')\n```\n---\n\n# 五、位运算实现权限组合\n\n```javascript\nconst READ = 0b1; //（1）可读权限     00001\nconst CREATE = 0b10; //（2）可创建    00010\nconst UPDATE = 0b100; //（4）可更新   00100\nconst DELETE =0b1000; //（8）可删除   01000\n\n// 或运算组合权限\nconst jurisdiction =  READ | UPDATE | DELETE | CREATE\nconsole.log(jurisdiction.toString(2))\n\n//与运算查询是否具有某个权限\nconst smz = 14;\nif ((smz & READ) === 0) console.log(\"无可读权限\")\nelse console.log(\"有可读权限\")\n\n//异或运算删除或者更改权限(原来有权限时是删除，原来没有时是更改，如果是更改时需要判断原来是否具有权限)\nconst smz2 = smz ^ READ\n```\n---\n# 六、JS相关\n\n - 随机颜色\n \n\n```javascript\nlet randomColor = \"#\" +\n    //Math.random() 随机选取大于等于0.0且小于1.0的伪随机 double 值\n\n    //取整\n    //  1.Math.round() 四舍五入\n    //  2.Math.ceil() 向上取整\n    //  3.Math.floor() 向下取整\n    Math.floor(Math.random()*16777215)\n.toString(16)\n```\n\n - 获取浏览器URL参数\n \n\n\n\n```javascript\nlet params = new URLSearchParams(\n    window.location.search\n)\n\nparams.get('参数名')\n```\n\n\n - 生成指定范围的随机整数\n \n\n```javascript\nlet randomInt = (min, max) =>\n    Math.floor(Math.random()* (max - min +1)) +min;\n\n\n```\n\n - 深度复制对象\n\n```javascript\nlet obj = {\n    name: 'smz',\n    age: 18,\n    other: {\n        type: '无',\n        other: {\n            type: '无',\n            other: {\n                type: '无'\n            }\n        }\n    }\n}\n//JSON.parse() 解析JSON字符串，得到对应的JavaScript值或对象\n//JSON.stringify() 将一个JavaScript对象或值转换为JSON格式字符串。\nlet cloneObj = JSON.parse(JSON.stringify(obj));\n\nconsole.log(cloneObj)\n\nif (Object.is(obj,cloneObj)) console.log(\"内存地址相同，为浅拷贝\")\nelse console.log(\"内存地址不同，为深拷贝\")\n```\n>内存地址不同\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d5a461f1b32d4507b19bc33b045bd397.png)\n\n","tags":["其它","tips","css","注释","位运算","函数"],"categories":["其它"]},{"title":"SpringCloud 学习-Nacos","url":"/2023/06/30/SpringCloud(学习 Nacos) 二/","content":"\n\n\n# 前言\n本文主要讲述微服务组件中的：**注册中心**、**配置中心**\n\n\n\n---\n\n\n# 一、各组件关系与技术选择\n\n![微服务组件关系图](https://img-blog.csdnimg.cn/88a8b667cbe746fdb3e18b673c596f70.png)\n\n **最终的技术搭配方案为：**\nSpringCloud Alibaba - Nacos：注册中心（服务发现/注册）\nSpringCloud Alibaba - Nacos：配置中心（动态配置管理）\nSpringCloud - Ribbon：负载均衡\nSpringCloud - Feign：声明式 HTTP 客户端（调用远程服务）\nSpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）\nSpringCloud - Gateway：API 网关（webflux 编程模式）\nSpringCloud - Sleuth：调用链监控\nSpringCloud Alibaba - Seata：原 Fescar，即分布式事务解决方案\n\n[阿里官方文档](https://spring-cloud-alibaba-group.github.io/github-pages/2021/en-us/index.html)\n\n[中文文档](https://github.com/alibaba/spring-cloud-alibaba/blob/2022.x/README-zh.md)\n\n[各版本对应关系](https://start.spring.io/actuator/info)\n>![springcloud关系对应](https://img-blog.csdnimg.cn/00bcaff35f324c219151a657151945fc.png)\n\n>`其中不止springboot与springcloud版本对应关系，还有其它与springboot的版本对应关系`\n\n在引入组件前引入依赖管理，可以在后续引入组件依赖时忽略版本号，这些依赖都引入公共模块common中。\n\n```java\n <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2021.0.4.0</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n# 二、Nacos\n## 1.Nacos作为注册中心\n>引入相关依赖：\n\n```java\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n---\n- 下载Nacos注册中心 [Nacos Server](https://github.com/alibaba/nacos/releases)\n- 为每个服务配置nacos服务注册配置\n\n>`server.port=8081\nspring.application.name=nacos-provider\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\nmanagement.endpoints.web.exposure.include=*`\n\n- 启动项添加注解@EnableDiscoveryClient开启服务注册/发现\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class GuliCouponApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(GuliCouponApplication.class, args);\n    }\n}\n```\n\n- 启动服务进行服务注册发现\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5cbf5c0b3f0c40feb84eebe71472b463.png)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/99b3ef7c5b91433895c648d4f3657188.png)\n\n---\n\n`如果使用win启动nacos则需要更改win启动脚本文件使用单机启动`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7d5240cba94545bd80a59d61830ee4f3.png)\n`在脚本文件末尾加入pause\nendlocal 可以在启动错误时不闪退，可以看到报错信息`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f3791bfec8844516aa48af647d1a3ba8.png)\n\n## 2.使用openFeign远程调用\n- Feign是一个声明式HTTP客户端，使服务间远程调用更方便，它内置了HTTP请求模板，通过接口和注解就可以定义好HTTP请求的参数等信息。\n- Feign整合了Ribbon（负载均衡）和Hystrix（服务熔断）\n- `这里在微服务版本超过2020时，Feign对负载均衡器做出了调整调整为Spring Cloud Loadbalancer，为此需要引入Spring Cloud Loadbalancer的相关依赖并移除Ribbon引用和增加配置,不然开启远程调用的服务会启动报错`\n\n```java\nspring.cloud.loadbalancer.ribbon.enabled: false\n```\n\n```java\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-loadbalancer</artifactId>\n</dependency>\n```\n---\n\n>引入依赖\n\n```java\n <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n </dependency>\n```\n\n- 远程调用步骤为\n   - 引入open-feign\n   - 在需要远程调用的服务里编写一个接口，这个接口需要调用远程服务\n       - 声明接口的每一个方法都是调用那个远程服务的那个请求\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/40c96b71bf7a4b5cac379ef82dfea0b4.png)\n\n\n   - 开启远程调用功能，在启动类中添加注解@EnableFeignClients(basePackages = \"com.smz.guli.member.feign\")，basePackages表示刚刚创建接口的位置。\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/8099107cd2b841a5a6af9a1700e2b279.png)\n   - 在接口处使用远程调用的接口可获取其它服务接口的值\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/ed8aec878a844c61a60ae62b0a5bce71.png)\n\n\n## 3.Nacos作为配置中心\n- 简介\n>配置中心主要解决的问题是，当需要修改某个服务的配置时，由于服务是集群化和分布式的，修改耗时耗力，配置中心则是统一化，将配置分发给对应的服务，这样就只用配置一遍而使所有服务都读取到配置。\n- 在公共服务中添加依赖\n\n```java\n<dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n```\n\n`如果微服务版本大于2020，则以下形式将需要引入bootstrap的依赖才可以，不导入依赖的方式比较麻烦这里不再赘述`\n\n```java\n <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bootstrap</artifactId>\n            <version>3.1.0</version>\n        </dependency>\n```\n\n- 为了使配置中心的读取在配置文件之前需要创建**bootstrap.properties**文件，springboot中**bootstrap.properties**文件会在**application.yml**之前。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2501289836b7426a87176b9838f4e133.png)\n- 配置配置中心信息\n\n```java\nspring.application.name=guli-coupon\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\n```\n- 给配置中心默认添加一个数据集（Data Id）guli-coupon.properties。默认规则，应用名.properties。\n- 在guli-coupon.properties添加配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/838e45960e804773b1f2def46d96789d.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fd2e36dbcc4d4c519b347172a50ac649.png)\n\n- 动态获取配置\n  - 动态刷新配置注解 **@RefreshScope**\n  - 获取配置值 **@Value(\"${配置项名}\")**\n\n`如果配置中心和配置文件中都配置了，优先使用配置中心的`\n\n## 4.配置中心细节\n\n - 命名空间\n  >配置隔离\n  >- 用来隔离不同环境下的配置（开发、测试、生产）\n  >可以在bootstrap.properties配置指定命名空间\n  >`spring.cloud.nacos.config.namespace=c700d749-47f7-4b10-9116-4fe586a1a2a2`\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/3581a8623fee40ffbed21168d531f6a5.png)\n>- 各个服务间配置隔离\n>每个微服务创建自己的命名空间\n\n\n  `默认：public（保留空间）;默认新增的所有配置都在public空间`\n  \n - 配置集\n >所有的配置的集合\n - 配置集ID\n >Data ID\n - 配置分组\n >`默认所有的配置集都属于DEFAULT_GROUP`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3cb5104cfa4449bcb1b8c17159ef0dda.png)\n>配置分组可以用来区分环境\n>  可以在bootstrap.properties配置指定配置分组\n  >`spring.cloud.nacos.config.group=1111`![在这里插入图片描述](https://img-blog.csdnimg.cn/ea9efc4f1acb4633918b9211ea39bc80.png)\n - 同时加载多个配置集\n在**bootstrap.properties**文件中配置如下代码\n\n```java\nspring.cloud.nacos.config.extension-configs[0].data-id=datasource.yml // Data ID\nspring.cloud.nacos.config.extension-configs[0].group=dev // 配置分组\nspring.cloud.nacos.config.extension-configs[0].refresh=true // 是否动态更新\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/13c5484fbdf84e01bf1b27f515878322.png)\n>微服务中所有的配置都可以交给nacos配置中心管理。配置中心有的优先使用配置中心的\n\n---\n\n# 总结\n本章主要讲了微服务的注册发现和配置中心两个组件。\n\n","tags":["后端","SpringCloud","Nacos","注册中心","配置中心"],"categories":["SpingCloud","Nacos","微服务","后端","组件","项目","谷粒商城"]},{"title":"SpringCloud 学习-Gateway","url":"/2023/06/30/SpringCloud（学习 Gateway）三/","content":"\n# 前言\n\n\n网关的存在就是让请求动态路由到正确的服务，也可以在网关层做鉴权、限流、日志输出等功能的实现。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b98238e28fbf49bc95586327348b2fb0.png)\n\n\n本次网关采用 **Gateway** 进行，不使用**Zuul**。\n\n---\n\n# 一、三大概念\n## 1. Route（路由）\n>请求通过网关路由到对应的服务中。\n\n - ID：通过不同的ID来区分不同路由\n - URI：请求到服务的地址\n - 断言集合\n - 过滤器集合\n \n`注：只要断言为真视为匹配成功`\n## 2. Predicate（断言）\n在请求经过网关时会根据请求头、参数等判断出是否符合某个路由规则\n>官方提供了12种断言规则\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ec6e3a42ccdc4ee384dc8e09faf74732.png)\n![请添加图片描述](https://img-blog.csdnimg.cn/ca30dddbd8cb46959872a58aff458be4.png)\n\n## 3. Filter（过滤器）\n在路由到指定地址时会经过一系列过滤器，当响应请求时也会经过一系列过滤器。\n>官方提供了37种过滤器规则\n---\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf96131760534903874c9e829ec6a554.png#pic_center)\n\n\n\n# 二、整合Gateway\n`建议不要继承common中的依赖，会有很多依赖问题`\n- 1.引入依赖\n>代码如下：微服务的版本为 **2021.0.5**\n\n```java\n<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n<!--        服务注册/发现-->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n<!--        配置中心-->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n<!--        网关依赖-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n            <version>3.1.5</version>\n        </dependency>\n<!--        bootstrap.properties依赖文件适配高版本springcloud-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bootstrap</artifactId>\n            <version>3.1.0</version>\n        </dependency>\n```\n\n- 2.网关服务注册\n\n在启动类添加注解 \n\n```java\n@EnableDiscoveryClient\n```\n- 3.创建命名空间并创建配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/de099be1f77f4ec4b046684f07a185cc.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/01852957c9fe4133ac4935f7033f43d4.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761dcd651ae247b5ab1119ee4d5f7c9d.png)\n- 4.配置端口等信息（application.properties）\n\n```java\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\nspring.application.name=guli-gateway\nserver.port=88\n```\n- 5连接nacos配置（bootstrap.properties）\n\n```java\nspring.application.name=guli-gateway\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\nspring.cloud.nacos.config.namespace=4b130b5f-4b59-4aed-b1f8-2efdd14ae549\n```\n- 6配置网关相关配置（application.yml）\n>目前测试阶段配置写在本地上，以后通过nacos配置中心配置\n\n```java\nspring:\n  cloud:\n    gateway:\n      routes: #是个集合\n        - id: baidu_route #ID\n          uri: https://www.baidu.com #路由转发地址\n          predicates: #断言 是个集合 可配置多个断言\n            - Query=url,baidu #参数断言 url参数为baidu时 断言通过 逗号之后可以使用正则\n          filters: #过滤器 是个集合 \n            - AddRequestHeader=X-Request-red, blue #添加请求头过滤器\n\n        - id: qq_route\n          uri: https://www.qq.com\n          predicates:\n            - Query=url,qq\n\n```\n>具体配置方法、断言、过滤器配置可以查看[官方文档](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories)\n\n---\n\n# 总结\n\n本文主要讲了网关Gateway的简介以及如何在SpringCloud中整合Gateway、一些配置。\n\n","tags":["后端","SpringCloud","Gateway","网关"],"categories":["SpingCloud","Gateway","微服务","后端","组件","项目","谷粒商城","网关","Gateway"]},{"title":"SpringCloud 学习-微服务简介","url":"/2023/06/30/SpringCloud(学习 微服务简介) 一/","content":"\n\n# 前言\n\n本文记录学习SpringCloud微服务学习的过程，通过B站视频《谷粒商城》项目进行学习。\n\n**技术架构为：**\n- 后端：\nSpringboot + SpringCloud + Docker \n- 前端：\nVue + Element-ui\n\n\n---\n# 一、什么是微服务？\n## 1.微服务简介\n>将大型单体应用，基于业务进行服务拆分，每个服务独立部署运行，互不影响。\n\n## 2.集群、分布式、节点\n**集群：**\n>多台服务器，实现相同的业务\n**分布式：**\n>将不同业务部署在不同的服务器上\n\n`分布式中的每一个节点，都可以做集群。而集群并不一定就是分布式`\n\n## 3.远程调用\n在分布式系统中，由于不同服务部署在不同的地方，在服务之间需要进行通讯。\n\n>SpringCloud中使用HTTP+JSON的方式进行远程调用，可以通过不同语言不同平台进行传输，兼容性高。\n\n## 4.负载均衡\n在服务集群中，为了使集群中每个服务器充分利用，采用负载均衡的方式调用独立服务器。\n\n常用负载均衡算法：\n>轮询：从服务器健康池中选择第一个服务器分配给第一个请求，然后按顺序依次向后选择，到最后以后从新开始循环。\n\n>最小连接：优先选择连接数最少的服务器，在会话时间较长优先选择该方式。\n\n>散列：相同IP地址连接相同的服务器，保证特定用户能连接到相同的服务器。如果应用需要处理状态而要求用户连接到相同的服务器，可以采用该方式。\n\n## 5.服务注册/发现、注册中心\n>由于有很多的服务，避免调用到不可用（不在线）的服务，为了感知每个服务的状态，在服务上线时，会在注册中心注册这个服务。在调用某个业务服务时会在注册中心查询相关服务进行调用。\n\n## 6.配置中心\n>每个业务都有大量的配置，而这个业务又会放在多个服务器形成集群，修改配置后需要在大量服务器上修改配置，这样及其不方便。因此才会有配置中心用来给服务进行管理服务配置。\n\n## 7.服务熔断、服务降级\n\n - 服务熔断\n >设置服务的超时，当被调用的服务经常失败达到某个阈值，启用断路保护机制，之后的请求不再去调用这个服务，本地直接返回默认数据。\n - 服务降级\n>在运维期间，当系统处于高压状态，资源紧张，让非核心业务进行降级运行，被降级的业务将不处理或者简单处理（抛异常、返回NULL、调用Mock数据、调用Fallback处理逻辑）\n\n## 8.API网关\n对所有请求进行拦截并处理，保证服务的正常运行，其中处理包括：负载均衡、服务自动熔断、灰度发布、统一认证、限流流控、日志统计等公共功能，解决API管理困难。\n\n![](https://img-blog.csdnimg.cn/2ae8b9442529420894fff1ccb3a8a031.png)\n\n# 二、项目架构\n\n - 微服务架构图\n![项目架构图](https://img-blog.csdnimg.cn/c07c47e2f262426d9a896148367b60c6.png)\n ---\n - 微服务划分图\n\n![微服务划分图](https://img-blog.csdnimg.cn/cd36bb8e4f624796930396c10f01e66a.png)\n\n\n# 三、环境配置\n\n配置开发环境，在虚拟机中进行，虚拟机采用**centos9**这个版本，在虚拟机中安装**docker**，在docker中安装mysql等软件。\n\n - 安装虚拟机\n >我在VM中安装虚拟机，具体安装可网上查询，版本选择centos9这个版本\n \n - 安装Docker-CE(社区版)\n >- Docker官网给了各种虚拟机的安装流程，我安装的是CentOS版本的\n >[CentOS安装流程](https://docs.docker.com/engine/install/centos/)\n >- 启动Docker\n >sudo systemctl start docker（这里sudo是以管理员身份启动，可以使用“su root”命令进入管理员模式）\n >- 设置开机自启\n >sudo systemctl enable docker\n >- 配置镜像加速\n >sudo mkdir -p /etc/docker\n>sudo tee /etc/docker/daemon.json <<-'EOF' { \"registry-mirrors\": [\"https://82m9ar63.mirror.aliyuncs.com\"]\n}\nEOF\n>sudo systemctl daemon-reload\n>sudo systemctl restart docker\n - 在Docker安装mysql\n>- docker pull mysql:5.7\n>- 创建实例并启动\n>docker run -p 3306:3306 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n-v /mydata/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-d mysql:5.7\n参数说明\n-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口\n-v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机\n-v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机\n-v /mydata/mysql/data:/var/lib/mysql/：将配置文件夹挂载到主机\n-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码\n>- 配置自启动\n>docker update mysql --restart=always\n>- 连接mysql \n>查看虚拟机ip使用命令 ：ifconfig -a\n>然后我这里使用navicat连接数据库进行可视化\n\n - 在Docker安装redis\n>- docker pull redi\n>- 创建实例并建立配置文件并启动实例\n>mkdir -p /mydata/redis/conf\n>touch /mydata/redis/conf/redis.conf\n>docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\\n-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n-d redis redis-server /etc/redis/redis.conf\n>- 持久化储存（修改配置文件）\n>docker exec -it redis redis-cli\n>输入“i”进入插入模式\n>appendonly yes（开启持久化）\n>\"ESC\"输入\":wq\"保存退出\n>exit (退出redis)\n>- redis可视化\n>这里我是用IDEA的插件 \"redis\" 可以直接可视化redis\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/ec00eee6ba714276ad58f52cd9a99c18.png)\n\n\n - 新建项目\n>JDK使用1.8，springboot使用2.7.8\n>后台管理使用码云开源项目“[renren-fast](https://gitee.com/renrenio/renren-fast)\"\n>前台使用”[renren-fast-vue](https://gitee.com/renrenio/renren-fast-vue)“\n>后台项目中给了sql的文件\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/9bf6fb953e344dff97b1debdb40c5cef.png)\n - 微服务划分与创建\n >根据服务划分图创建对应服务，其中common为全局服务，储存公共bean和依赖等\n >![在这里插入图片描述](https://img-blog.csdnimg.cn/9ee9df2bc0ff476e85b52572593d51c3.png)\n\n - 利用码云开源项目\"[renren-generator](https://gitee.com/renrenio/renren-generator)\"逆向出每个服务中表的CRUD功能\n >- 在配置文件中配置数据库信息\n >![在这里插入图片描述](https://img-blog.csdnimg.cn/6e5af0ab23e643eab38f3fa4c2fd909c.png)\n >![在这里插入图片描述](https://img-blog.csdnimg.cn/681491be5b4741dea2d26db8fa6a4d43.png)\n\n >- 运行打开web页面后可选择对应表进行生成\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dc099d93e5974d92b40476e8c39a9a15.png)\n>-  将生成的代码替换完成代码生成\n>- 在配置文件配置数据源\n>`spring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://192.168.8.124:3306/guli-pms\n    driver-class-name: com.mysql.jdbc.Driver`\n    >- 配置mybatis-plus(关联xml文件和设置主键自增)\n>`mybatis-plus:\n  mapper-locations: classpath:/mapper/**/*.xml\n  global-config:\n    db-config:\n      id-type: auto`\n      >- 主类扫描实体类\n      >添加注解@MapperScan\n      >@MapperScan(\"com/smz/guli/product/dao\")\n      >- 启动服务\n\n\n","tags":["后端","SpringCloud","Docker"],"categories":["SpingCloud","简介","微服务","后端","Docker","项目","谷粒商城"]},{"title":"用两个栈实现队列","url":"/2023/06/30/用两个栈实现队列/","content":"\n# 问题描述：\n\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n\n---\n\n# 例子\n\n示例 1：\n输入：\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n\n示例 2：\n输入：\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n\n\n---\n# 提示：\n\n1 <= values <= 10000\n最多会对 appendTail、deleteHead 进行 10000 次调用\n\n---\n\n\n# 代码实现：\n## 1.双栈元素翻转：\n>模拟示例二\n```java\n /*\n       题目描述：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n       解题思路：利用栈的特性，添加直接在A栈尾部添加，删除时将A的元素依次出栈并入栈到B中，B出栈尾元素后，将剩余元素依次出栈并入栈到A，此时完成删除。\n     */\n    public static void main(String[] args) {\n        CQueue obj=new CQueue();\n        obj.deleteHead();\n        obj.appendTail(5);\n        obj.appendTail(2);\n        obj.deleteHead();\n        obj.deleteHead();\n    }\n     static class CQueue{\n        Stack<Integer>A,B;\n        public CQueue(){\n            A=new Stack<>();\n            B=new Stack<>();\n        }\n\n        public  void appendTail(int value){//直接入栈\n            System.out.println(\"添加的值为\"+value);\n            A.push(value);\n            System.out.println(\"添加后：\"+A.toString());\n        }\n        public  int deleteHead(){\n            if (A.isEmpty()){//如果为空则返回-1\n                System.out.println(\"队列中没有值可以删\"+A);\n                return -1;\n            }\n            System.out.println(\"删除前:\"+A);\n           while (!A.isEmpty()){//出栈所有元素并入栈到B\n               B.push(A.pop());\n           }\n           int value=B.pop();//删除的元素\n           while (!B.isEmpty()){//重新将B中剩于元素入栈到A\n               A.push(B.pop());\n           }\n            System.out.println(\"删除后：\"+A.toString());\n            System.out.println(\"本次删除的是：\"+value);\n            return value;\n        }\n    \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/53fd16a174624d149674c39f7eba557a.png)\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof)\n","tags":["算法","简单","offer","力扣","栈","队列"],"categories":["力扣","栈"]},{"title":"桶排序及其应用","url":"/2023/06/30/桶排及稳定性汇总/","content":"\n\n---\n\n# 前言\n\n桶排序及其应用\n\n---\n\n\n\n# 一、桶排序流程\n\n相比其它排序，桶排序不基于比较的排序，根据数据状况来排序。应用范围不是很广。\n##  （1）计数排序\n定义一个数组，用来记录每个数出现的次数，数组下标就是值，然后根据排序规则，分别输出每种数的个数。最终就得到有序数组。\n\n>代码如下：\n\n```java\npublic class countSort {\n    public static void main(String[] args) {\n        int []arr={21,1,8,15,15,15,1,1,2,2,3,4,4,4,4};\n        System.out.println(\"排序前:\"+Arrays.toString(arr));\n        countSort(arr);\n        System.out.println(\"排序后:\"+Arrays.toString(arr));\n    }\n    public static void countSort(int[]arr){\n        int max=maxNum(arr);// 最大数\n        int[]help=new int[max+1];// 创建出最大数长度的辅助数组\n        for (int i=0;i<arr.length;i++){\n            help[arr[i]]+=1;// 计数\n        }\n        System.out.println(\"桶子：\"+Arrays.toString(help));\n        int temp=0;\n        for (int j=0;j<help.length;j++){// 出桶\n            if (help[j]!=0){\n                for (int d=0;d<help[j];d++){\n                    arr[temp++]=j;\n                }\n            }\n        }\n    }\n    // 找最大数\n    public static int maxNum(int []arr){\n        int max=0;\n        for (int i:arr){\n            max=Math.max(max,i);\n        }\n        return max;\n    }\n}\n\n\n```\n\n>时间复杂度：O（N）\n>结果如下：\n![!\\[在这里插入图片描述\\](https://img-blog.csdnimg.cn/2ebd86fbfe2e4e97b0bcda10696f326d.png](https://img-blog.csdnimg.cn/de45363093ec4a3c908d058a94d52b8b.png)\n\n\n## （2）基数排序\n准备十个桶，分别对应数字0~9，桶就是个容器，可以是队列，数组，栈等...,最开始将所有数按最多位的数以0补齐位数（【34，789，444】补全为：【034，789，444】），从个位数将数放入对应桶中（034就放入4号桶，789就放入9号桶），然后依次从0 ~ 9号桶的顺序取出一个桶里的遵循先进先出。然后从十位重复，最后到最高位，出桶后就得到有序数组。（优先级是从最高位开始依次递减）。\n>代码如下：\n\n```java\npublic class radixSort {\n    public static void main(String[] args) {\n        int []arr={63,21,80,91,23,42,444,382,45};\n        System.out.println(\"排序前:\"+ Arrays.toString(arr));\n        radixSort(arr);\n        System.out.println(\"排序后:\"+Arrays.toString(arr));\n    }\n    public static void radixSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        radixSort(arr,0,arr.length-1,maxbits(arr));\n    }\n    public static void radixSort(int []arr,int L,int R,int maxBit){\n        final int radix=10;// 10个桶子\n        int i=0,j=0;// j=>当前数的第几位\n        int []bucket=new int[R-L+1];// 辅助数组\n        for (int d=1;d<=maxBit;d++){ // 有多少位就进多少次\n            // 桶子共有maxBit个\n            // 桶子的计数与流程有差别，桶子计数的为小于等于当前下标的个数之和\n            // （第6个桶子是【0，1，2，3，4，5，6，7】的数字的总和）\n            int []count =new int [radix];\n            for (i=L;i<=R;i++){// 取出当前位的数字 入桶\n                j=getDigit(arr[i],d);\n                count[j]++;\n            }\n            for (i=1;i<radix;i++){// 桶子的累加和\n                count[i]=count[i]+count[i-1];\n            }\n            for (i=R;i>=L;i--){// 从右到左遍历，取出对应位 桶中对应数--，摆放位置 出桶\n                j=getDigit(arr[i],d);\n                bucket[count[j]-1]=arr[i];\n                count[j]--;\n            }\n            for (i=L,j=0;i<=R;i++,j++){// 将辅助数中的值给arr准备下一次进桶出桶\n                arr[i]=bucket[j];\n            }\n        }\n    }\n    // 取出一个数中的第d位数字\n    public static int getDigit(int x,int d){\n        return ((x/(int)(Math.pow(10,d-1)))%10);\n    }\n    // 找一个数组内最多有多少位\n    public static int maxbits(int []arr){\n        int max=Integer.MIN_VALUE;\n        for (int j : arr) {// 找出最大值\n            max = Math.max(max, j);\n        }\n        int res=0;\n        while (max!=0){// 循环计位数\n            res++;\n            max/=10;\n        }\n        return res;\n    }\n}\n```\n\n>结果如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/564462c2843a44c7b67e7edd0014bcc3.png)\n\n\n# 二、排序算法的稳定性及其汇总\n## 稳定性\n  ****同样的个体间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。****\n\n 1. 不具备稳定性的排序：\n- 选择排序\n- 快速排序\n- 堆排序\n2. 具备稳定性的排序：\n- 冒泡排序\n- 插入排序\n- 归并排序\n- 一切桶排序思想下的排序\n\n目前按没有找到时间复杂度O(N*logN),空间复杂度O(1)又稳定的排序算法。\n\n|  | 时间复杂度 |额外空间复杂度|稳定性|\n|--|--|--|--|\n| 选择 | O(N^2) |O(1)|×|\n| 冒泡 | O(N^2) |O(1)|√|\n| 插入 | O(N^2) |O(1)|√|\n|归并  | O(N*logN) |O(N)|√|\n| 快排（随机） | O(N*logN) |O(logN)|×|\n| 堆 |O(N*logN)  |O(1)|×|\n\n\n## 坑\n\n - 归并排序的额外空间复杂度可以变成O（1）但会丧失稳定性，而且非常难（归并排序，内部缓存法）\n - 原地归并排序，让时间复杂度变成O（N^2）\n - 快速排序可以做到稳定，但空间复杂度会变为O(N)，而且非常难\n - 目前没有找到时间复杂度O(N*logN),额外空间按复杂度O(1)，又稳定的排序。\n - 奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变。\n\n## 工程上堆排序的改进\n- 充分利用O(N*logN)和O（N^2）排序各自优势\n在快排中，当样本容量小于60时使用插入排序更快（综合排序）\n\n\n- 稳定性考虑\n在系统中使用排序，基础类型，系统会使用快排进行排序；而遇到非基础类型排序时，会使用归并保持稳定性。\n# 总结\n以上就是桶排序的所有内容。\n","tags":["算法","数据结构","排序算法","桶排序"],"categories":["算法","数据结构和算法"]},{"title":"旋转数组中的最小数字","url":"/2023/06/30/旋转数组的最小数字/","content":"# 问题描述：\n\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n\n给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  \n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n\n\n---\n\n# 例子\n\n示例 1：\n输入：numbers = [3,4,5,1,2]\n输出：1\n\n示例 2：\n输入：numbers = [2,2,2,0,1]\n输出：0\n\n\n---\n# 提示：\n\n- n == numbers.length\n- 1 <= n <= 5000\n- -5000 <= numbers[i] <= 5000\n- numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n\n\n\n---\n\n\n# 代码实现：\n>利用二分的思想，因为经过循环后，在最小值两侧都为单调增的，但是最小值左侧的值永远比最小值右侧的值大于或等于，利用中点值和右顶点值作比较，有如下三种情况：\n-   如果中点值比右端点小，说明最小值在中点左侧；\n- 如果中点值比有顶点大，说明最小值在中点右侧；如果相等，不能判断右顶点是否为最小值，但是可以确定\n- 最小值在这个区间之内，将右顶点往前挪，再判断。最坏情况是全部数都一样。\n## 1.二分：\n>时间复杂度：O（logN）  空间复杂度：O（1）；\n```java\npublic static int minArray(int[] numbers) {\n            int left=0;\n            int right=numbers.length-1;\n            while (left<right){\n                int mid=left+((right-left)>>1);\n                if (numbers[mid]<numbers[right]){\n                    right=mid;\n                } else if (numbers[mid]>numbers[right]) {\n                    left=mid+1;\n                }else right -=1;\n            }\n            return numbers[left];\n        }\n```\n\n## 2.运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/24665d4618934355bd01d9b1689960bc.png)\n\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof)\n","tags":["算法","数组","二分","简单","offer","力扣"],"categories":["力扣","数组","二分"]},{"title":"数组中重复的数字","url":"/2023/06/30/数组中重复的数字/","content":"\n# 问题描述：\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n限制：2 <= n <= 100000\n\n---\n\n# 例子\n\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n---\n# 提示：\n\n- 数组中的数都不超过数组长度-1\n\n\n---\n\n\n# 代码实现：\n>    用打标签的方式记录是不是重复的，先创建一个标签数组，从0开始到n-1，再遍历数组。出现过一次就在对应标签标记，发现标签元素中某次出现标记过的返回这个数\n\n   >利用哈希表记录值，每次加入前查找是否存在，不能再则加入，存在则返回\n\n>原地交换，某个数如果对应它自己的位置，则跳过，否则将查看该索引下的值是否与当前值相等，相等就返回，不等则交换\n## 1.标签：\n```java\n public static int findRepeatNumber(int[] nums) {\n        if (nums.length==2)return -1;// 如果数组长度位2直接返回-1\n        int[]label=new int[nums.length];// 标签数组\n        for (int num : nums) {\n            if (label[num] == 0) label[num] = 1;// 标签为0 使其变为1\n            else return num;// 不为1说明重复出现\n        }\n        return -1;// 不存在重复的数\n    }\n```\n## 2.原地交换：\n```java\npublic static int findRepeatNumber2(int[] nums) {\n        if (nums.length==2)return -1;// 如果数组长度位2直接返回-1\n        int i=0;\n        while (i<nums.length){\n            if (nums[i]==i){\n                i++;// 只在与索引值相等才往后，避免某些元素遍历不到\n                continue;\n            }\n            if (nums[nums[i]]==nums[i]) return nums[i];\n            else {// 交换位置\n                int temp=nums[i];\n                nums[i]=nums[temp];\n                nums[temp]=temp;\n            }\n        }\n        return -1;// 不存在重复的数\n    }\n\n```\n\n## 3.运行结果\n>两次错误是因为用异或运算交换位置，然后最后一个测试点过不去\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ac93e8b90c4380a412ec555d1b99f3.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)\n","tags":["数组","简单","offer","力扣"],"categories":["力扣","数组"]},{"title":"归并排序，快排变形应用","url":"/2023/06/30/归并排序，快排变形应用/","content":"\n---\n\n# 前言\n\nO(NlogN)的排序\n\n---\n\n\n\n# 一、数组中点防溢出\n在取一个数组的中点时，传统写法为：\n\n- **mid=(min+max)/2**;  这样会发生（mn+max）溢出。\n- **min+(max-min)/2**; 可以改成这样。\n- **mn+（(max-min)>>1）**;也可以这样。\n\n\n\n\n\n# 二、master公式\n## 1.master公式的使用\n**T（N）=a*T（N/b）+O(N^d)**\n其中T（N）表示母问题规模，a表示子问题调用次数，T（N/b）表示子问题规模，O（N^d）表示其它规模。\n`必须在子问题规模一样的情况下`\n时间复杂度\n- logb^a<d  --->O(N ^ d)\n- logb^a>d   ---> O(N ^logb ^a)\n- logb^a==d  ---> O(N ^d *logN)\n  \n \n\n# 归并排序\n## 1.流程\n将数组沿中点分成两部分,分别将左右两部分先排序，然后申请辅助空间，依次比较 左右两边的数，根据规则将较大或较小数copy到辅助空间，将这一侧往后移一位和另一侧不移动的数比较，以此类推，最终一边越界将另一边剩下的直接copy进辅助空间，就得到了有序数组。\n\n>T（N）=2T（N/2）+O（N）\n>归并排序的时间复杂度为：O（NlogN）\n>额外空间复杂度为：O（N）\n> 代码如下\n\n```java\npublic class mergeSort {\n    public static void process(int []arr,int L,int R){ // 递归\n        if (L==R){\n            return;\n        }\n        int mid=L+((R-L)>>1);// 取中点\n        // 两次递归\n        process(arr,L,mid);\n        process(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n    public static void merge(int []arr,int L,int M,int R){// 比较\n        int[] help=new int[R-L+1];// 辅助空间\n        int i=0;\n        int p1=L; // 左指针\n        int p2=M+1; // 右指针\n        // O（N）\n        while (p1 <= M && p2 <= R){// 比较\n           help[i++]= arr[p1]<=arr[p2]?arr[p1++]: arr[p2++];\n        }\n        // 最终\n        while (p1<=M){\n            help[i++]=arr[p1++];\n        }\n        while (p2<=R){\n            help[i++]=arr[p2++];\n        }\n        // O（N）\n        for (int j=0;j<help.length;j++){\n            arr[L+j]=help[j];\n        }\n    }\n}\n```\n---\n## 2.归并排序拓展\n### （1）求小和问题\n>描述：在一个数组中，每一个数左边比当前的数大累加起来，叫做这个数组的小和。求一个数组的小和。\n例如：\n[1,3,4,2,5],1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、4、2；所以小和为1+1+3+1+1+3+4+2=16。\n\n>思路：转换问题，将求左边比当前数小改为求右边比当前数大的个数，再与该数相乘，最后相加得到小和。\n>例如：\n>1右边比1大的数有4个，就是1*4；3右边比3大的有2个，就是3*2；4右边比4大的有1个，就是4*1；2右边比2大的有1个，就是2*1；5右边没有比5大的数；所以小和为1*4+3*2+4*1+2*1=16。\n\n>利用归并找到小和，在左右两边都排序后，只要左边比右边的小，就要进行小和的累加，当相同时，先复制右边的，这样能更快找完但个数的小和。\n\n```java\npublic class smallSumProblem {\n    public static int process(int []arr, int L, int R){ // 递归\n        if (L==R){\n            return 0;\n        }\n        int mid=L+((R-L)>>1);\n        return process(arr,L,mid) +process(arr,mid+1,R)+merge(arr,L,mid,R); //总小和\n    }\n    public static int merge(int []arr,int L,int M,int R){// 比较\n        int[] help=new int[R-L+1];// 辅助空间\n        int i=0;\n        int p1=L; // 左指针\n        int p2=M+1; // 右指针\n        int res =0;\n        while (p1 <= M && p2 <= R){// 比较 求小和\n            res+=arr[p1]<arr[p2]?(R-p2+1)*arr[p1]:0; // 左边小于右边时，计算小和数\n            help[i++]= arr[p1]<arr[p2]?arr[p1++]: arr[p2++];// 左右两边相等时先拷贝右边的\n        }\n        // 最终\n        while (p1<=M){\n            help[i++]=arr[p1++];\n        }\n        while (p2<=R){\n            help[i++]=arr[p2++];\n        }\n        for (int j=0;j<help.length;j++){\n            arr[L+j]=help[j];\n        }\n        return res;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/4ce416eaf43949438852cdefc3d76419.png)\n\n### （2）逆序对问题\n>描述：在一个数组中，左边的数如果比右边大，则这两个数构成一个逆序对，请打印所有逆序对。\n---\n\n```java\npublic class reversePairProblem {\n    public static void main(String[] args) {\n        int[] arr = {5, 3, 4, 2, 1};\n        process(arr, 0, 4);\n    }\n\n    public static void process(int[] arr, int L, int R) { // 递归\n        if (L == R) {\n            return;\n        }\n        int mid = L + ((R - L) >> 1);\n         process(arr, L, mid);\n         process(arr, mid + 1, R);\n         merge(arr,L,mid,R);\n    }\n    public static void merge(int[] arr, int L, int M, int R) {// 比较\n        int p1 = L; // 左指针\n        int p2 = M + 1; // 右指针\n        while (p1 <= M && p2 <= R) {// 比较\n            if (arr[p1]>arr[p2]){\n                System.out.println(\"[\"+arr[p1]+\",\"+arr[p2]+\"]\");\n                p1++;\n            }else {\n                p2++;\n            }\n\n        }\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/59e2a6119b6b48c69281d8724ff9d01e.png)\n\n## 3.荷兰国旗问题\n### （1）荷兰国旗问题一\n>描述：\n>给定一个数组arr，和一个数num，请把小于等于num的数放在数组左边，大于num的数放在数组的右边，要求额外空间复杂度O(1)，时间复杂度O（N）。\n\n>思路：\n>他并不要求有序，值啊要将小于等于num的数放左边，大于num的数放右边就可以。先规定一个小于等于num的区域area，area起始是arr第一个数的左边，让指针i指向arr第一个数，让arr[i]与num比较，如果比num小或等，就让i+1，让area往右边扩一位，将arr[i]包含其中；如果arr[i]大于num时，i+1,area不变，接着比较下一位，知道有一位比num小时，交换这一位和area下一位数的位置，再将area往下扩一位，以此类推。\n\n```java\npublic class dutchFlagQuestionOne {\n    public static void main(String[] args) {\n        int []arr={3,8,5,3,8,1,2,9,7};\n        int num=5;\n        hollandOne(arr,num);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void hollandOne(int []arr,int num){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        partition(arr,num,0, arr.length-1);\n    }\n    public static void partition(int []arr,int num,int L,int R){\n        int less=L-1;\n        int more=R+1;\n        while (L<more){\n            if (arr[L]<=num){\n                swap(arr,++less,L++);\n            }else {\n                swap(arr,--more,L);\n            }\n        }\n    }\n    //交换方法\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/a75e03cdeb3741b7a111f22f9db649dc.png)\n\n### （2）荷兰国旗问题二\n>描述：\n给定一个数组arr，和一个数num，请把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组的右边，要求额外空间复杂度O(1)，时间复杂度O（N）。\n\n> 思路:\n> 和上一个差不多，只不过多了一个等于的区域\n>  - [i]<num,[i]和小于区下一位交换，小于区右扩一位，i++\n>  -   [i]=num，i++\n>  -  [i]>num,[i]和大于区前一位交换，大于区左扩一位，i不变\n\n```java\npublic class dutchFlagQuestionOne {\n    public static void main(String[] args) {\n        int []arr={3,8,5,3,8,1,2,9,7};\n        int num=5;\n        hollandOne(arr,num);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void hollandOne(int []arr,int num){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        partition(arr,num,0, arr.length-1);\n    }\n    public static void partition(int []arr,int num,int L,int R){\n        int less=L-1;\n        int more=R+1;\n        while (L<more){\n            if (arr[L]<=num){\n                swap(arr,++less,L++);\n            }else {\n                swap(arr,--more,L);\n            }\n        }\n    }\n    //交换方法\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/1e965cf11de343cb8e584ed7a2bdc9c5.png)\n\n## 4.快排\n### （1）快排1（荷兰国旗问题一的递归）\n>将最后一个数作为划分数进行判断，先判断第一个数与划分数的大小关系，如果小于等于划分数，与小于区后一位交换，小于区域右扩一位；如果大于划分数，与大于区前一位数交换，大于区左扩一位，返回小于区与大于区的交界值，进行递归，最终必定能得到一个有序数组。\n>时间复杂度为：O（N^2）\n>空间复杂度为：O（logN）\n\n```java\npublic class quickRowOne {\n    public static void main(String[] args) {\n        int []arr={1,9,4,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        quickSort(arr,0,arr.length-1);\n    }\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            int p=partition(arr,L,R);\n            quickSort(arr,0,p-1);\n            quickSort(arr,p,R);\n        }\n    }\n    public static int partition(int []arr,int L,int R){\n        int less=L-1; // 小于等于区右边界\n        int more=R;// 大于区左边界\n       while (L<more){\n           if (arr[L]<=arr[R]){\n               swap(arr,++less,L++);\n           }else swap(arr,--more,L);\n       }\n        swap(arr,more,R);\n       return more;\n    }\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/e3651b96fdc34e3ba46580ab7af5f008.png)\n\n### （2）快排2（荷兰国旗问题二的递归）\n>在一的基础上添加了=的区域，也就是说=区域的那部分在后面就不用递归排序了。\n>时间复杂度为：O（N^2）\n>空间复杂度为：O（logN）\n```java\npublic class quicksortTwo {\n    public static void main(String[] args) {\n        int []arr={1,9,4,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        quickSort(arr,0,arr.length-1);\n    }\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            int p[]=partition(arr,L,R);\n            quickSort(arr,0,p[0]-1);\n            quickSort(arr,p[1]+1,R);\n        }\n    }\n    public static int[] partition(int []arr,int L,int R){\n        int less=L-1; // 小于等于区右边界\n        int more=R;// 大于区左边界\n        while (L<more){\n            if (arr[L]<arr[R]){\n                swap(arr,++less,L++);\n            }else if (arr[L]>arr[R]){\n                swap(arr,--more,L);\n            }else L++;\n        }\n        swap(arr,more,R);\n        return new int[]{less+1,more};\n    }\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/eeff751387c1457993dbdbba754f4e50.png)\n\n### （3）快排3（随机选取数来划分）\n>选取划分数时，在列表中随机选取一个数，并人为的将其放到列表的最后一位。\n>时间复杂度为：O（N*logN）\n>空间复杂度为：O（logN）\n```java\npublic class quickRowThree {\n    public static void main(String[] args) {\n        int []arr={1,9,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int[]arr){\n       if (arr==null||arr.length<2){\n           return;\n       }\n       quickSort(arr,0,arr.length-1);\n    }\n\n    // 递归排序\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            swap(arr,L+(int)(Math.random()*(R-L+1)),R); // 随机范围数，手动交换到最后一位\n            int[]p=partition(arr,L,R);// 用来确定等于区域边界\n            quickSort(arr,L,p[0]-1);// 小于区域\n            quickSort(arr,p[1]+1,R);// 大于区域\n        }\n    }\n\n    public static int[] partition(int[]arr, int L, int R){\n        int less=L-1; // 小于取右边界\n        int more=R;// 大于区左边界\n        while (L<more){\n            // [i]<num,[i]和小于区下一位交换，小于区右扩一位，i++\n            // [i]=num，i++\n            // [i]>num,[i]和大于区前一位交换，大于区左扩一位，i不变\n            if (arr[L]<arr[R]){\n                swap(arr,++less,L++);\n            }else if (arr[L]>arr[R]){\n                swap(arr,--more,L);\n            }else {\n                L++;\n            }\n        }\n        swap(arr,more,R);\n        return new int[]{less+1,more};\n    }\n    public static void swap(int[]arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/0f4ca14d34364059bafc3a33d8e0af19.png)\n\n---\n# 总结\n\n上文主要讲了master公式的使用，归并排序以及快排逻辑，以及递归解决问题。\n","tags":["算法","数据结构","排序算法","归并排序","快排排序"],"categories":["算法","数据结构和算法"]},{"title":"左旋字符串","url":"/2023/06/30/左旋转字符串/","content":"# 问题描述：\n\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。\n\n限制：1 <= k < s.length <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入: s = \"abcdefg\", k = 2\n输出: \"cdefgab\"\n\n示例 2：\n输入: s = \"lrloseumgh\", k = 6\n输出: \"umghlrlose\"\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>    使用片段拼接的方式，按照需要反转的的地方一分为二，再将两个片段重新拼接就可以了\n\n>    使用遍历拼接字符串的方式，从第n位开始遍历将字符拼接起来，再从头遍历拼接\n## 1.字符串片段拼接：\n>时间复杂度O（n）,空间复杂度O（n）\n>substrin（）方法是将字符串复制一遍，所以时间复杂度位O（n）\n```java\n public static String reverseLeftWords(String s, int n) {\n        //substring:获取字符串某一段\n        return s.substring(n)+s.substring(0,n);\n    }\n```\n## 2.字符串循环遍历拼接：\n>时间复杂度O（n）,空间复杂度O（n）\n\n```java\n public static String reverseLeftWords2(String s, int n) {\n        StringBuilder sb=new StringBuilder();//拼接字符串容器\n        for (int i=n;i<s.length()+n;i++){\n            sb.append(s.charAt(i%s.length())); // 利用取余来减少一个for循环\n        }\n        return sb.toString();\n    }\n\n```\n\n## 3.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ecd863b94667487fa2118de526dcf8bd.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n","tags":["算法","简单","offer","力扣","字符串"],"categories":["力扣","字符串"]},{"title":"奇偶排序（左边为奇数右边为偶数）","url":"/2023/06/30/奇偶排序（左边为奇数右边为偶数）/","content":"\n\n# 问题描述：\n\n\n给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数;并且都要分别有序。\n\n第一行输入整数n。(1<=n<=1000)表示数组大小 第二行输入n个整数a.(1<=n<=100)\n\n---\n\n# 例子\n\n示例 1：\n\n输入：\n6\n3 34 67 89 90 58\n输出：3 67 89 34 90 58\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n## 1.双指针：\n```java\npublic static ArrayList<Integer> solution(int n, ArrayList<Integer> arr){\n        ArrayList<Integer> result = new ArrayList<>();\n        ArrayList<Integer> result2 = new ArrayList<>();\n        int left=0;\n        int right=0;\n        int L=0;\n        int R=n-1;\n        while (L <= R) {// 双指针查找，左指针位偶就去 右指针找奇数，然后交换位置，最后左右指针相遇结束，就得到了左边位奇数，右边为偶数的数组，但是不是有序的的。\n            if (arr.get(L) % 2 == 0) {\n                left = arr.get(L);\n\n                while (true) {\n                    if (L > R) {\n                        break;\n                    }\n                    if (arr.get(R) % 2 != 0) {\n                        right = arr.get(R);\n                        arr.set(L++, right);\n                        arr.set(R--, left);\n\n                        break;\n                    } else {\n                        R--;\n                    }\n                }\n            } else {\n                L++;\n            }\n        }\n        //有序处理\n        for(Integer item:arr){\n            if(item%2==0){\n                break;\n            }\n            result.add(item);\n        }\n        for(int i=n-1;;i--){\n            if(arr.get(i)%2!=0){\n                break;\n            }\n            result2.add(arr.get(i));\n        }\n        arr.clear();\n        Collections.sort(result);\n        Collections.sort(result2);\n        arr.addAll(result);\n        arr.addAll(result2);\n        return arr;\n    }\n```\n---\n## 运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/93bd12f4b9314ecfb304b098108cc3ab.png#pic_center)\n\n---\n题目来源：CSDN\n链接: [CSDN题目](https://edu.csdn.net/skill/program/28795?practiceId=6842155)\n","tags":["算法","数组","简单","offer","力扣"],"categories":["力扣","排序"]},{"title":"复杂链表的复制","url":"/2023/06/30/复杂链表的复制/","content":"# 问题描述：\n\n\n请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n\n\n\n---\n\n# 例子\n\n\n**示例 1：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4f44c4a8168c442fa1d59f911a4446c7.png)\n\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n\n\n**示例 2：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/466e20e591804d579e0d3fe6e3292c08.png)\n\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n\n\n\n**示例 3：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a580fd515b854ae3af2b5d047ae5d483.png)\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n\n\n**示例 4：**\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n\n---\n# 提示：\n\n提示：\n\n- -10000 <= Node.val <= 10000\n- Node.random 为空（null）或指向链表中的节点。\n- 节点数目不超过 1000 。\n\n---\n\n\n# 代码实现：\n>对于简单链表的深拷贝，按照顺序遍历一遍就可以，该题目中存在随机指针，在拷贝时，你不能确定他所指向的结点是否已经创建了。\n\n >所以可以尝试用拆分停留的方式，就是在原链表每个结点后面添加一个和原节点一样的结点，用复制结点的随机指针指向原结点的随机指针的后一个，最后再把两个链表拆开就得到了结果\n## 1.拆分停留：\n>时间复杂度O(N)，空间复杂度O(1)\n```java\npublic Node copyRandomList(Node head) {\n        if (head==null) return null;\n       for (Node node=head;node!=null;node=node.next.next){// 插入每个结点的复制版\n           Node nodeCopy=new Node(node.val);// 创建结点\n           nodeCopy.next=node.next;// 插入\n           node.next=nodeCopy;\n       }\n       for (Node node=head;node!=null;node=node.next.next){// 将复制的随机结点指向原节点指向的下一个结点\n           node.next.random=node.random!=null?node.random.next:null;\n       }\n       Node rt=head.next;// 记录头结点\n       for (Node node=head;node!=null;node=node.next){// 将复制链表和原链表分开\n           Node nodeNew = node.next;\n           node.next=node.next.next;\n           nodeNew.next=node.next!=null?nodeNew.next.next:null;\n       }\n       return rt;\n    }\n```\n---\n\n## 运行截图\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/275d67b0949649c39af91a4bdfe031cc.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n","tags":["算法","数组","offer","力扣","链表","中等"],"categories":["力扣","链表"]},{"title":"复杂度和简单排序算法及位运算的实际问题","url":"/2023/06/30/复杂度和简单排序算法及位运算的实际问题/","content":"# 前言\n数据结构和算法是每个程序员必不可少的一部分，算法培养思维逻辑，而数据结构提供实现思维的载体。\n# 复杂度和简单排序算法\n\n## 复杂度\n### 1.时间复杂度\n是对一个算法流程中发生的常数操作的总结，在总结出的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分为f（N），那么时间复杂度为O（f(N)。\n\n### 2.空间复杂度\n是对一个算法在运行过程中临时占用存储空间大小的一个量度。在常量空间中空间复杂度为S（n）=O(1)，在线新空间和递归空间中空间复杂度都为 S（n）=O(n),在二维空间中空间复杂度为S（n）=O(n*m)。\n## 简单排序算法\n### 1.选择排序算法\n从第一个数开始在其中找到最小的数与其交换位置，一直到最后交换完成，就完成了排序\n```java\n//选择排序\n    public static void selectionSort(int[] arr){\n        //长度不足2的都直接返回\n        if (arr==null||arr.length<2){\n            return;\n        }\n        for (int i=0;i<arr.length-1;i++){\n            int minIndex=i;\n            //找到最小值的下标和值\n            for (int j=i+1;j<arr.length;j++){\n                minIndex=arr[j]<arr[minIndex]?j:minIndex;\n            }\n            //交换位置\n            swap(arr,i,minIndex);\n        }\n    }\n    // 交换两个数的位置\n    public static void swap(int[] arr,int i,int j){\n        int tmp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=tmp;\n    }\n```\n\n### 2.冒泡排序算法\n从开始两个数开始谁大（小）往右移动，一轮就确定了一位，以此类推就可以得到一个有序队列。\n\n```java\n public static void bubbleSort(int[]arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        for (int i=arr.length-1;i>0;i--){\n            for (int j=0;j<i;j++){\n                if (arr[i]>arr[i+1]){\n                    swap(arr,i,i+1);\n                }\n            }\n        }\n    }\n    //交换函数\n    public static void swap(int[]arr,int i,int j){\n        arr[i]=arr[i]^arr[j];\n        arr[j]=arr[i]^arr[j];\n        arr[i]=arr[i]^arr[j];\n    }\n```\n交换中，异或运算中（无进位相加）\n\n- n^0=n\n- n^n=0\n- a^ b=b^a\n- (a^ b)^c=a ^(b ^ c)\n- 一堆数异或，改变顺序，结果不变\n\n不用其它变量交换两个数\n**a=a ^ b;\nb=a ^ b;\na=a ^ b;**\n`a和b值可以一样但储存的内存地址不能相同`\n\n### 3.插入排序算法\n依次做到从0~1、0 ~2、0 ~3...0 ~n位置上有序，也就是说比较当前位置和前一位置的大小，按照排序要求比较移动（升序就把小的往前挪，降序把大的往前挪），移动完成再和前一个数比较，直到不满足条件则跳到下一组进行排序，到最后一组完成时整个数列就是有序的了。\n`插入排序的时间复杂度，会根据原数组的顺序而发生改变，最坏情况下为O（N^2）最好情况下为O（N）`\n\n```java\n   public static void interpolationSort(int[] arr){\n        if (arr == null||arr.length<2){\n            return;\n        }\n        //0~0已经有序\n        for (int i=1;i<arr.length;i++){//0~i有序\n            for (int j=i-1;j>=0&&arr[j]>arr[j+1];j--){//当前数往前换到不能换或者到第一个位置为止\n                swap(arr,j,j+1);\n            }\n\n        }\n    }\n    public static void swap(int[]arr,int i,int j){\n        arr[i]=arr[i]^arr[j];\n        arr[j]=arr[i]^arr[j];\n        arr[i]=arr[i]^arr[j];\n    }\n```\n\n## 异或问题求解\n### 1.数组中只存在一种数出现了奇数次，其它数出现了偶数次，如何找到这种数？\n因为只有一种数出现了偶数次，根据异或运算规则，偶数次 数异或运算都为0，当到奇数次的数时，最后0 ^ 这个数等于他本身，就找到了。\n```java\npublic static void printOddTimesNum1(int[]arr){\n        int eor=0;\n        for (int cur:arr){\n            eor ^=cur;\n        }\n        System.out.println(eor);\n    }\n```\n### 2.数组中只存在两种数出现了奇数次，其它数出现了偶数次，如何找到这两种数？\n当整个数组异或完后最后等于这两个数的异或，也就是这两个数的异或肯定不等于0，也就是这两个数其中位运算中某一位肯定不相同，提取出两个数异或运算后某一位为1的位置，所有的数在这个位置相同的形成一个集合，这里边一定存在这两种数中的一个，则另一个在另外一边，再将一边的数进行异或，由于只有那种数是奇数个，最后异或结果就是这种数，再将 这种数与两种数异或的结果进行异或就得到了另一种数。\n```java\n public static void printOddTimesNum2(int[]arr){\n        int eor=0;\n        for (int cur:arr){\n            eor ^=cur;\n        }\n        //eor=a^b\n        //eor!=0\n        //eor必定有一位不为0\n        int rightOne=eor & (~eor +1);//提取最右侧为1的数  ~eor取反\n        int onlyOne=0;\n        for (int cur:arr){\n            if ((cur & rightOne)==0){\n                onlyOne ^=cur;\n            }\n        }\n        System.out.println(onlyOne+\" \"+(eor ^onlyOne));\n    }\n```\n\n# 总结\n本文简单的介绍了复杂度和几种简单排序算法以及位运算的基本使用。\n","tags":["算法","数据结构","排序算法","复杂度","选择排序","冒泡排序","插入排序"],"categories":["算法","数据结构和算法"]},{"title":"堆结构、堆排序及其应用","url":"/2023/06/30/堆及堆排序应用/","content":"\n\n\n---\n\n# 前言\n\n堆结构、堆排序及其应用\n\n---\n\n\n\n# 一、堆结构\n堆结构是一个数组对象，就是一颗特殊的完全二叉树或是一颗特殊的满二叉树。\n堆分为**大根堆**和**小根堆**。\n>满二叉树：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7d670002d9db47fe8e6563d0e8608858.png)\n\n>完全二叉树：（）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7ba20f01e1e04dcbb0d55d292d5060c6.png)\n\n---\n\n**某个节点i**\n- 左孩子节点下标索引：i*2+1\n- 右孩子节点下标索引：i*2+2\n- 父节点下标索引：(i-1)/2\n---\n\n## 1、大根堆\n每一棵子树的最大值为头节点的值，就为大根堆\n\n>如下\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/210abc6dad0c43d9998868581c19b4c6.png)\n### （1）向上调整（heapInsert）\n调整某个位置能否往上移动\n\n>代码如下：\n\n```java\n// 某个数在index位置能否往上移动\n    public static void heapInsert(int[]arr,int index){\n        while(arr[index]>arr[(index-1)/2]){\n            swap(arr,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n```\n\n### （2）向下调整（heapify）\n某个位置能否往下移动。\n返回最大值并移除：最大值就是第一个值，用最后边那个数代替头节点，整体堆长度减小一，此时需要对这个头节点进行调整，在子孩子中找到最大的再与头节点比较，如果头节点小于子孩子就交换位置，以此类推当子孩子不大于头结点或者没有子孩子时，停止，此时为大根堆。\n>调整代价为：O（logN）\n\n>代码如下：\n\n```java\n    // 某个数在Index位置，能否往下移动\n    public static void heapify(int[]arr,int index,int heapSize){\n        int left=index*2+1; // 左孩子下标\n        while (left<heapSize){ // 如果当前位置有子节点\n            //将两个子孩子大的下标记录\n            int largest=left+1<heapSize && arr[left+1]>arr[left]?left+1:left;\n            //比较父和子哪个值大，值大的记录\n            largest=arr[largest]>arr[index]?largest:index;\n            if (largest==index){ // 符合跳出循环\n                break;\n            }\n            swap(arr,index,largest);\n            index=largest;\n            left=index*2+1;\n        }\n    }\n```\n### （3）合并应用\n当改变其中某个值，可以分别使用向下调整和向上调整，调整过后得到大根堆。\n\n>调整代价为：O（logN）\n## 2、小根堆\n每一棵子树的最小值为头节点的值，就为小根堆,和大根堆刚好相反。\n>如下\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b7c4ead0562f4d8ca1744e25f7b4a826.png)\n\n\n\n# 二、堆排序\n## 1.过程\n不断的从0~1，0 ~2....做到大根堆或小根堆，heapSize为堆长度，每一次新进来个数heapSize++，最终得到堆，然后将最大的与最后一个位置交换，heapSize--，就将最大位置排在了最后并剔除了堆，利用向下调整得到堆，再重复上述步骤，最终heapSize为0时，这个数组就有序了。\n>时间复杂度为：O（NlogN）\n>额外空间复杂度为：O（1）\n\n>代码如下：\n\n```java\npublic class bigRootPile {\n\n    public static void main(String[] args) {\n        int []arr={2,4,5,1,8,2,9,4,3,6};\n        heapSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void heapSort(int[]arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        // O(NlogN)\n        // 可优化\n        for (int i=0;i<arr.length;i++){\n            heapInsert(arr,i);\n        }\n        int heapSize=arr.length;\n        swap(arr,0,--heapSize);\n        while (heapSize>0){\n            heapify(arr,0,heapSize);// O(logN)\n            swap(arr,0,--heapSize);//O(1)\n        }\n    }\n    // 某个数在index位置能否往上移动\n    public static void heapInsert(int[]arr,int index){\n        while(arr[index]>arr[(index-1)/2]){\n            swap(arr,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n    // 某个数在Index位置，能否往下移动\n    public static void heapify(int[]arr,int index,int heapSize){\n        int left=index*2+1; // 左孩子下标\n        while (left<heapSize){ // 如果当前位置有子节点\n            //将两个子孩子大的下标记录\n            int largest=left+1<heapSize && arr[left+1]>arr[left]?left+1:left;\n            //比较父和子哪个值大，值大的记录\n            largest=arr[largest]>arr[index]?largest:index;\n            if (largest==index){ // 符合跳出循环\n                break;\n            }\n            swap(arr,index,largest);\n            index=largest;\n            left=index*2+1;\n        }\n    }\n    // 交换\n    public static void swap(int[]arr,int index,int fIndex){\n        int temp=arr[index];\n        arr[index]=arr[fIndex];\n        arr[fIndex]=temp;\n    }\n}\n\n```\n>结果如下：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/08f94a79e9034ea6b336895a7d4da8ff.png)\n\n`只让一个不为大根堆的变为大根堆可以将以下代码优化`\n\n```java\n for (int i=0;i<arr.length;i++){\n            heapInsert(arr,i);\n        }\n```\n>优化后：\n\n```java\n  for (int i=arr.length-1;i>=0;i--){\n            heapify(arr,i,arr.length);\n        }\n```\n在最后一个数往下调整，做到依次局部大根堆，最终得到大根堆。\n\n# 三、堆排序扩展\n`如果做到高效的进行堆结构的调整，就必须自己手写，而不用系统自带的堆结构，因为系统自带的堆结构在调整时，是从头开始扫描调整`\n\n>**JAVA**中的堆结构：(默认为小根堆)\n>PraiorityQyueue<Integer>heap=new PriorityQueue<>();\n\n## （1）几乎有序数组排序\n已知一个几乎有序数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对则个数据进行排序。\n> 时间复杂度：O（NlogK）\n> 代码如下：\n\n```java\npublic class almostOrdinal {\n    public static void main(String[] args) {\n        int k=2;\n        int []arr={2,8,6,4,14,12,16,16,18};\n        System.out.println(\"排序前：\"+Arrays.toString(arr));\n        almostOrderedSort(arr,k);\n        System.out.println(\"排序后：\"+Arrays.toString(arr));\n    }\n    public static void almostOrderedSort(int[]arr,int k){\n        PriorityQueue<Integer>heap=new PriorityQueue<>();\n        int index=0;\n        for (;index<=Math.min(arr.length,k);index++){// 把前k+1个数放入小根堆（如果k大于数组长度则把整个数组放入）\n            heap.add(arr[index]);\n        }\n        int i=0;\n        for (;index<arr.length;index++){\n            heap.add(arr[index]);// 新加后一位数放到小根堆中\n            arr[i++]= heap.poll();//小根堆弹出最小的数放到i位置\n        }\n        while (!heap.isEmpty()){// 如果没有可加的新数字 依次弹出就行\n            arr[i++]= heap.poll();\n        }\n    }\n}\n```\n\n> 结果如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0c97ec4ae0241ccab0e030a94dd0cdd.png)\n\n# 四、比较器\n自己定义比较策略的类，实质就是重载比较运算符。\n\n# 总结\n\n以上文章主要讲了堆（大根堆、小根堆）和堆排序的思想，以及扩展，和比较器。\n","tags":["算法","数据结构","排序算法","堆结构","堆排序"],"categories":["算法","数据结构和算法"]},{"title":"在排序数组中查找数字 I","url":"/2023/06/30/在排序数组中查找数字 I/","content":"\n# 问题描述：\n\n\n 在排序数组中查找数字 I\n\n---\n\n# 例子\n\n示例 1：\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n\n示例 2：\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n\n\n---\n# 提示：\n\n- 0 <= nums.length <= 105\n- -109 <= nums[i] <= 109\n- nums 是一个非递减数组\n- -109 <= target <= 109\n\n\n---\n\n\n# 代码实现：\n>利用二分寻找左边界和右边界，再相减就是个数\n## 1.二分：\n```java\nclass Solution {\n        public int search(int[] nums, int target) {\n            if(nums.length==0) return 0;// 数组长度为0直接返回\n            int L=0;\n            int R=nums.length;\n            return search(nums,L,R,target+1)-search(nums,L,R,target);// 分别调用二分找边界\n        }\n        // 二分\n        public int search (int[]nums,int L,int R,int target){\n            while(L<R){\n                int mid=L+((R-L)>>1);\n                if(nums[mid]<target){\n                    L=mid+1;\n                }else{\n                    R=mid;\n                }\n            }\n            return R;\n        }\n    }\n```\n\n\n## 2.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/33e4ed6d2b0e404ba1fa89e7d9ee0122.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n","tags":["算法","数组","二分","简单","offer","力扣"],"categories":["力扣","数组"]},{"title":"包含min函数的栈","url":"/2023/06/30/包含min函数的栈/","content":"# 问题描述：\n\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n---\n\n# 例子\n\n示例 1：\n\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.min();   --> 返回 -2.\n\n--- \n# 提示：\n\n各函数的调用总次数不超过 20000 次\n\n---\n\n\n# 代码实现：\n## 1.辅助栈：\n>寻找最小的值，开始时辅助栈入栈一个无穷大数保证在栈中没有元素盗用Min()方法任然是正常的，可以在每一次添加的时候利用辅助栈入栈一个当前最小值min，在出栈时，同时将两个栈出栈并更新min的值为辅助栈顶值，保证min是正确的。\n```java\nstatic class MinStack {\n        Stack<Integer> stack;\n        Stack<Integer> stack2;//辅助栈\n        public int min;//记录最小值\n        public MinStack() {\n            min=Integer.MAX_VALUE;\n            stack=new Stack<>();\n            stack2=new Stack<>();\n            stack2.push(min);\n        }\n\n        public void push(int x) {\n            System.out.println(\"加入的值为：\"+x);\n            stack.push(x);\n            min= Math.min(x, min);//记录最小值\n            stack2.push(min);\n            System.out.println(\"加入后栈为：\"+stack);\n        }\n\n        public void pop() {\n            stack.pop();\n            stack2.pop();\n            min=stack2.peek();//出栈后及时更新min的值\n            System.out.println(\"出栈后栈为:\"+stack);\n        }\n\n        public int top() {\n            System.out.println(\"栈顶元素为：\"+stack.peek());\n            return stack.peek();\n        }\n\n        public int min() {\n            System.out.println(\"最小值为：\"+min);\n            return min;\n        }\n    }\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0ce05eb0fe7452e9c3f1a82912fdcea.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)\n","tags":["算法","简单","offer","力扣","栈"],"categories":["力扣","栈"]},{"title":"从尾到头打印链表","url":"/2023/06/30/从尾到头打印链表/","content":"\n\n# 问题描述：\n\n\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n限制：\n0 <= 链表长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>解题思路：\n>考虑到数组的方式更快，并且限制长度也不是很长，所以一开始想到辅助数组的方式，利用一个辅助数组先将数加入到数组，通过计数得到长度，再从辅助数组末尾依次把数加到返回           数组中，缺点是辅助数组的长度必须为10001；\n            或者利用辅助栈先进后出的特点，先将数压入栈中，最后出栈放入返回数组。\n## 1.辅助数组：\n```java\n  public static int[] reversePrint(ListNode head) {\n          if (head==null) return new int[0];\n          int [] aid = new int[10001];\n          int i=0;\n          while (head != null){\n              aid[++i]= head.val;\n              head=head.next;\n          }\n          int []res=new int[i];\n          for (int j=0;i>0;j++){\n              res[j]=aid[i--];\n          }\n          return res;\n        }\n```\n## 2.辅助栈：\n```java\npublic static int[] reversePrint2(ListNode head) {\n        if (head==null) return new int[0];\n        Stack<Integer>stack=new Stack<Integer>();\n        while (head != null){\n            stack.push(head.val);\n            head=head.next;\n        }\n        int []res=new int[stack.size()];\n        int i=0;\n        while (!stack.isEmpty()){\n            res[i++]=stack.pop();\n        }\n        return res;\n    }\n\n```\n\n## 运行结果：\n>发现数组方式确实要比栈快一点\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a166ae362024fb39e39da0caca8f415.png)\n\n\n\n---\n\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\n","tags":["算法","数组","简单","offer","力扣","栈"],"categories":["力扣","链表"]},{"title":"二进制加法","url":"/2023/06/30/二进制加法/","content":"\n# 问题描述：\n\n给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。\n            输入为 非空 字符串且只包含数字 1 和 0。\n\n---\n\n# 例子\n\n示例 1：\n\n输入: a = \"11\", b = \"10\"\n输出: \"101\"\n\n示例 2：\n输入: a = \"1010\", b = \"1011\"\n输出: \"10101\"\n\n示例 3：\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n\n---\n# 提示：\n\n- 每个字符串仅由字符 '0' 或 '1' 组成。\n- 1 <= a.length, b.length <= 10^4\n- 字符串如果不是 \"0\" ，就都不含前导零。\n\n---\n\n\n# 代码实现：\n## 对位相加：\n>通过对位相加满2进1的思路进行计算，不足位用0代替。\n>字符运算时是通过ASCII码进行计算的，所以在计算时结果应“ -‘0’ ”，取余时应“ +‘0’ ”\n```java\npublic static String addBinary(String a,String b){\n         StringBuilder ans=new StringBuilder();//存字符的\n         int n= Math.max(a.length(), b.length());//选择最长的字符长度\n         int carry=0;//进位计数\n         for (int i=0;i<n;i++){//从最右边开始＋，没有的用0代替\n             carry+=a.length()>i?(a.charAt(a.length()-i-1)-'0'):0;// 字符运算时通过ASCII码进行计算的所以这里要“-‘0’”使其值是对的\n             carry+=b.length()>i?(b.charAt(b.length()-i-1)-'0'):0;\n             ans.append((char)(carry%2+'0'));//取余查看剩下是0还是1\n             carry /=2;//进位是否为1\n         }\n         if (carry==1){//最终最高位判定\n             ans.append('1');\n         }\n         ans.reverse();//翻转\n         return ans.toString();\n     }\n```\n## 运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/57cd83457cbc4d6480be4fc6f8f062ae.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/JFETK5/)\n","tags":["算法","简单","offer","力扣","字符串"],"categories":["力扣","字符串"]},{"title":"二维数组中查找","url":"/2023/06/30/二维数组中的查找/","content":"# 问题描述：\n\n\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n限制：0 <= n <= 1000       0 <= m <= 1000\n\n\n---\n\n# 例子\n\n示例 1：\n现有矩阵 matrix 如下：\n\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n给定 target = 5，返回 true。\n\n给定 target = 20，返回 false。\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n\n## 1.循环二分：\n>每一行用二分查找\n\n>时间复杂度：O（MlogN）    空间复杂度：O（1）\n```java\npublic static boolean findNumberIn2DArray(int[][] matrix, int target) {\n            if (matrix.length == 0 || matrix[0].length == 0) return false;\n            for (int[] ints : matrix) {// 行\n                int left = 0;\n                int right = matrix[0].length - 1;\n                while (left <= right) {// 二分\n                    int half = left + ((right - left) >> 1);\n                    if (ints[half] < target) {\n                        left = half + 1;\n                    } else if (ints[half] > target) {\n                        right = half - 1;\n                    } else return true;\n                }\n            }\n            return false;\n        }\n```\n## 2.仿搜索树：\n>从左下角或者右上角开始找，因为每行开头和结尾的值是极端，相当于搜索二叉树的节点；从左下角找，比目标数大就往上一行找，比目标数小就往下一列找\n\n>时间复杂度：O（M+N）    空间复杂度：O（1）\n\n```java\npublic static boolean findNumberIn2DArray2(int[][] matrix, int target) {\n            if (matrix.length == 0 || matrix[0].length == 0) return false;\n            int i = 0;\n            int j = matrix.length - 1;\n            while (j >= 0) { // 从左下角开始找（也可以从右上角，i--,j++）\n                if (matrix[j][i] > target) j--;// 开头的值大于目标数，往上一行找\n                else if (matrix[j][i] < target) {// 开头的数小于目标数，往下一列找\n                    ++i;\n                    if (i > matrix[0].length - 1) return false;\n                } else return true;\n            }\n            return false;\n        }\n\n```\n\n## 3.运行结果\n###  1、循环二分\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9e58b867aefd439897d82d6fd0c44ad5.png)\n\n###  2、仿搜索树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/053aa26636e248558a7781d77a0a767c.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)\n","tags":["算法","数组","二分","offer","力扣","中等"],"categories":["力扣","数组"]},{"title":"二叉树的识别与应用","url":"/2023/06/30/二叉树的识别与应用/","content":"\n# 前言\n\n>二叉树节点结构：\n\n```java\n  public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data){\n            this.value=data;\n        }\n    }\n```\n\n`代码中实现的二叉树都为图片所示二叉树`\n\n\n# 一、二叉树的先序、中序、后序遍历\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b5239a183a8245ae80862c62bbf94599.png)\n二叉树递归序：1->2->3->3->3->2->4->4->4->2->1->6->7->7->7->6->1\n\n先序：1->2->3->4->6->7\n中序：3->2->4->1->7->6\n后序：3->4->2->7->6->1\n## 1、递归方式（先序、中序、后序）\n```java\npublic class traverse {\n    public static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n\n        System.out.println(\"==============二叉树遍历===============\");\n        System.out.print(\"pree-order: \");\n        preorderTraversal(head);\n\n        System.out.println();\n        System.out.print(\"in-order: \");\n        inorderTraversal(head);\n\n        System.out.println();\n        System.out.print(\"pos-order: \");\n        postOrderTraversal(head);\n\n    }\n    // 树节点\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    //先序遍历\n    public static void preorderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        System.out.print(head.value+\" \");\n        preorderTraversal(head.left);\n        preorderTraversal(head.right);\n    }\n\n    //中序遍历\n    public static void inorderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        inorderTraversal(head.left);\n        System.out.print(head.value+\" \");\n        inorderTraversal(head.right);\n    }\n\n    //后序遍历\n    public static void postOrderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        postOrderTraversal(head.left);\n        postOrderTraversal(head.right);\n        System.out.print(head.value+\" \");\n    }  \n}\n\n```\n\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/dc5e3ca1645e40538685bd0032bae0e0.png)\n\n## 2、非递归（先序、中序、后序）\n\n```java\npublic static void main(String[] args) {\n        traverse.Node head=new traverse.Node(1);\n        head.left=new traverse.Node(2);\n        head.right=new traverse.Node(6);\n        head.left.left=new traverse.Node(3);\n        head.left.right=new traverse.Node(4);\n        head.right.left=new traverse.Node(7);\n\n        System.out.println(\"==============二叉树非递归遍历===============\");\n        preOrderUnRecur(head);\n\n        System.out.println();\n        inOrderUnRecur(head);\n\n        System.out.println();\n        posOrderUnRecur1(head);\n\n\n    }\n    // 树节点\n    public static class Node{\n        public int value;\n        public traverse.Node left;\n        public traverse.Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    //先序遍历\n    public static void preOrderUnRecur(Node head){\n        System.out.print(\"pre-order: \");\n        if (head!=null){\n            Stack<Node> stack=new Stack<Node>();\n            stack.add(head);\n            while (!stack.isEmpty()){\n                head=stack.pop();\n                System.out.print(head.value+\" \");\n                if (head.right!=null){\n                    stack.push(head.right);\n                }\n                if (head.left!=null){\n                    stack.push(head.left);\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    //中序遍历\n    public static void inOrderUnRecur(Node head){\n        System.out.print(\"in-order: \");\n        if (head!=null){\n            Stack<Node>stack=new Stack<Node>();\n            while (!stack.isEmpty() || head != null){\n                if (head!=null){// 把左边界都入栈\n                    stack.push(head);\n                    head=head.left;\n                }else {// 依次弹节点并跳到右结点\n                    head=stack.pop();\n                    System.out.print(head.value+\" \");\n                    head=head.right;\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    // 后序遍历\n    // 用先序遍历的 头右左 逆序输出就是后序遍历\n    public static void posOrderUnRecur1(Node head){\n        System.out.print(\"pos-order: \");\n        if (head!=null){\n            Stack<Node>s1=new Stack<Node>();\n            Stack<Node>s2=new Stack<Node>();\n            s1.push(head);\n            while (!s1.isEmpty()){\n                head=s1.pop();\n                s2.push(head);\n                if (head.left!=null){\n                    s1.push(head.left);\n                }\n                if (head.right!=null){\n                    s1.push(head.right);\n                }\n            }\n            while (!s2.isEmpty()){\n                System.out.print(s2.pop().value+\" \");\n            }\n        }\n        System.out.println();\n    }\n```\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f7d15bb9db1a4283b9b6c6071afd36ac.png)\n\n# 二、宽度优先遍历\n## 1.遍历\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n        System.out.println(\"==========宽度优先遍历===========\");\n        w(head);\n    }\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n    public static void w(Node head){\n        if (head==null){\n            return;\n        }\n        Queue<Node>queue=new LinkedList<>();\n        queue.add(head);\n        while (!queue.isEmpty()){\n            Node cur=queue.poll();\n            System.out.print(cur.value+\" \");\n            if (cur.left!=null){\n                queue.add(cur.left);\n            }\n            if (cur.right!=null){\n                queue.add(cur.right);\n            }\n        }\n    }\n```\n\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/70d8b13a66ac4607b713b277166f4f11.png)\n## 2、最大宽度查找\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n\n        System.out.println(\"==========最大宽度===========\");\n        System.out.println(\"该树最大宽度为： \"+w(head));\n    }\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n    public static int w(Node head){\n        if (head==null){\n            return 0;\n        }\n        Queue<Node> queue=new LinkedList<>();\n        queue.add(head);\n        HashMap<Node,Integer>levelMap=new HashMap<>();\n        levelMap.put(head,1);\n        int curLevel=1;\n        int curLevelNodes=0;\n        int max=Integer.MIN_VALUE;\n        while (!queue.isEmpty()){\n           Node cur=queue.poll();\n           int curNodeLevel=levelMap.get(cur);\n           if (curNodeLevel==curLevel){\n               curLevelNodes++;\n           }else {\n               max=Math.max(max,curLevelNodes);\n               curLevel++;\n               curLevelNodes=1;\n           }\n            if (cur.left!=null){\n                levelMap.put(cur.left,curNodeLevel+1);\n                queue.add(cur.left);\n            }\n            if (cur.right!=null){\n                levelMap.put(cur.right,curNodeLevel+1);\n                queue.add(cur.right);\n            }\n        }\n        max=Math.max(max,curLevelNodes);\n        return max;\n    }\n```\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/eecd7eb2fb0a484f911ab85d7a26fb12.png)\n\n# 三、是否为搜索二叉树\n## 1、搜索二叉树\n>整棵树右子树要大于左子树的值，称该树为搜索二叉树，如图:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b36f09f405b94d3b8eac45d054a76b76.png)\n\n\n## 2、判断搜索二叉树\n利用中序遍历的特点（左中右），如果为是搜索二叉树，则中序遍历是逐渐增大的。\n\n>分为递归和非递归方式\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(8);\n        head.left=new Node(3);\n        head.right=new Node(10);\n        head.left.left=new Node(1);\n        head.left.right=new Node(6);\n        head.left.right.left=new Node(4);\n        head.left.right.right=new Node(7);\n        head.right.right=new Node(14);\n        head.right.right.left=new Node(13);\n        System.out.print(\"递归方式： \");\n        System.out.println(checkBST(head)?\"是一颗搜索二叉树\":\"不是一颗搜索二叉树\");\n        System.out.print(\"非递归方式： \");\n        System.out.println(checkBST2(head)?\"是一颗搜索二叉树\":\"不是一颗搜索二叉树\");\n    }\n\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    public static int preValue=Integer.MIN_VALUE;\n\n    //递归 判断是否为搜索二叉树\n    public static Boolean checkBST(Node head){\n        if (head==null){\n            return true;\n        }\n        boolean isLeftBst=checkBST(head.left);\n        if (!isLeftBst){\n            return false;\n        }\n        if (head.value<=preValue){\n            return false;\n        }else {\n            preValue= head.value;\n        }\n        return checkBST(head.right);\n    }\n\n    //非递归\n    public static int preValue2=Integer.MIN_VALUE;\n    public static Boolean checkBST2(Node head){\n        if (head!=null){\n            Stack<Node>stack=new Stack<Node>();\n            while (!stack.isEmpty() || head != null){\n                if (head!=null){// 把左边界都入栈\n                    stack.push(head);\n                    head=head.left;\n                }else {// 依次弹节点并跳到右结点\n                    head=stack.pop();\n                    if (head.value<=preValue2){\n                        return false;\n                    }else {\n                        preValue2= head.value;\n                    }\n                    head=head.right;\n                }\n            }\n        }\n       return true;\n    }\n```\n\n> 运行结果：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8fa6e7de492b4ea2beca81132842e6f3.png)\n\n\n---\n  >套路递归：\n  >每一颗子树都应该满足：**左子树<父节点<右子树**\n\n>构建信息体：\n\n```java\n public static class ReturnData{// 信息体\n        public boolean isBST;\n        public int min;\n        public int max;\n\n        public ReturnData(boolean is,int min,int max){\n            this.isBST=is;\n            this.min=min;\n            this.max=max;\n        }\n    }\n```\n>加工信息：\n\n```java\npublic static ReturnData process(Node x){\n        if (x==null){\n            return null;\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n        int min=x.value;\n        int max= x.value;\n        if (leftData!=null){// 左子树中最大和最小\n            min=Math.min(min, leftData.min);\n            max=Math.max(max, leftData.max);\n        }\n        if (rightData!=null){// 右子树中最大和最小\n            min=Math.min(min, rightData.min);\n            max=Math.max(max, rightData.max);\n        }\n\n        boolean isBST=true;\n        // 左子树不为空和（左子树>=父节点 或 左子树不为搜索二叉树）\n        if (leftData!=null && (!leftData.isBST || leftData.max>=x.value)){\n            isBST=false;\n        }\n        // 右子树不为空和（右子树<=父节点 或 右子树不为搜索二叉树）\n        if (rightData!=null && (!rightData.isBST ||x.value>=rightData.min)){\n            isBST=false;\n        }\n        return new ReturnData(isBST,min,max);//最终返回\n    }\n```\n\n# 四、是否为完全二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3f9a09e29a6446b9bff0d49d4650b5f4.png)\n\n## 完全二叉树的两个条件\n 1. 某个节点左孩子为空右孩子不能为空\n 2. 在一的条件下遇到过左右两孩子不双全的节点，当前节点不能有叶子节点\n\n> 代码如下\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(3);\n        head.left.left=new Node(4);\n        head.left.right=new Node(5);\n        head.right.left=new Node(6);\n        head.right.right=new Node(7);\n        head.left.left.left=new Node(8);\n        head.left.left.right=new Node(9);\n        head.left.right.left=new Node(10);\n        head.left.right.right=new Node(11);\n        head.right.left.left=new Node(12);\n        System.out.println(\"是否为完全二叉树： \"+isBCT(head));\n    }\n\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data ){\n            this.value=data;\n        }\n    }\n\n    /*\n      判断是否为完全二叉树需要两个条件\n      1、左孩子为空右孩子不能为空\n      2、在一的条件下遇到过左右两孩子不双全的节点，当前节点不能有叶子节点\n     */\n    public static Boolean isBCT(Node head){\n        if (head==null){\n            return true;\n        }\n        LinkedList<Node>queue=new LinkedList<>();\n        boolean leaf=false;// 是否遇到过左右两个孩子不双全的节点\n        Node l=null;\n        Node r=null;\n        queue.add(head);\n        while (!queue.isEmpty()){\n            head=queue.poll();\n            l=head.left;\n            r=head.right;\n            if(\n                    (leaf && (l != null || r != null))\n                    ||\n                            (l==null && r!=null)\n            ){\n                return false;\n            }\n            if (l!=null){\n                queue.add(l);\n            }\n            if (r!=null){\n                queue.add(r);\n            }\n            if (l==null||r==null){\n                leaf=true;\n            }\n        }\n        return true;\n    }\n```\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d9f014f7e2e45eb98a56086f128163d.png)\n\n# 五、是否为满二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/85e6dac612864a7289c4a6dabc6ca174.png)\n## 满二叉树的条件\n\n >记一棵树最大深度为L，所有节点数为N，满二叉树存在以下关系：\n **N=2^L-1**\n \n>构建信息体，只要知道树的高度和节点个数\n\n```java\n public static class ReturnData{\n        public boolean isF;\n        public int height;\n        public int nodes;\n        public ReturnData(boolean isF ,int height,int nodes){\n            this.height=height;\n            this.nodes=nodes;\n            this.isF=isF;\n        }\n    }\n```\n\n>信息处理\n\n```java\n//加工信息\n    public static ReturnData process(Node x){\n        if (x==null){\n            return new ReturnData(true,0,0);\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n\n        boolean isF=true;\n        int height=Math.max(leftData.height,rightData.height)+1;\n        int nodes=leftData.nodes+ rightData.nodes+1;\n        // 是否符合 N=2^L-1\n        if (nodes!=Math.pow(2,height)-1){\n            isF=false;\n        }\n        return new ReturnData(isF,height,nodes);\n    }\n}\n```\n\n>完整代码\n\n```java\n public static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(3);\n        head.left.left=new Node(4);\n        head.left.right=new Node(5);\n        head.right.left=new Node(6);\n        head.right.right=new Node(7);\n        head.left.left.left=new Node(8);\n        head.left.left.right=new Node(9);\n        head.left.right.left=new Node(10);\n        head.left.right.right=new Node(11);\n        head.right.left.left=new Node(12);\n        head.right.left.right=new Node(13);\n        head.right.right.left=new Node(14);\n        head.right.right.right=new Node(15);\n        System.out.println(\"节点数： \"+process(head).nodes);\n        System.out.println(\"高度： \"+process(head).height);\n        System.out.println(\"是否为满二叉树： \"+process(head).isF);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n\n    /*\n    构建信息体\n     */\n    public static class ReturnData{\n        public boolean isF;\n        public int height;\n        public int nodes;\n        public ReturnData(boolean isF ,int height,int nodes){\n            this.height=height;\n            this.nodes=nodes;\n            this.isF=isF;\n        }\n    }\n\n    //加工信息\n    public static ReturnData process(Node x){\n        if (x==null){\n            return new ReturnData(true,0,0);\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n\n        boolean isF=true;\n        int height=Math.max(leftData.height,rightData.height)+1;\n        int nodes=leftData.nodes+ rightData.nodes+1;\n        // 是否符合 N=2^L-1\n        if (nodes!=Math.pow(2,height)-1){\n            isF=false;\n        }\n        return new ReturnData(isF,height,nodes);\n    }\n```\n\n# 六、是否为平衡二叉树\n## 平衡二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/989fe7c9037d492db12bb38368924acb.png =300x300)\n\n>对任何一个子树来说，左数和右树的高度差不超过1。\n\n 1. 左子树为平衡二叉树\n 2. 右子树为平衡二叉树\n 3. |左子树高度-右子树高度|<=1\n \n\n```java\n public static ReturnType process(Node x){\n        if (x==null){\n            return new ReturnType(true,0);\n        }\n        // 递归左右子树返回信息\n        ReturnType leftData=process(x.left);\n        ReturnType rightData=process(x.right);\n\n        // 整颗树高度\n        int height=Math.max(leftData.height, rightData.height)+1;\n        // 三个条件判断\n        boolean isBalanced= leftData.isBalanced && rightData.isBalanced\n                && Math.abs(leftData.height- rightData.height)<2;\n\n        return new ReturnType(isBalanced,height);//最终返回总的\n    }\n```\n\n---\n>在递归结构中左子树和右子树需要的信息都为高度和是否平衡：\n\n```java\npublic static class ReturnType{ // 子树信息结构体\n        public boolean isBalanced;// 是否平衡\n        public int height;// 树高度\n        public ReturnType(boolean isB,int height){// 构造函数\n            this.isBalanced=isB;\n            this.height=height;\n        }\n    }\n```\n\n>完整代码：\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(5);\n        head.left=new Node(3);\n        head.right=new Node(7);\n        head.left.left=new Node(2);\n        head.left.right=new Node(4);\n        head.right.left=new Node(6);\n        System.out.println(\"树高为：\"+isBalanced(head).height);\n        System.out.println(\"是否为平衡二叉树：\"+isBalanced(head).isBalanced);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    public static ReturnType isBalanced(Node  head){// 主函数\n        return process(head);\n    }\n    public static class ReturnType{ // 子树信息结构体\n        public boolean isBalanced;// 是否平衡\n        public int height;// 树高度\n        public ReturnType(boolean isB,int height){// 构造函数\n            this.isBalanced=isB;\n            this.height=height;\n        }\n    }\n    public static ReturnType process(Node x){\n        if (x==null){\n            return new ReturnType(true,0);\n        }\n        ReturnType leftData=process(x.left);\n        ReturnType rightData=process(x.right);\n\n        int height=Math.max(leftData.height, rightData.height)+1;\n        boolean isBalanced= leftData.isBalanced && rightData.isBalanced\n                && Math.abs(leftData.height- rightData.height)<2;\n\n        return new ReturnType(isBalanced,height);\n    }\n```\n\n>运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a54e916bd034bad90c77ec428e10dc7.png)\n# 七、二叉树题目应用\n## 1、最低公共祖先节点\n>题目描述：\n>给定两个二叉树的节点node1和node2,找到他们最低公共祖先节点\n>如图G和F节点的最低公共祖先节点为C，E和G的 最低公共祖先为E。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n\n\n>解题思路：\n>理解版：\n>将其中一个节点往上回溯的其余节点和他本身放到一个集合中，如F节点往上回溯将A、C、F三个节点放入集合中，再将另一个节点往上回溯，每次回溯都去第一个集合查询是否存在该节点，没有就往上回溯，直到第一个出现在第一集合中的节点就是最低公共祖父节点，如G节点往上回溯，发现G、E不存在，最终找到C，C就是该最低祖父节点。\n\n>储存关系集合：\n\n```java\n //迭代将整个树关系储存\n    public static void process(Node head, HashMap<Node,Node>fatherMap){\n        if (head==null){\n            return;\n        }\n        fatherMap.put(head.left,head);\n        fatherMap.put(head.right,head);\n\n        process(head.left,fatherMap);\n        process(head.right,fatherMap);\n    }\n\n```\n\n>回溯查找：\n\n```java\npublic static Node lca(Node head,Node o1,Node o2){\n        HashMap<Node,Node>fatherMap=new HashMap<>();\n        fatherMap.put(head,head);\n        process(head,fatherMap);//储存整棵树各个节点的回溯关系\n        HashSet<Node>set1=new HashSet<>();\n        HashSet<Node>set2=new HashSet<>();\n\n        Node cur=o1;\n        while (cur!=fatherMap.get(cur)){//第一个节点回溯添加\n            set1.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        set1.add(head);// 将头节点添加\n\n        cur=o2;\n        while (cur!=fatherMap.get(cur)){//第二个节点回溯添加\n            set2.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        for (Node node1:set2){\n            for (Node node2 : set1) {\n                if (node1==node2){\n                    return node2;\n                }\n            }\n        }\n```\n\n>**简易版:**\n>  1、当o1是 o2的最低公共祖先或当o2是 o1的最低公共祖先\n        2、o1和o2不互为公共祖先，必须向上回溯才能找到\n\n```java\npublic static Node lca2(Node head,Node o1,Node o2){\n        if (head==null || head==o1 || head==o2){\n            return head;\n        }\n        //以头节点分成左右两个树\n        Node left=lca2(head.left, o1, o2);//左树返回\n        Node right=lca2(head.right, o1, o2);//右树返回\n        if (left!=null && right!=null){// 条件二判断\n            return head;\n        }\n        //左右两棵树，并不都有返回值（条件一）\n        return left!=null ? left:right;\n    }\n```\n\n>完整代码：\n\n```java\n public static void main(String[] args) {\n        Node head=new Node(\"A\");\n        head.left=new Node(\"B\");\n        head.right=new Node(\"C\");\n        head.left.left=new Node(\"D\");\n        head.right.left=new Node(\"E\");\n        head.right.right=new Node(\"F\");\n        head.right.left.left=new Node(\"G\");\n        System.out.println(\"理解版最低祖父公共节点为：\"+lca(head,head.right.left.left,head.right.right).value);\n        System.out.println(\"简洁版最低祖父公共节点为：\"+lca2(head,head.right.left.left,head.right.right).value);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public String value;\n\n        public Node(String data){\n            this.value=data;\n        }\n    }\n\n    /*\n    易理解版\n     */\n    public static Node lca(Node head,Node o1,Node o2){\n        HashMap<Node,Node>fatherMap=new HashMap<>();\n        fatherMap.put(head,head);\n        process(head,fatherMap);//储存整棵树各个节点的回溯关系\n        HashSet<Node>set1=new HashSet<>();\n        HashSet<Node>set2=new HashSet<>();\n\n        Node cur=o1;\n        while (cur!=fatherMap.get(cur)){//第一个节点回溯添加\n            set1.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        set1.add(head);// 将头节点添加\n\n        cur=o2;\n        while (cur!=fatherMap.get(cur)){//第二个节点回溯添加\n            set2.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        for (Node node1:set2){\n            for (Node node2 : set1) {\n                if (node1==node2){\n                    return node2;\n                }\n            }\n        }\n\n        return head;\n    }\n    //迭代将整个树关系储存\n    public static void process(Node head, HashMap<Node,Node>fatherMap){\n        if (head==null){\n            return;\n        }\n        fatherMap.put(head.left,head);\n        fatherMap.put(head.right,head);\n\n        process(head.left,fatherMap);\n        process(head.right,fatherMap);\n    }\n\n\n    /*\n    简洁版：\n        1、当o1是 o2的最低公共祖先或当o2是 o1的最低公共祖先\n        2、o1和o2不互为公共祖先，必须向上回溯才能找到\n     */\n    public static Node lca2(Node head,Node o1,Node o2){\n        if (head==null || head==o1 || head==o2){\n            return head;\n        }\n        //以头节点分成左右两个树\n        Node left=lca2(head.left, o1, o2);//左树返回\n        Node right=lca2(head.right, o1, o2);//右树返回\n        if (left!=null && right!=null){// 条件二判断\n            return head;\n        }\n        //左右两棵树，并不都有返回值（条件一）\n        return left!=null ? left:right;\n    }\n```\n>运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9aa2ac8ab7d04832b63d393c5805fbce.png)\n\n## 2、后继节点\n>题目描述：\n>不通过中序遍历找到某个节点的后继（前继）节点\n>`后继节点就是中序遍历的当前节点的后一个节点，前继相反`\n>如图二叉树中序遍历为：D->B->A->G->E->C->F\n>则B的后继为A，前继为D\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n\n>解题思路：\n\n>后继：\n >1. 当需要找的节点有右子树时，他的后继就是右子树的最左子树（没有最左时就是本身）\n > 2. 当需要找的节点有右子树时，向上寻找节点，直到找到某个节点是该节点头节点的左子树时，该节点的头就是后继\n\n>根据情况一向左一直找最左子树\n\n```java\n // 向左寻找最左子树\n    public static Node getLeftMost(Node node){\n        if (node==null){\n            return null;\n        }\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n```\n\n>根据情况二找\n\n```java\n Node parent=node.parent;\n            while (parent!=null && parent.left!=node){//当前节点是其父亲节点右孩子 情况二\n                node=parent; //往上移动\n                parent=node.parent;\n            }\n            return parent;\n```\n\n>完整代码\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(\"A\");\n        head.left=new Node(\"B\");\n        head.right=new Node(\"C\");\n        head.left.left=new Node(\"D\");\n        head.right.left=new Node(\"E\");\n        head.right.right=new Node(\"F\");\n        head.right.left.left=new Node(\"G\");\n        head.parent=null;\n        head.left.parent=head;\n        head.right.parent=head;\n        head.left.left.parent=head.left;\n        head.right.left.parent=head.right;\n        head.right.right.parent=head.right;\n        head.right.left.left.parent=head.right.left;\n        System.out.println(\"G节点的后继为：\"+getSuccessorNode(head.right.left.left).value);\n    }\n    public static class Node{\n        public String value;\n        public Node left;\n        public Node right;\n        public Node parent;// 指向自己的父节点\n        public Node(String value){\n            this.value=value;\n        }\n    }\n    public static Node getSuccessorNode(Node node){\n        if (node==null){\n            return null;\n        }\n        if (node.right!=null){//情况一\n            return getLeftMost(node.right);\n        }else {//无右子树\n            Node parent=node.parent;\n            while (parent!=null && parent.left!=node){//当前节点是其父亲节点右孩子 情况二\n                node=parent; //往上移动\n                parent=node.parent;\n            }\n            return parent;\n        }\n    }\n    // 向左寻找最左子树\n    public static Node getLeftMost(Node node){\n        if (node==null){\n            return null;\n        }\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n```\n\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c183681319254d358d5bb6a8a3224473.png)\n## 3、二叉树的序列化与反序列化\n>题目描述：\n>从字符串到内存结构的转换叫反序列化，从内存结构到字符串的转换叫序列化\n>以‘#’表示null，节点之间用'_'隔开\n>如图所示二叉树的先序为：A_B_D_C_E_G_F\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n### （1）二叉树的序列化\n\n```java\n public static String serialByPre(Node head){\n        if (head==null){\n            return \"#_\";\n        }\n        String res=head.value+\"_\";\n        res+=serialByPre(head.left);\n        res+=serialByPre(head.right);\n        return res;\n    }\n```\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d29624b16513492997b1126ba55ca39e.png)\n\n### （1）二叉树的反序列化\n\n```java\n//反序列化主函数\n    public static Node reconByPreString(String preStr){\n        String[]values=preStr.split(\"_\");\n        Queue<String> queue = new LinkedList<String>(Arrays.asList(values));//将每一项复制给队列\n        return reconPreOrder(queue);\n    }\n    //反序列化处理\n    public static Node reconPreOrder(Queue<String>queue){\n        String value=queue.poll();\n        if (Objects.equals(value, \"#\")){\n            return null;\n        }\n        Node head=new Node(value);\n        head.left=reconPreOrder(queue);//左树反序列\n        head.right=reconPreOrder(queue);//右树反序列\n        return head;\n    }\n```\n## 4、折纸条问题\n>问题描述：\n>一个纸条向自己的方向向上折N次，依次打印折痕方向（折痕向外为‘凹’，向内为‘凸’）。\n>\n>如折一次时，纸条的折痕为‘凹’；折两次时，折痕为‘凹凹凸’；三次时，折痕为‘凹凹凸凹凹凸凸’。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e99ffb2d6da4b91b3ffdb5dc46f9c7e.png)\n\n\n\n>解题思路：\n>经过模拟发现折痕是一颗总头节点为‘凹’ 左子树为‘凹’，右子树为‘凸’的满树，如果打印折痕就是将这棵树中序遍历。\n\n>代码实现\n\n```java\npublic static void main(String[] args) {\n        int N=3;\n        printAllFolds(N);\n    }\n    public static void printAllFolds(int N){\n        printProcess(1,N,true);\n    }\n    /*\n       i为节点层数\n       N为共几层\n       down == true 凹\n       down == false 凸\n     */\n\n    public static void printProcess(int i,int N,boolean down){\n        if (i>N){// 超过就返回\n            return;\n        }\n        //中序遍历\n        printProcess(i+1,N,true);\n        System.out.println(down?\"凹\":\"凸\");\n        printProcess(i+1,N,false);\n    }\n```\n\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cc2e0bb98867458dac22165e5cedea55.png)\n\n# 总结\n\n\n本文简单介绍了二叉树的三种遍历，以及相关二叉树的识别以及一些二叉树的应用题。\n\n","tags":["二叉树","数据结构","二叉树遍历","搜索二叉树"],"categories":["二叉树","数据结构和算法"]},{"title":"两数之和II-输入有序数组","url":"/2023/06/30/两数之和II-输入有序数组/","content":"\n# 问题描述：\n\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n你所设计的解决方案必须只使用常量级的额外空间。\n\n---\n\n# 例子\n\n示例 1：\n\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n示例 2：\n\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n示例 3：\n\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n\n---\n# 提示：\n\n - 2 <= numbers.length <= 3 * 104\n- -1000 <= numbers[i] <= 1000\n- numbers 按 非递减顺序 排列\n- -1000 <= target <= 1000\n- 仅存在一个有效答案\n\n---\n\n\n# 代码实现：\n## 1.双指针：\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n       int left =0;\n       int rigth=numbers.length-1;\n       while(left<rigth){\n           if(numbers[left]+numbers[rigth]==target){\n               return new int []{left+1,rigth+1};\n           }else if(numbers[left]+numbers[rigth]<target){\n               left++;\n           }else rigth--;\n       }\n       return new int[]{};\n    }\n}\n```\n## 2.二分：\n`使用二分时我发现会超时，但是暴力求解不会`\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        for(int i=0;i<numbers.length-1;i++){\n          int left =i+1;\n          int rigth=numbers.length-1;\n          while(left<=rigth){\n               int mid=left+((rigth-left)>>1);\n           if(numbers[mid]==target-numbers[i])return new int[]{i+1,mid+1};\n           else if (numbers[mid] > target - numbers[i]){\n              rigth=mid-1; \n           }\n           else rigth=mid+1;\n           }\n        }\n       return new int[]{-1,-1};\n    }\n}\n\n```\n\n## 3.暴力求解\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int temp2[]=new int[2];\n        for(int i=0;i<numbers.length;i++){\n            int temp=target-numbers[i];\n            for(int j=i+1;j<numbers.length;j++){\n               if(numbers[j]==temp){\n                   temp2[0]=i+1;\n                   temp2[1]=j+1;\n                   return temp2;\n               }\n            }\n        }\n        return temp2;\n    }\n}\n\n```\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)\n","tags":["算法","数组","简单","offer","力扣"],"categories":["力扣","整数"]},{"title":"Webpack5核心原理与应用实践（基础用法)一","url":"/2023/06/30/Webpack5核心原理与应用实践（基础用法）一/","content":"\n---\n\n# 前言\n\n记录Webpack基本配置规则；根据场景、技术栈运用具体方法、工具与技巧。\n主要有：搭建完善的JavaScript、CSS开发环境；搭建微前端、NPM包、桌面应用等。\n\n---\n# 一、Webpack配置项\n##  1.Webpack编译流程\n>Webpak原生配置项数不胜数，最终都会作用于不同阶段\n\n>大致编译流程可分为四个流程：\n>\n>**输入**--->**模块处理**--->**后处理**--->**输出**\n\n - **输入**：从文件系统读入代码文件\n - **模块递归处理**：调用 Loader 转译 Module（模块） 内容，并将结果转换为 **AST**（抽象语法树），从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；\n- **后处理**：所有模块递归处理完毕后开始执行后处理，包括**模块合并**、**注入运行时**、**产物优化**等，最终输出 **Chunk** （按照某种规则的模块集合）集合；\n- ****输出****：将Chunk写出到外部文件系统；\n\n--- \n##  2.Webpack配置\n\n>Webpack配置项可分为两大类\n\n - **流程类**：作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项\n - **工具类**：打包主流程之外，提供更多工程化工具的配置项\n\n###  （1）流程类配置\n>与流程类配置强相关配置有：\n\n - 输入输出：\n   - `entry`：用于定义项目入口文件，**Webpack** 会从这些入口文件开始按图索骥找出所有项目文件；  \n   - `context`：项目执行上下文路径；\n   - `output`：配置产物输出路径、名称等；\n - 模块处理：\n   - `resolve`：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块\n   - `module`：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 **Loader** 进行处理\n   - `externals`：用于声明外部资源，**Webpack** 会直接忽略这部分资源，跳过这些资源的解析、打包操作\n - 后处理：\n    - `optimization`：用于控制如何优化产物包体积，内置 **Dead Code Elimination**、**Scope Hoisting**、代码混淆、代码压缩等功能\n    - `target`：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异\n    - `mode`：编译模式短语，支持 development、production 等值，可以理解为一种声明环境的短语\n\n>**Webpack** **首先**需要根据输入配置(`entry/context`) 找到项目入口文件；**之后**根据按模块处理(`module/resolve/externals` 等) 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，**最后**再根据后处理相关配置项(`optimization/target` 等)合并模块资源、注入运行时依赖、优化产物结构等。\n\n---\n###  （2）工具类配置\n>除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具，大体上可划分为：\n- 开发效率类：\n  - `watch`：用于配置持续监听文件变化，持续构建\n  - `devtool`：用于配置产物 Sourcemap(储存代码转换前后的对应位置信息) 生成规则\n  - `devServer`：用于配置与 HMR(模块热更新) 强相关的开发服务器功能\n- 开发效率类：\n  - `cache`：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果\n  - ` performance`：用于配置当产物大小超过阈值时，如何通知开发者\n- 日志类：\n   - `stats`：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用\n   - `infrastructureLogging`：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件\n\n---\n\n##  3.配置逻辑\n\n>文件结构如下：\n\n```bash\n.\n├── src\n|   └── index.js\n└── webpack.config.js\n```\n>其中，`src/index.js` 为项目入口文件，`webpack.config.js` 为 **Webpack** 配置文件。在配置文件中，首先我们需要声明项目入口：\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: \"./src/index\"\n};\n```\n\n>声明产物输出路径：\n\n```javascript\n// webpack.config.js\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: \"./src/index\",\n  output: {\n    filename: \"[name].js\",\n    path: path.join(__dirname, \"./dist\"),\n  }\n};\n```\n>在前端项目中经常需要处理 JS 之外的其它资源，包括 css、ts、图片等，此时需要为这些资源配置适当的加载器：\n\n```javascript\n// webpack.config.js\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: \"./src/index\",\n  output: {\n    filename: \"[name].js\",\n    path: path.join(__dirname, \"./dist\"),\n  },\n  module: {\n    rules: [{\n      test: /\\.less$/i,\n      include: {\n        and: [path.join(__dirname, './src/')]\n      },\n      use: [\n        \"style-loader\",\n        \"css-loader\",\n        // \"./loader\",\n        {\n          loader: \"less-loader\",\n        },\n      ],\n    }],\n  },\n};\n```\n\n# 二、脚手架工具\n>对于项目的推进，配置管理将十分困难。所以社区提供了对应的脚手架工具来管理配置。\n\n - [Vue CLI](https://cli.vuejs.org/zh/guide/index.html)：用于帮助用户快速创建、运行 **Vue.js** 项目脚手架的命令行工具；\n - [create-react-app](https://zh-hans.reactjs.org/)：用于创建 **React** 项目脚手架的命令行工具；\n - @[angular/cli](https://angular.io/cli)：用于创建 **angular** 项目的命令行工具；\n - [webpack-cli](https://www.npmjs.com/package/webpack-cli)：Webpack 官方提供的命令行工具，提供了一套交互式生成配置文件的指令集，以及项目编译、开发、迁移等功能；\n - [Neutrino](https://neutrinojs.org/installation/create-new-project/)：用于快速创建、运行现代 JavaScript 应用的工具，同时支持 React、Preact、Vue、Web、Node.js、Library 等场景；\n - [react-starter-kit](https://github.com/kriasoft/react-starter-kit)：用于创建 React + Relay + GraphQL 应用的脚手架工具，内置 SSR 支持。\n\n## 1. Vue CLI 搭建项目脚手架\n>**Vue CLI** 底层调用 Webpack 实现针对 .vue 等资源的编译打包功能；调用 **webpack-dev-server** 实现包含 **HMR** 功能的开发服务器功能；还能通过插件方式整合 **ESLint**、**Babal**、**Less** 等工具。\n\n>安装依赖：（安装完成后 可以使用 vue -V 测试是否安装成功）\n\n```javascript\nnpm install -g @vue/cli\n\n# 或者使用 yarn\nyarn global add @vue/cli\n```\n\n>创建项目：`vue create` 命令 (可使用 `vue create --help` 命令查看 create 的参数列表 `仅限于 vue3中使用`)\n\n```javascript\nvue create 项目名\n```\n\n>执行 create 命令后，CLI 会进一步询问使用何种脚手架方案：\n>通常使用第三种自定义\n\n```javascript\nVue CLI v4.5.15\n? Please pick a preset: (Use arrow keys)\n❯ Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n  Manually select features\n```\n\n>vue2使用 `vue init webpack 项目名` 来构建项目\n>基本回车就行倒数四项根据自身需求来\n\n```javascript\n Project name webpack5-dispose\n? Project description A Vue.js project\n? Author xxx <邮箱>\n? Vue build standalone\n? Install vue-router? Yes\n? Use ESLint to lint your code? No\n? Set up unit tests No\n? Setup e2e tests with Nightwatch? No\n? Should we run `npm install` for you after the project has been created? (recommended) yarn\n```\n>Vue CLI 底层依赖于 Webpack 实现编译打包等工程化能力，开发者可通过 `configureWebpack` 与 `chainWebpack` 配置项修改 Webpack 配置信息。\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  configureWebpack: {\n    plugins: [\n      new MyAwesomeWebpackPlugin()\n    ]\n  }\n}\n```\n>configureWebpack 的配置规则与 Webpack 一致，同样支持 plugins/module/resolve 等配置项。实际上，Vue CLI 内部最终会调用 webpack-merge 将 configureWebpack 值与其它上下文配置合并，生成最终的 Webpack 配置信息。\n\n```javascript\n// vue.config.js\nmodule.exports = {\n  chainWebpack: config => {\n    config.module\n      .rule('vue')\n      .use('vue-loader')\n        .tap(options => {\n          // modify the options...\n          return options\n        })\n  }\n}\n```\n\n\n\n>使用 inspect 命令生成完整的 Webpack 配置信息：\n\n```javascript\nvue inspect > output.js\n```\n---\n\n## 2. CRA 搭建项目脚手架\n>使用如下代码可使用CRA创建一个react项目，webStrom创建react项目时可选CRA创建项目\n```javascript\nnpx create-react-app [项目名称]\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3a38afb0ffb947fd8b580b1e20d4c1e6.png)\n\n---\n\n**默认规则创建的脚手架包含如下工程能力：**\n\n - JSX、ES6、TypeScript、Flow 语法支持\n- CSS 自动添加 --webkit-- 前缀\n- 基于 Jest 的自动化测试能力\n- 支持 HMR 的开发服务器\n- 等等\n\n---\n\n>必要时，也可以通过 `npm run eject` 命令导出完整的项目配置结构：\n>注意：可能有未被管理的文件需要先提交在使用该命令\n>会生成对应的配置：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e44bb85aa894d4f94139ec39e9be2e2.png)\n>导出配置后，直接修改 `webpack.config.js` 等相关配置文件即可控制各项功能行为。\n\n---\n\n# 三、如何借助 Babel+TS+ESLint 构建现代 JS 工程环境\n##  1.使用Babel\n>作用：用于将代码向后兼容，在旧版本JS引擎中运行\n>因为ES6提供了许多JS新特性，这就会导致旧版本的**JS**和**Node**等产生兼容性问题，**Babel**就是解决这个问题，它会将代码转译成旧版本的代码，使得旧版本引擎能正常使用。\n\n```javascript\n// 使用 Babel 转译前\narr.map(item => item + 1)\n\n// 转译后\narr.map(function (item){\n  return item + 1;\n})\n```\n>Webpack 场景下，只需使用 `babel-loader` 即可接入 Babel 转译功能：\n\n 1. 安装依赖\n \n\n```javascript\nnpm i -D @babel/core @babel/preset-env babel-loader\n```\n\n 2. 添加模块处理规则\n\n```javascript\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 规则 表示所有.js后缀文件\n        use: ['babel-loader'], // 使用babel-loader处理\n      },\n    ],\n  },\n};\n```\n\n 3. 执行编译命令\n\n```javascript\nnpx webpack\n```\n4. 可以使用 .babelrc 文件或 rule.options 属性配置 Babel 功能逻辑\n\n```javascript\n// 预先安装 @babel/preset-env\n// npm i -D @babel/preset-env\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              presets: ['@babel/preset-env'],\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n```\n>@babel/preset-env是Babel预设规则集----Preset，可以使用各种Preset资源：\n\n - `babel-preset-react`：包含 React 常用插件的规则集，支持 `preset-flow`、`syntax-jsx`、`transform-react-jsx` 等；\n- `@babel/preset-typescript`：用于转译 TypeScript 代码的规则集\n- `@babel/preset-flow`：用于转译 Flow 代码的规则集\n\n###  vue-cli\n>在文件`build/webpack.base.conf.js`中脚手架已经配置了`相关的配置项，但我们依然可以在`webpack.config.js`中修改一些配置\n>`entry`入口文件\n\n```javascript\nentry: {\n    app: './src/main.js'\n  },\n```\n\n>`output`编译产物的目标位置\n```javascript\noutput: {\n    path: config.build.assetsRoot,\n    filename: '[name].js',\n    publicPath: process.env.NODE_ENV === 'production'// 判断是什么环境\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n```\n>`resolve`解析规则\n```javascript\n  resolve: {\n    extensions: ['.js', '.vue', '.json'],//文件扩展名\n    alias: {// 别名\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n```\n>`modele`解析模块\n\n```javascript\n module: {\n    rules: [\n      {\n        test: /\\.vue$/, // 规则过滤条件，这里表示对所有 .vue 后缀文件\n        loader: 'vue-loader',// vue-loader处理\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('img/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('media/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n        }\n      }\n    ]\n  },\n```\n\n###  CRA\n>在`config/webpack.config.js`中已经有脚手架给我门配置的一些\n```javascript\nmodule: {\n    rules: [\n      {\n        test: /\\.js$/,// 声明该规则过滤文件，只有路径和文件类型对应才会生效，此处为所有的 .js 后缀的文件生效\n        loader: 'babel-loader',// 所有命中文件传入Loader序列做转译\n        include: [resolve('src'), resolve('test'), //包内容路径 这里时src和test下的文件  \n        resolve('node_modules/webpack-dev-server/client')]// 以及node_modules中自己的包\n      }\n    ]\n  }\n```\n>不光配置了程序内的文件，还配置了文件外\n\n```javascript\n{\n              test: /\\.(js|mjs)$/,\n              exclude: /@babel(?:\\/|\\\\{1,2})runtime/,\n              loader: require.resolve('babel-loader'),\n              options: {\n                babelrc: false,\n                configFile: false,\n                compact: false,\n                presets: [\n                  [\n                    require.resolve('babel-preset-react-app/dependencies'),\n                    { helpers: true },\n                  ],\n                ],\n                cacheDirectory: true,\n                // See #6846 for context on why cacheCompression is disabled\n                cacheCompression: false,\n                \n                // Babel sourcemaps are needed for debugging into node_modules\n                // code.  Without the options below, debuggers like VSCode\n                // show incorrect code and set breakpoints on the wrong lines.\n                sourceMaps: shouldUseSourceMap,\n                inputSourceMap: shouldUseSourceMap,\n              },\n            },\n```\n\n---\n\n##  2.使用 TypeScript\n>作用：提供了一系列类型约束，能更早的发现错误，确保运行阶段的类型安全性，适合在多人协作的项目中使用。\n\n>**Webpack** 有很多种接入 TypeScript 的方法，包括 `ts-loader`、`awesome-ts-loader`、 `babel-loader`。通常可使用 `ts-loader` 构建 **TypeScript** 代码：\n\n\n>Vue CLi和 CRA均使用`babel-loader`引入TypeScript\n\n 1. 安装依赖\n \n\n```javascript\nnpm i -D @babel/preset-typescript\n```\n2. 配置 Webpack\n\n```javascript\n// 预先安装 @babel/preset-env\n// npm i -D @babel/preset-env\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              presets: ['@babel/preset-typescript'],\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n```\n>`@babel/preset-typescript`只是做了简单的代码转换，未做类型检查等,可以使用其它Preset\n\n--- \n\n##  3.使用 ESLint\n>js作为一种灵活、弱类型脚本语言，对于一些开发过程中产生的语法、类型导致影响稳定的错误，这对开发效率和质量造成影响，**ESLint**就是为了解决这些问题。\n\n>作用：JS代码风格检查器，能将违反规则的代码修复。\n\n>Webpack 下，可以使用 `eslint-webpack-plugin` 接入 ESLint 工具，步骤：\n\n 1. 安装依赖\n \n\n```javascript\n# 安装 webpack 依赖\nyarn add -D webpack webpack-cli\n\n# 安装 eslint \nyarn add -D eslint eslint-webpack-plugin\n\n# 简单起见，这里直接使用 standard 规范\nyarn add -D eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node\n```\n2. 在项目根目录添加 .`eslintrc` 配置文件，内容：\n\n```javascript\n// .eslintrc\n{\n  \"extends\": \"standard\"\n}\n```\n3. 添加 `webpack.config.js` 配置文件，补充 `eslint-webpack-plugin` 配置：\n\n```javascript\n// webpack.config.js\nconst path = require('path')\nconst ESLintPlugin = require('eslint-webpack-plugin')\n\nmodule.exports = {\n  entry: './src/index',\n  mode: 'development',\n  devtool: false,\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  // 添加 eslint-webpack-plugin 插件实例\n  plugins: [new ESLintPlugin()]\n}\n```\n4. 执行编译命令\n\n```javascript\nnpx webpack\n```\n\n>也可以使用第三方扩展来进行特殊的代码风格检测\n\n - `eslint-config-airbnb`：Airbnb 提供的代码风格规则集，算得上 ESLint 生态第一个成名的规则集合\n- `eslint-config-standard`：Standard.js 代码风格规则集，史上最便捷的统一代码风格的方式\n- `eslint-plugin-vue`：实现对 Vue SFC 文件的代码风格检查\n- `eslint-plugin-react`：实现对 React 代码风格检查\n- `@typescript-eslint/eslint-plugin`：实现对 TypeScript 代码风格检查\n- `eslint-plugin-sonarjs`：基于 Sonar 的代码质量检查工具，提供圈复杂度、代码重复率等检测功能\n\n# 总结\n\n本文主要记录了Webpack配置底层逻辑结构以及如何借助Babel、TS、ESLint构建JS环境\n","tags":["前端","Webpack","Babel","ESLint","TypeScript"],"categories":["前端","Webpack"]},{"title":"vue项目各方面的一些优化","url":"/2023/06/30/vue项目的一些优化/","content":"---\n\n# 前言\n主要记录vue项目的一些优化\n\n---\n\n\n# 一、渲染优化\n##  v-for\n>避免v-if和v-for的同级使用，v-for的优先级比v-if高，会导致数据渲染错误\n\n>v-for设置key的值，尽量不适用index，使用数据中唯一的标识，有利于dom的定位与diff。\n\n---\n##  v-show和v-if的选择\n>经常复用的组件用v-show来渲染（v-show是隐藏不销毁）\n>相反则用v-if（直接判断是否创建）\n\n---\n##  长列表优化\n###  纯粹做数据展示，不需要热更新\n>处于data中的数据会被监视，发生变化时数据就发生变化\n>所以采用object.freeze（数据）方法冻结数据。\n\n\n###  长列表\n>采用虚拟滚动，只渲染少部分区域的内容\n>只渲染视口部分的数据，也就是说渲染的DOM节点个数是固定的\n\n>页面：\n```html\n<template>\n  <div>\n    <div>\n      <span v-if=\"list.length===0\">暂无数据！！！</span>\n      <div v-else class=\"box\" :style=\"`height:${viewH}px;overflow-y:scroll;`\" @scroll=\"handleScroll\">\n        <ul>\n          <li :style=\"`transform:translateY(${offsetY}px); height:${itemH}px;`\" v-for='i in clist' :key=\"i\">{{ i }}</li>\n        </ul>\n      </div>\n    </div>\n    <button @click=\"gotoCSSLongList\" class=\"but\">CssLongList</button>\n  </div>\n</template>\n```\n\n>逻辑：\n\n```javascript\n<script>\nexport default {\n  name: \"LongListOne\",\n  data() {\n    return {\n      list: [],//上万条总数据\n      clist: [],// 页面展示数据\n      viewH: 500, // 可视box高度\n      itemH: 60, // 单项高度\n      scrollH: '', // 整个滚动列表高度\n      showNum: '',//可视化高度一次能装几个列表\n      offsetY: 0// 动态偏移量\n    }\n  },\n  mounted() {\n    for (let index = 0; index < 100000; index++) {// 10万条数据\n      this.list.push(index)\n    }\n    this.scrollH = this.list.length * this.itemH;// 计算总高度\n    // 计算可视化高度一次能装几个列表, 多设置几个防止滚动时候直接替换\n    this.showNum = Math.floor(this.viewH / this.itemH) + 4\n    // 默认展示几个\n    this.clist = this.list.slice(0, this.showNum);\n    this.lastTime = new Date().getTime()\n  },\n  computed: {},\n  methods: {\n    // 滚动监视器\n    handleScroll(e) {\n      let {lastTime,itemH,list}=this\n      if (new Date().getTime() - lastTime > 10) {\n        let scrollTop = e.target.scrollTop // 滚去的高度\n        // 每一次滚动后根据scrollTop值获取一个可以整除itemH结果进行偏移\n        // 例如: 滚动的scrllTop = 1220  1220 % this.itemH = 20  offsetY = 1200\n        this.offsetY = scrollTop - (scrollTop % itemH)\n        //上面卷掉了多少，就要往下平移多少，不然showNum滚出可视区外了\n        this.clist = list.slice(\n          Math.floor(scrollTop / itemH),  // 计算卷入了多少条\n          Math.floor(scrollTop / itemH) + this.showNum\n        )\n        this.lastTime = new Date().getTime()\n      }\n    },\n\n    // 跳转\n    gotoCSSLongList(){\n      this.$router.replace('/CssLongList')\n    }\n  }\n}\n</script>\n```\n>样式：\n\n```javascript\n<style scoped>\n* {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  box-sizing: border-box;\n}\nli {\n  text-align: center;\n  line-height: 60px;\n  border-bottom: 1px solid red;\n}\n.but{\n  height: 40px;\n  width: 100px;\n  margin-top: 10%;\n}\n</style>\n```\n\n####  插件\nvue-virtual-scroller或者vue-virtual-scroll-list\n\n\n####  自己封装\n **1. 数据一次性给：**\n >\n >- 元素监听scroll事件(滚动事件)\n>- 计算可视化高度一次能装几个列表，然后从总数据中进行slice截取\n>- 每一次滚动后根据scrollTop值获取一个可以整除itemH结果进行偏移（scrollTop：滚动条移动的距离）\n\n\n **2. 数据通过请求：**\n\n`代码实现存在点问题修改后再上传`\n \n---\n##  事件销毁\n>Vue组件在销毁时，会自动解绑它的全部指令事件及监听器，但仅限于组件本身。\n>比如定时器等最好在销毁阶段手动销毁，避免内存泄漏\n\n```javascript\ncreated(){\n  this.timer = setInterval(this.refresh,)\n}\n\nbeforeDestroy(){\n  clearInterval(this.timer)\n}\n```\n---\n##  无状态的组件标记为函数式组件（静态组件）\n>只接收父组件传过来的值，自己不做处理，无状态，不创建实例。\n\n>函数组件没有this\n\n```html\n<template functional> // 函数组件\n <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\"></div>\n    <section v-else class=\"off\"></section>\n <div>\n</template >\n```\n\n```javascript\n<script>\n export default {\n  props: ['value']\n}\n</script>\n```\n\n---\n##  子组件分割\n>将子组件中耗时的任务交给组件自己管理，不影响整体页面的加载\n\n```html\n<template>\n <div>\n   <HelloWorld/>\n </div>\n</template>\n<script>\n```\n\n```javascript\nexport default {\n  // 子组件自己管自己\n  HelloWorld:{\n    methods:{\n      heavy(){/* 耗时任务 */}\n    },\n    render(h) {\n      return h('div', this.heavy());\n    }\n  }\n}\n```\n\n---\n\n##  变量本地化\n>减少使用 **this.数据**  的形式获取数据，减少一些不必要的处理\n>用一个变量先获取数据，在这个变量上处理数据。\n\n>在用this.数据 时会有数据劫持，去调用get/set做处理，浪费了时间。\n\n---\n\n##  模块化、组件化\n- 封装高度复用的模块\n- 拆分高度复用的组件\n- 组件可配置性\n\n```xml\n<template>\n// 可配置\n <button\n   :class=\"['mybtn',`btn-${btnStyle}`]\"\n   @click=\"myBtnClick($event)\"\n   v-show=\"btnShow\"\n >\n   <slot></slot>\n </button>\n</template>\n<script>\n\nexport default {\n  name: 'MyBtn',\n  props: {\n    btnStyle: String,\n    btnShow: Boolean\n  },\n  setup (props,ctx){\n    const myBtnClick = (e)=>{\n      ctx.emit('my-btn-click', e);\n    }\n    return{\n      myBtnClick\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.mybtn {\n  border: none;\n  outline: none;\n  height:34px;\n  padding: 0 15px;\n  background-color: #fff;\n  border: 1px solid #fff;\n}\n&.btn-default{\n  color: #333;\n  background-color: #fff;\n  border-color: #ccc;\n}\n&.btn-primary{\n  color: #fff;\n  background-color: #317DEF;\n  border-color: #317DEF;\n}\n</style>\n```\n\n# 二、懒加载\n## 路由懒加载\n```javascript\nconst router = new VueRouter({\n  routes:[\n    {path:'.foo', component: () =>import('./Foo.vue')}\n ]\n})\n```\n---\n## 图片懒加载\n###  运用插件\n>vue-lazyload\n```html\n<img v-lazy=\"图片地址\">\n```\n\n---\n###  自己封装\n`代码完善后上传`\n\n---\n# 三、keep-alive缓存页面\n##  原理\n>在created周期函数（init初始化后）调用时。将需要缓存VNode节点保存 在this.cache中，在渲染页面前调用render函数时。如果VNodedename符合缓存条件（用include和exclude控制），则会从this.cache中取出缓存的VNode实例进行渲染。\n\n##  参数\n- include：字符或者正则表达式。在名称匹配的组件会被渲染。\n- exclude：字符或者正则表达式。在名称匹配的组件不会被渲染。\n- max：数字。最多可以缓存多少个实例。\n\n##  被keep-alive包裹时具有的周期函数\n##  activated\n- keep-alive组件激活时调用\n- 服务器端渲染不被调用\n\n##  deactivated\n- keep-alive组件停用时调用\n- 服务器渲染期间不调用\n\n##  注意\n- keep-alive会将数据保留在内存中，如果要获取最新数据，则要在activated钩子函数中获取。 \n- include需要的name是组件的name\n- 在多级嵌套兄弟页面时，缓存其中一个页面时会将父级都缓存了，导致所有子页面都缓存了，这时需要手动销毁其它兄弟页面。\n\n```javascript\n<keep-alive>    \n<router-view v-if=\"$route.meta.keepAlive\"></router-view></keep-alive>\n// 销毁不需要的兄弟组件\n<router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n```\n\n##  使用场景\n>如需要在不同组件切换时某个组件需要不改变\n>如：搜索框在输入文字后，切换组件时，输入框文字不消失，返回也不消失。\n\n##  使用方法\n###  使用属性include和exclude\n\n```javascript\n// 只缓存名字为home的组件\n<keep-alive include=\"home\">\n   <router-view />\n</keep-alive>\n```\n\n```java\n// 缓存整个组件\n<keep-alive>\n   <router-view />\n</keep-alive>\n```\n\n###  路由中meta属性来控缓存\n\n```javascript\n// meta属性中keepAlive值设为true\n{\n      path: '/',\n      name: 'home',\n      meta:{\n        keepAlive:true\n      },\n      component: Home\n    }\n```\n\n```javascript\n// 配合 keep-alive进行控制缓存\n<keep-alive>\n      <router-view v-if=\"$route.meta.keepAlive\" />\n</keep-alive>\n```\n\n##  存在的问题\n>组件被缓存后，不存在销毁阶段，在组件切换时，不会调用created等生命周期函数，导致数据不能及时更新。\n\n**解决方法：**\n>使用提供的activated与deactivated函数来获取当前组件是否活跃。\n>在activated函数中获取数据，更新数据（被缓存的组件才会有这两个函数）\n\n\n# 四、打包优化\n## 1.引入库\n>按需引入，避免体积过大\n\n```javascript\nimport {Button , selet}from 'element-ui';\n```\n---\n## 2.引入资源\n>插件cdn、图片cdn、使用CSS图标\n>减少项目体积\n\n---\n## 3.打包配置\n>位置：build/config/index.js \n>属性：productionGzip:  true\n >作用：打包压缩\n\n>位置：truebuild/config/index.js  \n>属性：productionSourceMap: false \n >作用：减小打包体积 定位源码的会生成map文件 可能造成源码泄露\n\n---\n# 五、首屏优化\n## 数据加载使用loding骨架屏\n>在数据加载阶段擦用骨架屏可以给用户带来更好的体验\n\n---\n\n## 首屏采用**SSR**服务端渲染\n- 客户端发送请求给服务器\n- 服务器读取模板，解析成dom节点，返回一个完整的首屏html结构\n- 客户端进行首屏激活（把用户写的交互的代码，在前端激活，重新变成一个spa应用）\n- 这样后续，用户再点击超链接、跳转时，不会再向服务器发送请求了，而是使用前端路由跳转，只会发送一些ajax请求数据\n\n---\n## 使用web worker\n###  作用\n>让JS实现多线程\n\n>给JS创造多线程运行环境，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰，在worker线程运行结束后把结果返回给主线程。\n\n>这并不意味着JS语言本身支持了多线程能力，而是浏览器作为宿主环境提供了JS一个多线程运行的环境。\n\n###  使用\n>Worker()构造函数，第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\n\n```javascript\nvar myWorker = new Worker(jsUrl, options)\n```\n\n###  使用场景\n1. 加密数据\n有些加解密的算法比较复杂，或者在加解密很多数据的时候，这会非常耗费计算资源，导致UI线程无响应，因此这是使用Web Worker的好时机，使用Worker线程可以让用户更加无缝的操作UI。\n\n2. 预取数据\n有时候为了提升数据加载速度，可以提前使用Worker线程获取数据，因为Worker线程是可以是用 XMLHttpRequest 的。\n\n3. 预渲染\n在某些渲染场景下，比如渲染复杂的canvas的时候需要计算的效果比如反射、折射、光影、材料等，这些计算的逻辑可以使用Worker线程来执行，也可以使用多个Worker线程，这里有个射线追踪的示例。\n\n4. 复杂数据处理场景\n某些检索、排序、过滤、分析会非常耗费时间，这时可以使用Web Worker来进行，不占用主线程。\n\n5. 预加载图片\n有时候一个页面有很多图片，或者有几个很大的图片的时候，如果业务限制不考虑懒加载，也可以使用Web Worker来加载图片，可以参考一下这篇文章的探索，这里简单提要一下。\n\n---\n##  优化webpackp配置\n- webpackp的code-split结合vue-router做懒加载\n- webpackp的conthash模式针对文件级别更改做缓存\n# 总结\n以上记录了vue在各个方面的优化，对于webpackp的优化在学完webpackp后完善\n\n","tags":["Vue","优化"],"categories":["Vue","前端","优化"]},{"title":"Vue的生命周期，各个组件间的执行情况","url":"/2023/06/30/Vue生命周期及各组件间的执行情况/","content":"\n\n\n---\n\n# 前言\n\n\nVue的生命周期，各个组件间的执行情况。\n`注：本文是以Vue2.x版本展开叙述`\n\n\n---\n\n\n# 一、Vue的生命周期是什么？\nVue的组件都是独立存在的，每个组件都要经历他自己的`生命周期`。Vue的生命周期是指组件：\n**创建**--->**数据初始化**--->**挂载**--->**更新**--->**销毁**\n简单的来说就是组件从创建到销毁之间的过程\n\n\n# 二、Vue生命周期中具体过程\n## 1.Vue生命周期中的函数\n**生命周期钩子**也叫**生命周期函数**也叫**生命周期事件**，vue中他自己携带了八个生命周期函数，如下：\n### 创建Vue实例期阶段：\n\n - **beforeCreate：**\n 实例刚在内存中被创建出来，此时，还没有初始化完成data和methods属性。\n\n- **created：**\n实例已经在内存中创建完成，此时data和menthods以及创建完成，但没有开始编译模板。\n- **beforeMount：**\n此时完成了模板的编译，但没有进行挂载。\n- **mounted：**\n此时已经完成挂载到指定容器中显示了。\n### 运行阶段：\n- **beforeUpdate：**\n状态更新之前调用此函数，此时data中的状态值是最新的，但在界面上并没有得到更新，还没有开始重新渲染DOM节点。\n- **updated：**\n实例更新完成后调用此函数，此时以及重新渲染好DOM节点，界面显示数据也是最新的。\n### 销毁阶段：\n- **beforeDestroy：**\n实例 销毁前调用的函数，此时，实力还是完全可用的。\n- **destroyed：**\n实例销毁后调用，实例锁指示的所有东西都将解绑，所有监听器将移除，所有子实例也将销毁。\n>生命周期流程图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/27c2330b888345dba3fec82144bb8306.png#pic_center)\n\n\n>代码演示：\n\n```c\n var app = new Vue({\n        el: \"#app\",\n        data: {\n            message: \"Hello Vue!\"\n        },\n        methods: {\n            changeMessage() {\n                this.message='改变了！'\n            }\n        },\n        beforeCreate() {\n            console.log(\"---------- 初始化前 beforeCreate-----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n            \n        },\n        created() {\n            console.log(\"---------- 初始化完成 created----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeMount() {\n            console.log(\"---------- 挂载前 beforeMount----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        mounted() {\n            console.log(\"---------- 挂载完成 mounted----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeUpdate() {\n            console.log(\"---------- 更新前 beforeUpdate----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        updated() {\n            console.log(\"---------- 更新完成 updated----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        }\n    });\n```\n>创建阶段运行结果：\n>\n![](https://img-blog.csdnimg.cn/d3c052cebaad48329c13c55b72f25f23.png)\n**可以看到首次加载只会运行前四个周期函数，在挂载前才能拿到el属性，如果要操作DOM节点最早在挂在完成 mounted中操作。**\n>运行阶段运行结果：\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b1907c6374949568f14cccd17df1bbe.png)\n## 2.加入keep-alive后\n### 1）keep-alive的认识：\n\n是vue自带的内部组件，是用**来缓存组件**的，达到**提升性能**的目的。\n当使用keep-alive后会增加两个生命周期函数：\n- activated\n在 **keep-alive 组件激活**时调用， 该钩子函数在**服务器端渲染期间**不被调用。\n承担原来**created**钩子中获取数据的任务\n在第一次进入keep-alive包裹的组件时，会调用 beforeCreate、created、beforeMount、mounted、activated；这五个生命周期函数。\n当第二次或第n次进入时只会调用activated\n\n- deactivated\n在 keep-alive 组件停用时调用，该钩子在服务器端渲染期间不被调用。\n\n### 2）keep-alive的用法：\nProps有三个include、exclude、max。\n  - include\n  使用字符串或者正则表达式，匹配的组件才会被缓存\n  - exclude\n  使用字符串或者正则表达式，匹配的组件都不会被缓存\n  - max\n  以数字的形式记录可以缓存多少个组件实例，到达这个值后再次缓存时将销毁最久未使用的组件实例。\n\n### 3）keep-alive的一些使用心得：\n - 在组件实例中，通过beforeRouteEnter(to, from, next)路由守卫，来判断路由是从哪里跳转的，如果是从详情页跳转的，则将当前路由对象的meta.isBack 设置为true,否则设为false\n```javascript\n  beforeRouteEnter(to, from, next) {\n    if (from.path == \"/detail\") {\n      to.meta.isBack = true;\n    } else {\n      to.meta.isBack = false;\n    }\n    next();\n  }\n```\n- 为了在其他页面进入时，更新页面中的列表数据，我们将在activated钩子函数中挂载页面初次进入时的请求数据：\n```javascript\n   activated() {\n    if (!this.$route.meta.isBack) {\n        this.list = [];\n        this.pageNum = 1;\n        this.getList();\n    }\n    this.$route.meta.isBack = false;\n}\n```\n\n# 各组件间的执行情况\n## 1.加载渲染过程\n\n>过程：\n>**父组件beforeCreate** --> **父组件created** --> **父组件beforeMount** --> **子组件beforeCreate** --> **子组件created** --> **子组件beforeMount** --> **子组件mounted** --> **父组件mounted**\n## 2.子组件更新过程\n>过程：\n> **子组件beforeUpdate**  -->  **子组件updated**  \n## 3.父组件更新过程\n>**父组件beforeUpdate**  -->  **父组件updated**\n## 4.组件销毁过程\n>**父组件beforeDestroy** --> **子组件beforeDestroy** --> **子组件destroyed** --> **父组件destroyed**\n## 5.过程演示\n> 父组件代码\n\n```javascript\n<template>\n  <div style=\"border: 2px #1E1E1E; height: 500px;width: 500px;background-color: blueviolet; text-align: center\">\n    <span>{{message}}</span>\n    <button @click=\"changef\" >父组件改变</button>\n    <Son></Son>\n    <button @click=\"destroy\">点击销毁</button>\n  </div>\n</template>\n\n<script>\nimport Son from './components/Son.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    Son\n  },\n  data() {\n    return {\n      message: \"父组件\"\n    }\n  },\n  methods: {\n    changef(){\n      this.message='父组件改变了'\n    },\n    destroy(){\n      this.$destroy();\n      console.log('销毁完成');\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 父组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 父组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 父组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 父组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 父组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 父组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 父组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 父组件销毁后 destroyed----------')\n  }\n}\n</script>\n\n```\n> 子组件代码\n\n```javascript\n<template>\n  <div>\n    <div style=\"border: 2px #1E1E1E; height: 200px;width:200px;background-color: aqua;\">\n      <span>{{message}}</span>\n      <button @click=\"changes\">子组件改变</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  // eslint-disable-next-line vue/multi-word-component-names\n  name: 'Son',\n  props: {\n\n  },\n  data() {\n    return {\n      message: \"子组件\"\n    }\n  },\n  methods: {\n    changes(){\n      this.message='子组件改变了'\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 子组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 子组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 子组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 子组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 子组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 子组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 子组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 子组件销毁后 destroyed----------')\n  }\n}\n</script>\n```\n\n>加载渲染：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1e0fc120774141659a13fc399163e525.png)\n\n>更新阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/1dbd838712ba4a6cbbb50f8b26c45ef9.png)\n\n>销毁阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/11c316d9bff44e798c70517f11209b53.png)\n# 总结\n - 生命周期：\n   - 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n    -   是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n    -   生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n     -  生命周期函数中的this指向是vm 或 组件实例对象。\n ---\n- 常用的生命周期钩子：\n   -  mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n   - beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n   \n---\n- 关于销毁Vue实例：\n   - 销毁后借助Vue开发者工具看不到任何信息。\n   - 销毁后自定义事件会失效，但原生DOM事件依然有效。\n   - 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n","tags":["Vue","生命周期","组件"],"categories":["Vue","前端"]},{"title":"Vue模板语法","url":"/2023/06/30/Vue模板语法/","content":"\n\n---\n\n# 前言\n\n在Vue中，模板语法 的使用是频繁的。\n\n\n---\n\n\n# 一、插值\n## 1.插值语法\n插值语法用于文本的插入，数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：\n\n```javascript\n<span>Message: {{ msg }}</span>\n```\nMustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。也就是数据的动态绑定。\n值得注意的是插值语法中可以使用JavaScript的表达式。\n主要用于解析标签体内容。\n## 2.指令语法\n用于解析标签（标签属性、标签体内容、绑定事件...）\n### （1）数据绑定指令\n#### v-bind:(单向数据绑定)\n v-bind指令可以用于响应式地更新 HTML attribute。\ndata中的数据改变可以影响页面数据，但反过来不行。\n```javascript\n<a v-bind:href=\"url\">...</a>\n```\n其中href为参数，url是绑定的值，该指令也可以简写为“：”\n\n```javascript\n<a :href=\"url\">...</a>\n```\n#### v-model:双向数据绑定)\n该指令只能用于表单类元素（input、select等），也就是拥有value的标签，v-model实际上是通过标签value值来控制标签内容。\n\n```javascript\n<input type=‘button' v-model:value='name'/>\n```\n>也可以简写为：\n\n```javascript\n<input type=‘button' v-model='name'/>\n```\n\n改变输入框的值也会 影响data中的值，反过来也可以。\n### （2）事件监听指令\n#### v-on:(事件监听）\n用于事件的触发监听来执行对应的JS表达式。\n\n```javascript\n<input type=‘button' v-on:click='num++'/>\n```\n监听了点击事件使num每点击一下+1，也可以是一个函数\n\n```javascript\n<button v-on:click='say()'>Say hi</button>\n```\n该指令也可以简写为“@”\n\n```javascript\n<input type=‘button' @click='num++'/>\n```\n### （3）条件渲染指令\n#### v-if、v-else-if、v-else\n和判断相同根据表达式值在DOM中渲染或销毁元素或组件\nv-else是没有判断条件的，如果你加上去不会影响得到的结果\n```javascript\n  <p v-if=\"flag===‘晴’\">今天大晴天</p>\n  <p v-else-if=\"flag==='多云'\">今天多云</p>\n  <p v-else>今天下雨</p>\n```\n\n#### v-show\n和v-if类似，根据表达式的值控制标签或者组件的显示与隐藏。\n\n```javascript\n  <p v-show=\"flag\">今天要下雨</p>\n  <p v-show=\"!flag\">今天不要下雨</p>\n```\n### （4）内容渲染指令\n#### v-text\nv-text用法简单，只能用来渲染纯文本内容，如下：\n\n```javascript\n<p v-text=\"username\"></p>\n```\n他的缺点是他会直接覆盖掉原来标签里的内容。\n\n---\n\n#### v-html\n如果要渲染带包含html标签的内容，可以使用v-html\n\n```javascript\n<div v-html=\"content\"></div>\n\nconst vm = new Vue({\n            el: \"#app\",\n            data: {\n                content: \"<h1>你好</h1>\"\n            }\n        })\n```\n\n### （5）列表渲染指令\n#### v-for\n需要生成多个某个标签，就可以在该标签上加入v-for进行动态生成,v-for可以遍历**数组、对象、字符串以及指定次数**（将in或of后边换成数字即可）,v-for可以接收两个参数，其中第一个为每一项，第二个是当前索引值。\n具体语法如下：\n\n```javascript\n<ul>\n<li v-for=\"（item,inex） in 某个数据集合\" :key=\"index\">\n{{形参.数据集合的属性}}\n</li>\n</ul>\n```\nin也可以换成of，某些版本可能不行\n对于绑定的key（标识符）的使用存在着一些问题，后面可能会在其它文章中体现。\n## 指令间的小tips\n### 1.v-if和v-show\n\n\n  **（1）v-if和v-show的区别**：\n \n - v-if控制元素是否渲染到页面（是否创建）\n - v-show控制元素是否显示（已经创建，是否显示）\n \n **（2）v-if和v-show如何选择**：\n - 当频繁的切换显隐时使用v-show\n - 只有一次的切换时使用v-if\n \n###  2.v-if和v-for\nv-if的优先级是没有v-for的高的，也就是说将两个指令用在同一个标签上时，会先进行循环，再进行判断。\n这样做会导致性能受到影响。\n在源码中可以发现，他判断的顺序是：once-->for-->if(也就不难理解为什么for的优先级会比if高了)\n```javascript\nexport function genElement(el: ASTElement, state: CodegenState): string {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre\n  }\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      let data\n      const maybeComponent = state.maybeComponent(el)\n      if (!el.plain || (el.pre && maybeComponent)) {\n        data = genData(el, state)\n      }\n\n      let tag: string | undefined\n      // check if this is a component in <script setup>\n      const bindings = state.options.bindings\n      if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {\n        tag = checkBindingType(bindings, el.tag)\n      }\n      if (!tag) tag = `'${el.tag}'`\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c(${tag}${\n        data ? `,${data}` : '' // data\n      }${\n        children ? `,${children}` : '' // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n```\n\n如果想一起使用，可以在标签外层嵌套一层，将v-if绑定在外层。\n###  3.v-on事件修饰符\n事件修饰符可以多个一起用（如：事件.prevent.stop）。\n- @事件.prevent:阻止默认事件\n- @事件.stop:阻止事件冒泡（在包含关系中不同标签上有相同的触发函数，导致这两个被关联起来）\n- @事件.once:事件只触发一次\n- @事件.capture：使用事件捕获模式\n- @事件.self：只有event.target是当前操作的元素才触发事件\n- @事件.passive：事件的默认行为立即执行，无需等待事件回调执行\n\n###  3.v-on键盘事件\n@keyup:按键放开触发\n@keydown：按键按下触发\n\n几个按键也可以同时使用（如：@keyup.ctrl.y）。\n\n根据按键触发:\n**@keyup.按键别名**\n\n常用按键别名：\n\n - 回车：enter\n - 删除：delete\n - 退出：esc\n - 空格：space\n - 换行：tab（只能配合@keydown中使用）\n - 上：up\n - 下：down\n - 左：left\n - 右：right\n\n---\n获取按键名称或者编码：\n\n```javascript\nshow(e){//事件调用函数\ne.key;//按键名称\ne.keyCode;//按键编码\n}\n```\n\n---\n系统修饰键（特殊）：**ctrl、alt、shift、meta**\n配合keyup使用时必须同时按下其它键，释放后才会触发，keydown中正常。\n\n---\nVue自定义别名按键\n**Vue.config.keyCodes.自定义键名=键码；**\n# 总结\n\n\n以上就是今天要讲的内容，本文简单介绍了Vue的模板语法，以及常用的指令语法\n\n","tags":["Vue","指令语法"],"categories":["Vue","前端","指令"]},{"title":"React入门","url":"/2023/06/30/React入门/","content":"\n\n\n\n# 前言\n\nReact是一个用于构建用户界面的JavaScript库,用来为现代的网络构建用户界面。\n\nReact框架可以用[Antd Table](https://ant.design/components/cascader-cn/)\n\n本次学习使用的**React**版本为**18.1.0**\n```c\n\"dependencies\": {\n    \"react\": \"^18.1.0\",\n    \"react-dom\": \"^18.1.0\"\n  }\n```\n---\n\n\n# 一、React的特点\n\n- 虚拟DOM\n- 声明式\n- 基于组件\n- 支持服务器渲染\n- 快速、简单、易学\n\n# 二、HelloReact\n## 1.引入库\n开发web项目，引入两个JS脚本\n\n- **react.js**\nreact.js是react核心库，只要使用react就必须引入\n- **react-dom.js** \n用来管理Dom操作的库。开发web应用必备\n\n## 2.创建React元素\n>**React.createElement()**;\n>-用来创建React元素\n>-参数：\n>     1.元素名\n>     2.元素中的属性\n>     3.元素的子元素（内容）\n代码如下：\n\n```c\nconst div=React.createElement('div',{},'我是div');\n```\n## 3.获取根元素对应的React元素\n>**ReactDOM.createRoot();**\n>需要一个DOM元素作为参数\n\n代码如下：\n\n```c\nconst root=ReactDOM.createRoot(document.getElementById('root');\n```\n\n## 4.渲染React元素到根元素\n\n代码如下：\n\n```c\nroot.render(div);;\n```\n\n---\n\n# 三、3个API\n## 1.React.createElement()\n- React.createElement(type,[props],[...children])\n    参数：\n    1.元素名称（html标签必须小写）\n    2.标签属性\n       设置事件时，属性名需要修改为驼峰命名法,\n    3.标签内容\n- 用来创建React元素\n- React元素无法修改\n## 2.ReactDOM.createRoot()\n- ReactDOM.createRoot(container[,options])\n- 用来创建React的跟容器，容器用来放置React元素\n## 3.root.render()\n- root.render(element)\n- 当首次调用时，容器节点里的所有DOM元素都会被替换，后续的调用则会使用React的DOM差分算法(DOM diffing algorithm)进行高效更新。\n- 不会修改容器节点（只会修改容器的子节点）。可以 在不覆盖现有子节点的情况下，将组件插入已有的DOM节点内。\n# 总结\n\n\n\n\n","tags":["前端","API","react"],"categories":["React","前端"]},{"title":"替换空格","url":"/2023/06/30/offer替换空格/","content":"# 问题描述：\n\n\n请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\n\n限制：0 <= s 的长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>解题思路：在JAVA中字符串是不可更改的，所以通过字符串每个字符的对比来在StringBuilder中加入字符遇到空格就加入'%20'\n\n\n   >  在c中利用字符数组可更改的性质，统计字符串中空格数，新字符长度就为=原字符长度（不包含空格）+空格数*2；用双指针分别指向原字符串最后和新字符串最后，往前寻找并复制不为空格的字符，遇到空格新字符串\n            指针依次往前三格加入‘0’，‘2’，‘%’，直到空格数为零，原指针停止，指针相遇就结束。\n## 1.JAVA：\n```java\npublic static String replaceSpace(String s) {\n        if(s==null)return null;\n        StringBuilder sb=new StringBuilder();\n        for (int i=0;i<s.length();i++){\n            if (s.charAt(i) == ' ') {\n                sb.append(\"%20\");\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n```\n\n\n---\n\n## 2.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/951d0fe3b4254020b0b4f57508baea9b.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/submissions/)\n","tags":["算法","简单","offer","力扣","字符串","栈"],"categories":["力扣","字符串"]},{"title":"offer整数除法","url":"/2023/06/30/offer整数除法/","content":"\n# 问题描述：\n\n\n给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。\n注意：\n\n - 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1\n\n---\n\n# 例子\n\n示例 1：\n输入: a = \"11\", b = \"10\"\n输出: \"101\"\n解释：15/2 = truncate(7.5) = 7\n\n示例 2：\n输入：a = 7, b = -3\n输出：-2\n解释：7/-3 = truncate(-2.33333..) = -2\n\n示例 3：\n输入：a = 0, b = 1\n输出：0\n\n示例 4：\n输入：a = 1, b = 1\n输出：1\n\n---\n# 提示：\n\n- -231 <= a, b <= 231 - 1\n- b != 0\n\n---\n\n\n# 代码实现：\n## 1.O（n）：\n>用a不断的减去b，然后累加次数，就是结论，但是要考虑越界问题，所以把两个数全弄成负数，再考虑边界问题单独解决\n```java\nclass Solution {\n    public int divide(int a, int b) {\n     // 32 位最大值：2^31 - 1 = 2147483647\n    // 32 位最小值：-2^31 = -2147483648\n    // -2147483648 / (-1) = 2147483648 > 2147483647 越界了\n    if (a == Integer.MIN_VALUE && b == -1)\n        return Integer.MAX_VALUE;\n    int sign = (a > 0) ^ (b > 0) ? -1 : 1;\n    /\n    if (a > 0) a = -a;\n    if (b > 0) b = -b;\n    int res = 0;\n    while (a <= b) {\n        a -= b;\n        res++;\n    }\n    // 因为不能使用乘号，所以将乘号换成三目运算符\n    return sign == 1 ? res : -res;\n\n作者：tangweiqun\n链接：https://leetcode.cn/problems/xoh6Oh/solution/jian-dan-yi-dong-javac-pythonjs-zheng-sh-e8r6/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n    }\n}\n```\n## 2.常数级别（31次循环）：\n>和上面一样，思路就是每次用减法来计算，但是是从最大的数开始找，也就是从2^31（最大）开始找，如果不够将2的指数依次减小，\n```java\nclass Solution {\n    public int divide(int a, int b) {\n       if (a == Integer.MIN_VALUE && b == -1) {\n            return Integer.MAX_VALUE;\n        }\n        int symbol=(a>0)^(b>0)?-1:1;// 符号判断\n        a=Math.abs(a);\n        b=Math.abs(b);\n        int res=0;\n        for(int i=31;i>=0;i--){\n            //右移避免越界\n            // >>>无符号右移， -2147483648看成正的2147483648\n            if ((a>>>i)-b>=0){// 和a>=(b<<i)一样但是有可能越界\n                a-=(b<<i);\n                res+=(1<<i);// 累加结果\n            }\n        }\n        return symbol==1?res:-res;\n    }\n}\n\n```\n\n\n\n```\n\n题目来源：力扣（LeetCode）\n[LeetCode题目](https://leetcode.cn/problems/xoh6Oh/?plan=lcof&plan_progress=gdsixbt)\n","tags":["算法","简单","offer","力扣"],"categories":["力扣","整数"]},{"title":"反转链表","url":"/2023/06/30/offer反转链表/","content":"# 问题描述：\n\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n限制：\n0 <= 节点个数 <= 5000\n\n\n---\n\n# 例子\n\n示例 1：\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n---\n# 提示：\n无\n\n\n---\n\n\n# 代码实现：\n>利用辅助数组将数记录并计数，然后再将数组中的值从末尾赋值给返回链表，在赋值时要记录下头结点\n>迭代利用指向下一个结点的指针反向指向上一个结点，在左这一步操作时应记录好先前当前结点的下一个结点。\n## 1.辅助数组：\n>时间复杂度为O(n)，空间复杂度为O(5001)\n```java\npublic static ListNode reverseList(ListNode head) {\n        if (head==null) return null;\n        int[] aid =new int[5001];//辅助数组\n        int i=0;\n        while (head!=null){// 将链表值赋给数组并计数\n            aid[++i]= head.val;\n            head=head.next;\n        }\n        ListNode res= new ListNode(aid[i]);// 返回的链表\n        ListNode temp=res;// 记录头结点\n        i-=1;// 去掉头结点\n        while (i>0){// 将数组中的值赋给链表\n            if (res.next==null){\n                res.next=new ListNode(aid[i]);\n            }\n            res=res.next;\n            i--;\n        }\n        res=temp;\n        //res.plant(res);\n        return res;\n    }\n```\n## 2.迭代：\n时间复杂度为O（n），空间复杂度为O（1）\n\n```java\n public static ListNode reverseList2(ListNode head) {\n        if (head==null||head.next==null) return head;\n       ListNode res=null;// 返回链表\n        while (head!=null){\n            ListNode temp=head.next;// 辅助结点\n            head.next=res;// 翻转\n            res=head;\n            head=temp;\n        }\n       // res.plant(res);\n        return res;\n    }\n\n```\n\n## 运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf33725d88574d9392e283e180885752.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)\n","tags":["算法","数组","简单","offer","力扣","链表"],"categories":["力扣","链表"]},{"title":"JS运行机制 Vue全局API nextTick源码分析","url":"/2023/06/30/JS运行机制 Vue全局API nextTick源码分析/","content":"\n---\n\n# 前言\n\n\nVue中nextTick的实现原理和对源码的分析。\n\n---\n\n\n\n# 一、nextTick是什么？\n\n官方文档中，提到nextTick是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n在Vue开发时，有没有遇到这样的情况，在改了data里的数据后获取DOM时里边的值竟然还是原来的值，甚至在循环中，这次获取的DOM永远是上一次的状态，但页面明明都变了呀，但是在使用nextTick后这种情况的到解决，简直摸不到头脑。\n不过，在查看nextTick源码，还有网上的相关资料后，豁然开朗。\n有意思的是官方文档还标注了：\n\n> 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\n\nIE躺着也中枪，源码中确实也体现了官方的这句话。\n\n# 二、为什么会出现这种情况\n## 1.JS的运行机制？\n神XX机制，我真的会谢，能用就行呗，哈哈哈哈，开玩笑，开玩笑。\n说起JS运行机制，还真没了解过，趁这个机会，好好了解一下。\n\n### （1）JS运行机制流程\nJS的执行竟然是单线程的，我不知道，这是为什么，可能是机制吧，他是靠事件循环来执行。具体流程如下：\n\n---\n 1. 在主线程运行时，会形成执行栈，栈中在执行过程中遇到任务源，将任务源中的回调函数加入到任务队列中\n 2. 执行栈执行完成后，会将任务队列中的回调函数放入执行栈依次执行。\n ---\n 经过反复循环这两个操作，就变成了事件循环。\n### （2）同步、异步执行过程\n同（1）中所讲一致，不过**同步任务**是直接放到执行栈中执行，异步任务只能看着，突然发现还有一个**任务队列**，异步任务赶紧把自己的**任务**给他，让任务队列在同步执行**完成后**喊他。\n\n#### 任务：\n在任务里边也有分类，分为**宏任务**和**微任务**\n##### 宏任务：\n- 在宏任务执行过程中，可以创建宏任务加到宏任务队列的最后等待下一次循环执行；也可以创建微任务，加入到本次宏任务下微任务队列的最后，会在本次宏任务结束后顺序执行。（每个宏任务都有个微任务队列）\n- 在本次宏任务执行完成后，这时候才去执行宏任务下的微任务队列，微任务结束后，算一个task执行完成。\n- **在一个task执行完成，页面会进行渲染，然后进入下一个task。**（Event loop）\n- 常见的宏任务：`setTimeout, setInterval, requestAnimationFrame, I/O, script标签内代码，setImmediate`等。\n\n##### 微任务：\n- 微任务创建的宏任务，会被加入到宏任务队列的最后。\n- 微任务创建的微任务会被加入到微任务队列的最后，微任务会在本次task中执行完成。\n- 常见的微任务有：\t`Promise callback， Promise.then，MutationObserver`\n##### 解释场景问题\n到这，大家应该知道为啥获取DOM的状态是上一次的吧，是因为渲染DOM都是异步进行的，在更改数据时，Vue开启了事件队列，数据更改的任务被推进了任务队列，在此时依赖了DOM时获取的肯定是上一次DOM状态，因为那时候DOM还没到重新渲染，只不过这个时间太短，你感觉不出来。\n\n# 三、nextTick源码分析\n## 1.浏览器能力？\nnextTick执行延迟回调，如何实现这个功能，这可离不开浏览器的能力，浏览器的能力决定了nextTick以什么样的方式去实现这个功能，说白了就是最大限度提升性能。\n### 如何判断浏览器能力？\n`微任务的耗时是小于宏任务的`\n- 当然是if（）喽，首先去判断支不支持Promise，在其中把回调函数队列给Promise.then，然后就创建了微任务，值得注意的是在IOS中支持Promise，但他队列不更新，所以要加个空的任务强制刷新下队列。\n\n- 如果不支持Promise也没关系，他会去找有没有原生的MutationObserver的API（ES5中检测DOM节点变化的API），显然它创建的也是个微任务\n- 实在不行就来到了setImmediate，IE可以直接跳过前两个直接来到这，因为自身条件不达标，从这个开始创建的是宏任务了。\n- 最不推荐的就是setTimeout了，他是最慢的。\n\n```javascript\n// 判断浏览器的能力：\n// 顺序：Promise-->MutationObserver-->setImmediate-->setTimeout\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop) // ios具备promise但不会更新队列信息，所以强制加入一个空计时器，强制刷新。\n  }\n  isUsingMicroTask = true\n} else if ( //接下来就是判断有没有原生的MutationObserver，用来检测DOM树变化的API。\n  !isIE &&\n  typeof MutationObserver !== 'undefined' &&\n  (isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]')\n) {\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  // 靠MutationObserver中characterData属性去观察目标节点（textNode）下所有文本类型节点（即子代或后代）的文字变化\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n  // 然后是setImmediate 前两个都是创建微任务，但从这个开始就是创建宏任务了\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  // 最后推荐的是setTimeout，宏任务间也是有差距的\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n```\n## 2.回调队列函数\n回调队列函数中很简单，上锁和循环执行回调队列，\n\n```javascript\n// 执行回调队列函数\nfunction flushCallbacks() {\n  pending = false //重置异步锁\n  // 将回调函数队列复制并清空回调函数队列。防止nextTick中套娃出现错误，防止在回调函数中调用nextTick时将其回调函数加入到这个队列中，也就是不会开启多个异步任务。\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n```\n## 3.nextTick主体\n- 将传进来的回调函数推入对调队列中，再判断异步锁是否上锁，如果未上锁就在上锁后执行异步函数创建异步任务等待同步任务执行完成。\n- 如果没有回调，则在支持Promise的情况下返回一个Promise（IE无语）\n\n```javascript\nexport function nextTick(cb?: (...args: any[]) => any, ctx?: object) {\n  let _resolve\n  // 将回调函数推入回调队列\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e: any) {\n      // 发生错误时，回滚并调用全局API handleError获取错误信息\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  // 如果异步锁未上锁，则锁上异步锁，调用异步函数等待同步函数完成\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n  // $flow-disable-line\n  // 如果没有回调并且支持Promise则返回一个Promise\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n```\n\n# 总结\n\n以上就是今天记录的内容，本文对JS的运行机制和nextTick原理进行了分析，其次除了nextTick外，可以用$forceUpdate ，强制更新，他只会影响到实例本身和插入插槽内容的子组件。\n\n","tags":["JS","Vue","源码","API"],"categories":["JS","Vue","前端"]},{"title":"一些JS的插件库","url":"/2023/06/30/js插件库/","content":"\n1、[airbnb/lottie-web](https://github.com/airbnb/lottie-web)\n\n一个可以从Adobe After Effects中创建的动画直接导出到你的网站。\n\n适用于Lottie for Web，[Android](https://github.com/airbnb/lottie-android)，[iOS](https://github.com/airbnb/lottie-ios)，[React Native](https://github.com/airbnb/lottie-react-native)和[Windows。](https://aka.ms/lottie)\n\n例子：\n\n![Example4.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example4.gif?raw=true)\n\n![Example2.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example2.gif?raw=true)\n\n\n\n![Community 2_3.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Community%202_3.gif?raw=true)\n\n2、[wagerfield/parallax](https://github.com/wagerfield/parallax)\n\n一个轻量级视差渲染JS库，可以创建视察效果，用鼠标来控制，还可以调整物体移动速度。\n\n示例网站：[parallax.js (wagerfield.com)](http://matthew.wagerfield.com/parallax/)\n\n\n\n3、[e-oj/Magic-Grid](https://github.com/e-oj/Magic-Grid)\n\n一个简单、轻量级的 Javascript 库，用于动态网格布局\n\n效果：\n\n![Magic-Gridv](http://imgconvert.csdnimg.cn/aHR0cHM6Ly92dWVqc2V4YW1wbGVzLmNvbS9jb250ZW50L2ltYWdlcy8yMDE5LzAxL01hZ2ljLUdyaWR2LmdpZg)\n\n\n\n4、[webslides/WebSlides](https://github.com/webslides/WebSlides)\n\n以漂亮的方式制作HTML演示文稿\n\n演示网站：https://webslides.tv/demos.\n\n\n\n5、[svgdotjs/svg.js](https://github.com/svgdotjs/svg.js)\n\n用于操作 SVG 和制作动画的轻量级库，无需任何依赖项。\n\n\n\n6、[dixonandmoe/rellax](https://github.com/dixonandmoe/rellax)\n\n是一个超轻量级，JavaScript视差库。Rellax 现在可以在移动设备上工作 \n\n效果网站：[Demo Website](https://dixonandmoe.com/rellax/)\n\n\n\n7、[Dynamics.js (dynamicsjs.com)](http://dynamicsjs.com/)\n\n用于创建基于物理的动画\n\n\n\n\n\n8、[mojs/mojs](https://github.com/mojs/mojs)\n\n用于 Web 的运动图形工具\n\n演示网址：[mo.js](https://mojs.github.io/)\n\n\n\n9、[metafizzy/zdog](https://github.com/metafizzy/zdog)\n\n圆形，平面，设计师友好的伪3D引擎，用于canvas和SVG\n\n官网：[Zdog · Round, flat, designer-friendly pseudo-3D engine for canvas and SVG (zzz.dog)](https://zzz.dog/)\n\n\n\n10、[leader-line-vue](https://www.npmjs.com/package/leader-line-vue)\n\n用来画引导线:\n\n![前020](https://raw.githubusercontent.com/anseki/leader-line/HEAD/img/ex-020.gif)\n","tags":["前端","JS","插件"],"categories":["JS","前端"]},{"title":"JS一些原理和方法","url":"/2023/06/30/JS一些原理和方法/","content":"\n# 前言\n\nJS一些原理和方法\n\n---\n\n\n# 一、JS深度拷贝\n\n## 1.深度拷贝和浅度拷贝的区别\n对象和数组是通过指针去指向内存地址区来确定其位置。\n\n对于浅拷贝只是复制了其指针，指向了同一块内存区域，在操作新数组或者对象时必然会影响到原数组或对象，也就是说改变新数组时，原数组也会进行改变。\n\n而深度拷贝是完全复制了原数组或对象，也在内存区申请了新空间，改变新数组或对象不会影响到原数组。\n\n## 2.如何进行深度拷贝\n首先是浅度拷贝，浅度拷贝我理解的就是简单的进行赋值\n\n>代码如下（示例）：\n\n```c\nlet arr1=[1,2,3,4,5];\nlet arr2=arr1;\n```\n\n对于深度拷贝可以用ES5或者ES6的语法规则来，当然ES6比较简单快捷，对于单层和多层嵌套的数组或对象ES5和ES6也有不一样的语法。\n>ES5代码如下（示例）：\n\n```c\n//ES5单层嵌套\nlet arr1=[1,2,3,4,5];\nlet arr2= ary1.concat();\n\n//ES5多层嵌套\nlet arr1=[1,2,3,4,5];\n JSON.parse(JSON.stringify(ary1));\n```\n>ES6代码如下（示例）：\n\n```c\n//ES6单层嵌套\nlet arr1=[1,2,3,4,5];\nlet arr2= [...ary1];\n//或者\nlet [...arr2]=arr1;\n\n//ES6多层嵌套\nlet arr1=[1,2,3,4,5];\nvar arr2 = arr1.constructor === Array ? [] : {};  \n        for (var i in arr1) {\n             arr2[i] = deepCopy(arr1[i]);\n        }\n```\n# 二、sort() 排序方法的使用\n`提示：sort()方法会改变原数组或对象`\nsort在没有传入参数时是根据各个字符的Unicode位来进行排序的\n>代码如下（示例）：\n\n```c\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\nmonths.sort();\n// 输出: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\n// 输出: Array [1, 100000, 21, 30, 4]\n\n```\n\nsort可以传入一个排序函数或者两个参数，显而易见排序函数中有两个参数也就是可以直接传的两个参数\n>代码如下（示例）：\n>`提示：为字符串时不排序`\n\n```c\narr=[1,30,4,21,100000];\narr.sort((p1,p2)=>{\n//升序\nreture p1-p2;\n// 输出: Array [1, 4, 21, 30, 100000]\n\n//降序\nreture p2-p1;\n//输出: Array [100000, 30, 21, 4, 1]\n})\n\n```\n\n# 三、判断数据类型\n>ES5数据类型共有6个：数值、字符串、布尔、对象、null、undefind\n\n>ES6又新加了symbol、bigInt\n>symbol（基本数据类型）是指独一无二的值，通过Symbol()生成的值都是唯一的，用来最为对象属性的标识符。\n\n>bigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示，数据必须加后缀n。\n\n`null被称为空对象指针：初始化对象时最好将其初始化为null。`\n\n`undefined:变量没有初始化、函数参数没提供、对象中属性没赋值、函数没有返回值，这些都为undefind`\n\n## 1、 判断基本数据类型\n- typeof x 。\n- x.constructor\n- Object.prototype.toString.call(x)\n\n\n# 四、比较运算\n><=、=、>=、==、!=  、! = =、 ===\n>`在比较运算符中==和===存在比较差异，==只比较值是否一样，而===则是值和类型同时比较；同理!=和!==一样`。\n\n# 五、跳出循环\n>break: 跳出整个大循环\n>continue：只跳出本次循环，开始下一次循环\n\n# 六、字符串方法\n>在字符串中如果要显示单引号或者双引号，需要转义在引号前加‘ \\ ’用来转义。\n\n## charAt（）\n>用来返回字符串中某个位置的字符，允许为负或者比字符串索引大，但返回一个空字符。\n\n## concat ( )\n>用来连接两个字符串，返回一个新字符串，不改变原字符串，可接受多个参数，如果参数不为字符串，则该方法会先将其转换为字符串。\n>用+来也可以代替该方法，字符串拼接。\n\n## substring（）\n>用来从原字符串取出子字符串并返回，不改变原字符串，它的第一个参数表示开始位置，第二个参数表示结束位置（结果不包含）。\n>只传一个参数则会返回该位置到结束的字符串\n>第一个参数比第二个参数，则会自动交换位置\n>如果为负，则会从0开始\n\n##  substr（）\n>与substring（）作用一样，但是参数不同\n>第一个参数为起始位置，第二个参数为长度\n>省略第二个参数则会从开始位置直到结束\n>如果第一个参数为负则会从倒数计算字符位置，第二个参数是负数，将会被自动转为0，返回空字符串\n\n\n##  indexOf（）\n>用来确定一个字符串在另一个字符串中出现的位置，返回结果为匹配开始的位置。\n>也可以传入第二个参数，表示从该位置开始匹配\n\n>在ES6中新增：\n>（1）includes()：返回布尔值，判断是否找到参数字符串。\n（2）startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。\n（3）endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。\n>都支持第二个参数，表示从这个位置开始。\n\n##  trim（）\n>用来去除字符串两端的空格，返回一个新字符串，不改变原字符串\n>去除的包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）\n\n>ES6扩展方法trimEnd()和trimStart()方法，分别是去掉尾部和头部\n\n\n##  split（）\n>利用规则来将字符串分割开，返回一个结果数组\n>如果参数为空字符串，则会分割每一个字符\n>不传参数则返回整个字符串，不做分割\n>第二个参数则是返回结果的个数\n\n##  ES6其它新增字符串方法\n###  repeat（）\n>用来将字符串重复指定次数返回，不改变原字符串\n>参数为正整数，则返回指定次数\n>参数为非负小数，则向下取整\n>如果参数是0~-1之间的数，则取整，为0\n>如果参数是NaN，则为0次\n>如果参数为负数或者Infinity，则报错\n>如果为字符串，则会先转换为数字\n\n###  字符串补全\n>padStart（）:返回新字符串，表示用参数字符串从头补全原字符串。\n>padEnd（）:返回新字符串，表示用参数字符串从后边补全原字符串\n\n>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。\n\n#  七、数组方法\n## 数组静态方法Array.isArray()\n  >用来弥补typeof判断数组返回object的缺陷，该方法会返回布尔值表示参数是否为数组。\n\n##  push()和pop()方法\n>push用来在数组末端添加一个或多个元素，会改变原数组\n>pop用来删除数组最后一个元素并返回，会改变原数组\n\n##  shift（)和unshift()方法\n>shift用来删除数组第一个元素，并返回该元素，会改变原数组\n>unshift用来在数组头部添加元素，并返回添加元素的长度\n\n##  join（）方法\n>用来以参数作为分割符，将所有数组成员连接为一个字符串并返回，如果不提供，默认为逗号。如果数组的成员为Null或undefind或空位，会被转层空字符串。\n\n\n##  concat（）方法\n>用来多个数组合并，将新数组的成员，添加到原数组的后部，返回一个新数组，原数组不变。\n>参数除了数组外，还有可以传入其它类型的参数，并将其添加到原数组后边。\n\n\n##  reverse（）方法\n>用来颠倒数组元素，返回改变的数组，原数组会改变\n\n##  indexOf（）方法\n>用来返回给定元素在数组中第一次出现的位置，不存在返回-1\n>第二个参数表示开始查找的位置\n\n\n#  变量提升（hoisting）\n>在JS引擎工作时，先解析代码，获取所有被声明的变量，然后顺序执行，所有的变量声明语句，都会被提升到代码的头部。\n\n#  函数提升\n>JS引擎会将函数名视同变量一样，采用function声明函数时，整个函数会像变量一样提升到头部。\n\n\n#  Math对象\n##  Math.abs()\n>用来返回参数值的绝对值\n\n##   Math.max()和Math.min()\n>返回参数中最大值或最小值\n>参数为空时，返回-Infinity或Infinity\n\n##  Math.floor（）和Math.ceil（）\n>返回参数向下取整或者向上取整的值\n\n## Math.random()\n>返回一个0~1的随机数\n\n>某个范围的随机整数：\n\n```javascript\nfunction f(min,max) {\n    let result=Math.random()*(max-min)+min;\n    result=Math.floor(result);\n    return result;\n  }\n```\n#  Date对象\n>JS原生的时间库\n\n##  Date.now()\n>返回当前事件距离四件零点（1970年1月1日00：00：00 UTC）的毫秒数，相当于Unix时间戳乘以1000\n\n###  时间戳\n>是指格林威治时间（1970年1月1日00：00：00 ）北京时间（1970年1月1日08：00：00 ）起到现在总秒数。\n\n###  Date提供的get方法\n\n \n\n```javascript\ncost d=new Date('January 6,2022'); \n```\n\n - getTime()：返回实例距离1970年1月1日的毫秒数\n - getDate()：返回实例对象对应每个月的几号\n - getDay()：返回星期几，从0开始\n - getYear()：返回距离1900的年数\n - getFullYear()：返回四位的年份\n - getMonth：返回月份，从0开始\n - getHours：返回小时\n - getMillisecinds：返回毫秒\n - getMinutes：返回分钟\n - getSeconds()：返回秒\n\n","tags":["前端","JS","方法"],"categories":["JS","前端"]},{"title":"JavaScript 设计模式核⼼原理与应⽤实践(一)原则与核心思想","url":"/2023/06/30/JavaScript 设计模式核核心原理与应⽤实践（一）原则于核心思想/","content":"\n---\n\n# 前言\n\n软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。\n\n---\n\n\n# 一、设计模式的原则\n>面向对象编程和面向对象设计的五个基本原则:\n\n - 单一功能原则（Single Responsibility Principle）\n- 开放封闭原则（Opened Closed Principle）\n- 里式替换原则（Liskov Substitution Principle）\n- 接口隔离原则（Interface Segregation Principle）\n- 依赖反转原则（Dependency Inversion Principle）\n\n>因为JS本身的特点，主要围绕前两个原则展开\n\n---\n# 二、设计模式的核心思想——封装变化\n>设计模式的出现，最主要的原因是因为软件在不停的更新迭代中，不断地产生**变化**\n\n>在开发过程中我们不能保证代码不会发生变化，我们能做的就是将影响降到最低，做到：`**将变化的部分与不变的部分抽离，保证变化的部分灵活，不变的部分稳定**`。这称为“封装”\n\n>我们不仅要考虑功能的实现，还要考虑其可维护性和可拓展性，不能经得起变化的考研的软件终不能长久。\n\n---\n\n# 三、二十三种设计模式\n\n>二十三种设计模式可分为三大类分别是：\n\n - 创建型\n    - 单例模式\n    - 原型模式\n    - 构造器模式\n    - 工厂模式\n    - 抽象工厂模式\n  - 结构型\n      - 桥接模式\n      - 外观模式\n      - 组合模式\n      - 装饰器模式\n      - 适配器模式\n      - 代理模式\n      - 享元模式\n   - 行为型\n        - 迭代器模式\n        - 解释器模式\n        - 观察和模式\n        - 中介者模式\n        - 访问者模式\n        - 状态模式\n        - 备忘录模式\n        - 策略模式\n        - 模板方法模式\n        - 职责链模式\n        - 命令模式\n\n>每一种类型的设计模式都离不开  `封装变化` 只是用了自己的方式去封装不同类型的变化\n\n - 创建型：封装了创建对象过程中的变化\n - 结构型：封装了对象之间组合方式的变化，灵活的表达了对象间的配合与依赖关系\n - 行为型：封装的是对象的行为进行，让我们更安全、方便的对行为进行更改\n\n\n>看似设计模式与我们很远，其实它就在我们身边，可能我们用到，但不知道这个思想就是，某种设计模式的思想。\n---\n\n\n# 总结\n以上记录了设计模式的核心思想，以及原则，简单的介绍了三大类设计模式的作用。\n\n","tags":["前端","设计模式"],"categories":["设计模式","前端"]},{"title":"JavaScript 设计模式核⼼原理与应⽤实践(二)创建型","url":"/2023/06/30/JavaScript 设计模式核心原理与应用实践（二）创建型/","content":"\n---\n\n# 前言\n创建型设计模式用于描述“怎么创建对象”。它的主要特点是“将对象的创建与使用分离”。\n\n前端创建型设计模式用到的有：`构造器模式`、`工厂模式`、`抽象工厂模式`\n\n---\n\n\n# 一、构造器模式\n>构造函数想必就是一种构造器如：\n\n\n```javascript\nfunction f(name,age,career) {\n    this.name=name;\n    this.age=age;\n    this.career=career;\n}\nconst user=new f('张三',23,'coder');\n```\n\n>只用传给构造函数对应的值，就可以创建出一个实例对象出来\n\n>总的来说：像这样一个新建对象分配内存后，用来初始化对象的特殊函数，叫做构造器。在JS中，我们通过构造函数去初始化对象，就是应用了构造器模式。\n\n>在整个过程中，改变的是属性的值，而这些属性则是固定不变的。\n>构造器将属性赋值给对象的过程给封装了，使每个对象都具有这些属性，这一部分不可更改使其稳定，而属性赋值的过程开放，可以灵活的给属性赋值。\n\n>构造器模式本质是去抽象每个**对象实例**的变与不变\n\n---\n\n# 二、简单工厂模式\n>工厂模式本质上是抽象不同**构造函数**（类）之间的变与不变，他将创建对象的过程单独封装。\n\n>当不同类中属性相同，但其中的属性会受到其它属性的值而产生对应的值，就比如一个教室中，有学生和老师两种类型，学生类中包含年龄、姓名、职位、工作组成；而老师类也是年龄、姓名、职位、工作组成；但工作会因为职位的值，自动匹配工作的值，学生：学习，老师：授课。\n\n```javascript\nfunction student(name,age){\n    this.name=name;\n    this.age=age;\n    this.position='学生';\n    this.work='学习';\n}\n\nfunction teacher(name,age) {\n    this.name=name;\n    this.age=age;\n    this.position='老师';\n    this.work='授课';\n}\nconst student1=new student('张三',23);\nconst student2=new student('李四',23);\nconst student3=new student('王五',23);\nconst teacher=new student('李',23);\n```\n\n>这样一个教室的角色就可以被构造出来实例，但会发现有个问题就是,得到一条数据后，还得手动判断职业，才能选择对用的构造函数构建。这部分的变可以给一个大函数来管理。\n\n```javascript\nfunction roleManagement(name,age,career) {\n    switch (career) {\n        case '学生':\n            return new student(name,age);\n            \n        case '老师':\n            return new teacher(name,age);\n        ...    \n        \n    }\n}\n```\n>这样判断职业的事交给了`roleManagement`函数管理，但是又有个问题就是假如有一个听课老师，那是不是又得写一个构造函数来构造这个听课老师，`roleManagement`中又得添加一个判断，又来一个校长又得写一个，显然是乏力的。\n\n>可以想到在这两个类中共同的部分依旧是那四个属性，改变的是每个属性的取值与work属性需要根据position属性值来判断，我们何不将 不变的构造函数和，判断改变的逻辑封装在同一个方法中，让他自己判断，从而构建出不同的实例对象。\n\n```javascript\nfunction gather(name,age,position) {\n    function User(name,age,position,work) {\n        this.name = name\n        this.age = age\n        this.position = position\n        this.work = work\n    }\n\n    function roleManagement(name,age,position) {\n        switch (position) {\n            case '学生':\n                work='学习'\n                break\n\n            case '老师':\n                work='授课'\n                break\n            ...\n\n        }\n    }\n    return new User(name,age,position,work);\n}\n\nconst student5=new gather('张三',23,'学生');\nconst teacher2=new gather('李老师',32,'老师');\n```\n>现在就只用传入姓名、年龄、职业就可以创建出对应的实例拉。\n\n>总的说，工厂模式就是把对象的创建过程封装，只给用户提供传参和结果\n\n\n---\n\n# 三、抽象工厂模式\n>对于构造器模式解决的是多个对象实例的问题，而简单工厂模式解决的是多个类的问题。抽象工厂解决的则是多个工厂的共存。\n\n>在JS的语法中，不支持抽象类的直接实现，只能考模拟还原抽象类。\n\n>有以下场景，在之前老师和学生的基础上，又有一个角色类型，但是他的属性完全和老师和学生不同，他多了其它的属性权限，这时候按照刚刚的逻辑又得在`roleManagement`中添加关于这个新角色的相关权限逻辑。这使得整个`roleManagement`在项目的迭代更新中变的越来越庞大，不易于维护。这样显然是没有遵循**开放封闭原则**的。\n\n```javascript\nfunction gather(name,age,position) {\n    function User(name,age,position,work) {\n        this.name = name\n        this.age = age\n        this.position = position\n        this.work = work\n    }\n\n    function roleManagement(name,age,position) {\n        switch (position) {\n            case '学生':\n                work='学习'\n                break\n\n            case '老师':\n                work='授课'\n                break\n             \n            case '新角色':\n                work='发工资'\n                newPrivileges='管理老师'\n                break\n            ...\n\n        }\n    }\n    \n    return new User(name,age,position,work);\n}\n```\n\n>对于开放粉笔原则：我们要对拓展开放，对修改封闭。也就是说实体（类、模块、函数）可以拓展，不可以修改。\n\n>抽象工厂模式会创建一个定义规则抽象工厂类，这个类只会提供具体工厂的接口，可以通过这个接口来扩展具体工厂的逻辑内容。就比如生产汽车，你不知道具体需要生产什么样的汽车，但你知道生产汽车需要发动机、车架、轮胎、玻璃....，这时候就可以创建出一个抽象类表示这辆车需要什么，但具体需要什么样的部件得靠具体工厂提供。\n\n```javascript\nclass automobileProduction {\n    // 提供发动机的接口\n    createTheEngine(){\n        throw new Error(\"抽象工厂方法不允许被直接调用，需要重写该方法！\")\n    }\n\n    //提供车架的接口\n    createTheFrame(){\n        throw new Error(\"抽象工厂方法不允许被直接调用，需要重写该方法！\")\n    }\n}\n```\n>值得注意的是抽象工厂是不能被实例化的，包括里边的方法是不能被调用的，如果能被调用那不就是修改嘛，我们需要的是扩展而不是修改。\n\n>那如何去生产一台车呢，这时候需要用具体工厂来生产需要的型号，也就是定制一个特定具体工厂：\n\n```javascript\n//具体工厂继承抽象工厂\nclass gallop extends automobileProduction{\n    creatingEngine() {\n        //提供奔驰的发动机\n        return new MercedesBenzEngine(); \n    }\n    createTheFrame(){\n        //提供奔驰车架\n        return new MercedesBenzChassis();\n    }\n}\n```\n\n>在具体工厂中调用的构造函数`MercedesBenzEngine`、`MercedesBenzChassis`，分别用于生产具体的发动机和车架实例，这样的类称为具体产品类，具体产品类往往不会孤立存在，而不同的具体产品类往往又相同的功能，比如：奔驰发动机类和大众发动机类都有给汽车带来动力。所以这里可以用一个抽象产品类来声明这些类具有的基本功能，就像最开始汽车生产抽象类一样声明了汽车生产的基本功能。\n\n```javascript\n//具体工厂继承抽象工厂\nclass gallop extends automobileProduction{\n    creatingEngine() {\n        //提供奔驰的发动机\n        return new MercedesBenzEngine();\n    }\n\n    createFrame(){\n        //提供奔驰车架\n        return new MercedesBenzChassis();\n    }\n}\n\n//定义发动机类的抽象产品类\nclass engine {\n    createTheEngine(){\n        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');\n    }\n}\n\n//定义车架类的抽象产品类\nclass frame {\n    createFrame(){\n        throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');\n    }\n}\n\n//定义具体发动机的具体产品类\nclass MercedesBenzEngine extends engine{\n    createTheEngine(){\n        console.log(\"奔驰发动机\")\n    }\n}\n\n//定义具体车架的具体产品类\nclass MercedesBenzChassis extends frame{\n    createFrame(){\n        console.log(\"奔驰车架\")\n    }\n}\n\n//我的车\nconst car=new gallop();\n// 选则发动机\nconst myEngine=new MercedesBenzEngine();\n//选择车架\nconst myFrame=new MercedesBenzChassis();\n//组装发动机\nmyEngine.createTheEngine();\n//组装车架\nmyFrame.createFrame();\n```\n>最终组装出来一辆奔驰车\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1c159ac4aa7c4da7a5e7a83069f9e585.png)\n>假设后来我又想生产大众车了，这时候我们不用对抽象工厂做任何改变，只需要拓展他的具体工厂和具体产品的种类就行了。这就完美的实现了拓展。\n---\n\n# 总结\n对于简单工厂和抽象工厂模式来看：\n共同点是：尝试去分离一个系统中变与不变的部分\n不同点：场景的复杂度\n>在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对共性作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分。\n","tags":["前端","设计模式"],"categories":["设计模式","前端"]},{"title":"H5声明和H5基本骨架，各种标签以及H5的新标签","url":"/2023/06/30/HTML5简介和H5新标签/","content":"# 前言\nH5声明和H5基本骨架，各种标签以及H5的新标签\n\n---\n\n# 一、HTML5的DOCTYPE声明\n\n>DOCTYPE是document type(文档类型)的缩写，<!DOCTYPE html>是H5的声明，位于文档最前面，他是网页必备组成部分，避免浏览器的怪异模式。\n\n# 二、HTML5的基本骨架\n## 1.html标签\n\n - 包裹其它标签\n - 限定文档的开始和结束\n> `<html lang=\"en\">`表示当前网页语言为英文\n  \n## 2.head标签\n\n - 定义文档的头部，包括文档的各种属性和信息，包括标题\n - 不展示给用户\n - 和其他文档的关系\n - 在Web中的位置\n\n>`<meta charset=\"UTF-8\">`表示当前编码为UTF-8\n## 3.body标签\n\n - 定义文档的主体\n - 包括了文档所有内容（文本、超链接、图像、表格、列表）\n - 直接在页面中显示，用户直观看到的内容\n\n## 4.title标签\n\n - 定义文档标题\n - 显示在浏览器窗口的标题栏或状态栏上\n - 该标签是head标签中唯一必须的标签\n - 有利于SEO优化（浏览器搜索引擎搜索的排名）\n\n---\n\n# 二、标题标签\n>标题（Heading）是通过<h1>~<h6>标签来定义的。\n><h1>定义最大 标题，<h6定义最小标题>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n</body>\n</html>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cbd4185ac2664813b43d2ea3d4e9104d.png)\n>标签位置摆放：\n>在标签中添加属性align=\"left | center | right\"默认居左\n\n```html\n<h1 align=\"center\">一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e0929400b67343b3a6d2ea18c191862f.png)\n\n\n`正确使用标题标签有利于SEO优化`\n\n\n# 三、段落、换行、水平线标签\n## 1、 段落\n>段落用`<p>`标签定义\n\n```html\n<body>\n<p>这是一个段落</p>\n<p>这是另一个段落</p>\n</body>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e0150229b284f5bba4ea22f6a928605.png)\n\n## 2、 换行\n>换行用`<br>`标签定义,为单标签\n\n```html\n<body>\n<p>这是一个段落</p>\n<p>这是<br/>另一个段落</p>\n</body>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7a261b61db7043b38e35e02990225644.png)\n\n## 3、 水平线\n>水平线用`<hr>`标签定义,为单标签\n\n属性：\n\n - color:设置水平线颜色\n - width：设置水平线长度\n - size:设置水平线的高度\n - align:设置水平线对齐方式（默认居中），可取值 left | right\n \n `<hr color=\"red\" width=\"300px\" size=\"5px\" align=\"left\"/>`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/376c5daec6414c94a429fe268a826fbd.png)\n\n# 四、图片标签\n>图片用`<img>`标签定义,为单标签\n\n```html\n<img src=\"\" alt=\"\">\n```\n属性：\n\n - src:图片路径\n - alt:规定图像的替代文本\n - width：规定图像的宽度\n - height：规定图像的高度\n - title：鼠标悬停在图片上的提示文字\n\n路径：\n\n - 绝对路径：电脑中储存的具体位置\n - 相对路径：\n              -  子级关系：/\n              -  父级关系：../\n              -  同级关系：./  \n              \n    \n\n# 五、超文本标签\n>超文本用`<a>`标签定义\n\n```html\n<a href=\"\"></a>\n```\n属性：\n\n - href:跳转链接地址\n \n---\n1. 一个未访问过的链接显示未蓝色字体并带有下划线\n2. 访问过的链接显示未紫色并带有下划线\n3. 点击链接时，链接显示为红色并带有下划线\n\n# 六、文本标签\n>常用文本标签：\n - `<em>`: 定义着重文字\n - `<b>`:定义粗体文本\n - `<i>`:定义斜体字\n - `<strong>`:定义加重语气\n - `<del>`:定义删除字\n - `<span>`:元素没有特定含义\n\n```html\n<em>em</em>\n<br>\n<i>i</i>\n<br>\n<b>b</b>\n<br>\n<strong>strong</strong>\n<br>\n<del>del</del>\n<br>\n<span>span</span>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c72d9e968358449f832b37f03811383b.png)\n# 七、有序列表标签\n>有序列表始于`<ol>`标签，每个列表始于`<li>`标签。\n\n```html\n<ol>\n    <li>123</li>\n    <li>123456</li>\n</ol>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/05aab8e7a6cf46b6baa9a4003b36dfd3.png)\nol属性type的选项：\n - 1\n - a\n - A\n - i\n - I\n \n![在这里插入图片描述](https://img-blog.csdnimg.cn/4f310307420543fa9dd9102a5d70b8d1.png)\n>可嵌套列表：\n\n```html\n<ol type=\"A\">\n    <li>123\n    <ol>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ol>\n    </li>\n    <li>123456</li>\n</ol>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e5637b78c2c41ccb487f3fa73b61f0f.png)\n# 八、无序列表标签\n>无序列表始于`<ul>`标签，每个列表始于`<li>`标签。\n\n```html\n<ul>\n    <li>123</li>\n    <li>123456</li>\n</ul>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1c0b1d670c414977a95ece9c4acee54b.png)\nol属性type的选项：\n\n - disc:默认实心圆\n - circle:空心圆\n - squarer:小方块\n - none:不显示\n \n \n>可嵌套列表：\n\n```html\n<ul>\n    <li>123\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ul>\n    </li>\n    <li>123456</li>\n</ul>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/17db97e3d1f644c7b19a98cfd16c7ef2.png)\n\n# 九、表格标签\n>表格：`<table>`标签\n>行：`<tr>`标签\n>单元格（列）：`<td>`标签\n\n```html\n<tr>\n        <td>1</td>\n        <td>2</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2b2fdcf2f87a4acca2702c43f76bccbe.png)\n>快捷键\n>`table>tr*2>td{内容}`\n\ntable表格属性：\n\n - border: 设置表格的边框\n - width: 设置表格的宽度\n - height: 设置表格的高度\n \n \n\n```html\n<table border=\"1px\" width=\"300px\" height=\"100px\">\n    <tr>\n        <td>1</td>\n        <td>2</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n</table>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/02c1c6efd9d3499f95d8c3978630f317.png)\n\n>单元格合并属性\n>水平合并：colspan 保留左边，删除右边，值为合并单元格个数\n>垂直合并：rowspan 保留上边，删除下边，值为合并单元格个数\n\n```html\n<table border=\"1px\" width=\"300px\" height=\"100px\">\n    <tr>\n        <td colspan=\"2\">1</td>\n        <td rowspan=\"2\">3</td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td>5</td>\n    </tr>\n</table>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/83ac69c89fef4a57a08de68efe985fee.png)\n\n# 十、Form表单\n>用来给用户填写信息，从而能采集用户信息，使网页具有交互的功能。\n>表单是由容器和控件组成，一个表单一般应该包括用户填写信息的输入框，提交按钮等，这些称为控件，表单就是容器，能容纳各种控件。\n\n>`<form action=\"url\" method=\"get | post\" name=\"myForm\">`\n>属性：\n>action:服务器地址\n>name:表单名称\n>meethod：请求方式（get | post）\n\n>表单元素：\n>完整的表单包含三个基本组成部分：表单标签、表单域、表单按钮\n\n```html\n<form action=\"url\" method=\"get | post\" name=\"myForm\">\n    <input type=\"text\">\n    <button type=\"submit\">提交</button>\n</form>\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/10e8dfb02ed4447ebb82ed47cd187397.png)\n\n>文本域：用户输入字母数字等内容\n>`<input type=\"text\">`\n\n>密码框：输入的密码\n>`<input type=\"password\">`\n\n>提交按钮：用来提交表单\n>`<input type=\"submit\" value=\"登录\">`\n\n# 十一、元素分类（块、行内元素）\n块级元素     | 行内元素\n-------- | -----\n块元素会在页面中独占一行（自上而下垂直排列）  | 行内元素不会独占一行，只占自身的大小\n可以设置width,height属性  | 行内元素设置width,height属性无效\n一般块级元素可以包含行内元素和其它块级元素  | 一般行内元素不包含块级元素\n\n## 块元素\n>常见：div、form、h1~h6、hr、p、table、ul、等\n## 行内元素\n>常见：a、b、em、i、span、strong、等\n\n## 行内块级元素\n>不换行、能够识别宽高\n>常见：button、img、input、等\n\n# 十二、HTML5新增标签\n有利于搜索引擎SEO优化\n>传统的页面采用DIV+CSS实现，某个模块最外层用`<div>`标签包裹\n\n```html\n<div>\n    <form action=\"url\" method=\"get | post\" name=\"myForm\">\n        <input type=\"submit\" value=\"登录\">\n        <button type=\"submit\">提交</button>\n    </form>\n</div>\n```\n\n>H5新增标签：\n\n - `<header></header>`头部标签\n - `<nav></nav>`导航栏标签\n - `<section></section>`文档中的节，如章节、页眉、页脚\n - `<article></article>`一个独立的、完整的相关内容块\n - `<aside></aside>`侧边栏标签\n - `<footer></footer>`底部标签\n\n# 总结\n\n本文仅仅简单介绍了HTML和H5，其中包括了H5声明和各种标签\n\n","tags":["HTML","标签"],"categories":["HTML","前端"]},{"title":"0~n-1缺失的数字","url":"/2023/06/30/0～n-1中缺失的数字/","content":"# 问题描述：\n\n\n一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n限制：1 <= 数组长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入: [0,1,3]\n输出: 2\n\n示例 2：\n输入: [0,1,2,3,4,5,6,7,9]\n输出: 8\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>二分：有且只有一个数字不在该数组，且每个数都是唯一的，利用二分查找到第一个数组下标与值不对应的，\n>下标就是缺失的数,在这之前如果数组长度为1要额外判断在左指针到最后时，要判断数组最后一个是否> 与下标对应，如果对应缺失的数就是left+1\n\n>顺序查找：从头开始查找，找到下标与值不对应的就是缺失的数，找到最后则缺失的数为数组长度。\n## 1.二分：\n>时间复杂度：O（logn），空间复杂度：O（1）\n```java\nclass Solution {\n        public static int missingNumber(int[] nums) {\n            if(nums.length==0)return -1;// 数组长度为0返回-1\n            if (nums.length==1)return nums[0]==0?1:0;// 数组长度为1 额外判断\n            int left=0;\n            int right=nums.length-1;\n            while (left<right){\n                int half=left+((right-left)>>2);// 取一半\n                if (nums[half]==half){// 下标对应其值\n                    left=half+1; // 左指针指向中点右边一位\n                    if (left==right && nums[left]==left)return left+1;// 到数组最后一位\n                }else right=half;// 没有对应\n            }\n            return right;// 返回第一个数组与下标不对应的值\n        }\n    }\n```\n## 2.顺序查找：\n>时间复杂度：O（n），空间复杂度：O（1）\n```java\npublic static int missingNumber2(int[] nums) {\n            for (int i=0;i<nums.length;i++){\n                if (i==nums[i]) continue;\n                return i;\n            }\n            return nums.length;\n        }\n\n```\n\n## 3.运行结果\n>二分：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ca52642128834fd6ba071edd53dbb5b2.png)\n\n>顺序查找；\n![在这里插入图片描述](https://img-blog.csdnimg.cn/617424ff8f1e4af48aa609873b9f91ba.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/submissions/)\n","tags":["算法","数组","二分","简单","offer","力扣"],"categories":["力扣","数组","二分"]}]