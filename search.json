[{"title":"数组中重复的数字","url":"/2022/09/15/数组中重复的数字/","content":"\n# 问题描述：\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n限制：2 <= n <= 100000\n\n---\n\n# 例子\n\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n---\n# 提示：\n\n- 数组中的数都不超过数组长度-1\n\n\n---\n\n\n# 代码实现：\n>    用打标签的方式记录是不是重复的，先创建一个标签数组，从0开始到n-1，再遍历数组。出现过一次就在对应标签标记，发现标签元素中某次出现标记过的返回这个数\n\n   >利用哈希表记录值，每次加入前查找是否存在，不能再则加入，存在则返回\n\n>原地交换，某个数如果对应它自己的位置，则跳过，否则将查看该索引下的值是否与当前值相等，相等就返回，不等则交换\n## 1.标签：\n```java\n public static int findRepeatNumber(int[] nums) {\n        if (nums.length==2)return -1;// 如果数组长度位2直接返回-1\n        int[]label=new int[nums.length];// 标签数组\n        for (int num : nums) {\n            if (label[num] == 0) label[num] = 1;// 标签为0 使其变为1\n            else return num;// 不为1说明重复出现\n        }\n        return -1;// 不存在重复的数\n    }\n```\n## 2.原地交换：\n```java\npublic static int findRepeatNumber2(int[] nums) {\n        if (nums.length==2)return -1;// 如果数组长度位2直接返回-1\n        int i=0;\n        while (i<nums.length){\n            if (nums[i]==i){\n                i++;// 只在与索引值相等才往后，避免某些元素遍历不到\n                continue;\n            }\n            if (nums[nums[i]]==nums[i]) return nums[i];\n            else {// 交换位置\n                int temp=nums[i];\n                nums[i]=nums[temp];\n                nums[temp]=temp;\n            }\n        }\n        return -1;// 不存在重复的数\n    }\n\n```\n\n## 3.运行结果\n>两次错误是因为用异或运算交换位置，然后最后一个测试点过不去\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ac93e8b90c4380a412ec555d1b99f3.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)\n","tags":["数组","简单","offer","力扣"],"categories":["力扣","数组"]},{"title":"左旋字符串","url":"/2022/09/15/左旋转字符串/","content":"# 问题描述：\n\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。\n\n限制：1 <= k < s.length <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入: s = \"abcdefg\", k = 2\n输出: \"cdefgab\"\n\n示例 2：\n输入: s = \"lrloseumgh\", k = 6\n输出: \"umghlrlose\"\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>    使用片段拼接的方式，按照需要反转的的地方一分为二，再将两个片段重新拼接就可以了\n\n>    使用遍历拼接字符串的方式，从第n位开始遍历将字符拼接起来，再从头遍历拼接\n## 1.字符串片段拼接：\n>时间复杂度O（n）,空间复杂度O（n）\n>substrin（）方法是将字符串复制一遍，所以时间复杂度位O（n）\n```java\n public static String reverseLeftWords(String s, int n) {\n        //substring:获取字符串某一段\n        return s.substring(n)+s.substring(0,n);\n    }\n```\n## 2.字符串循环遍历拼接：\n>时间复杂度O（n）,空间复杂度O（n）\n\n```java\n public static String reverseLeftWords2(String s, int n) {\n        StringBuilder sb=new StringBuilder();//拼接字符串容器\n        for (int i=n;i<s.length()+n;i++){\n            sb.append(s.charAt(i%s.length())); // 利用取余来减少一个for循环\n        }\n        return sb.toString();\n    }\n\n```\n\n## 3.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ecd863b94667487fa2118de526dcf8bd.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n","tags":["算法","简单","offer","力扣","字符串"],"categories":["力扣","字符串"]},{"title":"替换空格","url":"/2022/09/14/offer替换空格/","content":"# 问题描述：\n\n\n请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\n\n限制：0 <= s 的长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>解题思路：在JAVA中字符串是不可更改的，所以通过字符串每个字符的对比来在StringBuilder中加入字符遇到空格就加入'%20'\n\n\n   >  在c中利用字符数组可更改的性质，统计字符串中空格数，新字符长度就为=原字符长度（不包含空格）+空格数*2；用双指针分别指向原字符串最后和新字符串最后，往前寻找并复制不为空格的字符，遇到空格新字符串\n            指针依次往前三格加入‘0’，‘2’，‘%’，直到空格数为零，原指针停止，指针相遇就结束。\n## 1.JAVA：\n```java\npublic static String replaceSpace(String s) {\n        if(s==null)return null;\n        StringBuilder sb=new StringBuilder();\n        for (int i=0;i<s.length();i++){\n            if (s.charAt(i) == ' ') {\n                sb.append(\"%20\");\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n```\n\n\n---\n\n## 2.运行结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/951d0fe3b4254020b0b4f57508baea9b.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/submissions/)\n","tags":["算法","简单","offer","力扣","字符串","栈"],"categories":["力扣","字符串"]},{"title":"复杂链表的复制","url":"/2022/09/13/复杂链表的复制/","content":"# 问题描述：\n\n\n请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n\n\n\n---\n\n# 例子\n\n\n**示例 1：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4f44c4a8168c442fa1d59f911a4446c7.png)\n\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n\n\n**示例 2：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/466e20e591804d579e0d3fe6e3292c08.png)\n\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n\n\n\n**示例 3：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a580fd515b854ae3af2b5d047ae5d483.png)\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n\n\n**示例 4：**\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n\n---\n# 提示：\n\n提示：\n\n- -10000 <= Node.val <= 10000\n- Node.random 为空（null）或指向链表中的节点。\n- 节点数目不超过 1000 。\n\n---\n\n\n# 代码实现：\n>对于简单链表的深拷贝，按照顺序遍历一遍就可以，该题目中存在随机指针，在拷贝时，你不能确定他所指向的结点是否已经创建了。\n\n >所以可以尝试用拆分停留的方式，就是在原链表每个结点后面添加一个和原节点一样的结点，用复制结点的随机指针指向原结点的随机指针的后一个，最后再把两个链表拆开就得到了结果\n## 1.拆分停留：\n>时间复杂度O(N)，空间复杂度O(1)\n```java\npublic Node copyRandomList(Node head) {\n        if (head==null) return null;\n       for (Node node=head;node!=null;node=node.next.next){// 插入每个结点的复制版\n           Node nodeCopy=new Node(node.val);// 创建结点\n           nodeCopy.next=node.next;// 插入\n           node.next=nodeCopy;\n       }\n       for (Node node=head;node!=null;node=node.next.next){// 将复制的随机结点指向原节点指向的下一个结点\n           node.next.random=node.random!=null?node.random.next:null;\n       }\n       Node rt=head.next;// 记录头结点\n       for (Node node=head;node!=null;node=node.next){// 将复制链表和原链表分开\n           Node nodeNew = node.next;\n           node.next=node.next.next;\n           nodeNew.next=node.next!=null?nodeNew.next.next:null;\n       }\n       return rt;\n    }\n```\n---\n\n## 运行截图\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/275d67b0949649c39af91a4bdfe031cc.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n","tags":["算法","数组","链表","offer","力扣","中等"],"categories":["力扣","链表"]},{"title":"反转链表","url":"/2022/09/13/offer反转链表/","content":"# 问题描述：\n\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n限制：\n0 <= 节点个数 <= 5000\n\n\n---\n\n# 例子\n\n示例 1：\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n---\n# 提示：\n无\n\n\n---\n\n\n# 代码实现：\n>利用辅助数组将数记录并计数，然后再将数组中的值从末尾赋值给返回链表，在赋值时要记录下头结点\n>迭代利用指向下一个结点的指针反向指向上一个结点，在左这一步操作时应记录好先前当前结点的下一个结点。\n## 1.辅助数组：\n>时间复杂度为O(n)，空间复杂度为O(5001)\n```java\npublic static ListNode reverseList(ListNode head) {\n        if (head==null) return null;\n        int[] aid =new int[5001];//辅助数组\n        int i=0;\n        while (head!=null){// 将链表值赋给数组并计数\n            aid[++i]= head.val;\n            head=head.next;\n        }\n        ListNode res= new ListNode(aid[i]);// 返回的链表\n        ListNode temp=res;// 记录头结点\n        i-=1;// 去掉头结点\n        while (i>0){// 将数组中的值赋给链表\n            if (res.next==null){\n                res.next=new ListNode(aid[i]);\n            }\n            res=res.next;\n            i--;\n        }\n        res=temp;\n        //res.plant(res);\n        return res;\n    }\n```\n## 2.迭代：\n时间复杂度为O（n），空间复杂度为O（1）\n\n```java\n public static ListNode reverseList2(ListNode head) {\n        if (head==null||head.next==null) return head;\n       ListNode res=null;// 返回链表\n        while (head!=null){\n            ListNode temp=head.next;// 辅助结点\n            head.next=res;// 翻转\n            res=head;\n            head=temp;\n        }\n       // res.plant(res);\n        return res;\n    }\n\n```\n\n## 运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf33725d88574d9392e283e180885752.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)\n","tags":["算法","数组","链表","简单","offer","力扣"],"categories":["力扣","链表"]},{"title":"从尾到头打印链表","url":"/2022/09/13/从尾到头打印链表/","content":"\n\n# 问题描述：\n\n\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n限制：\n0 <= 链表长度 <= 10000\n\n---\n\n# 例子\n\n示例 1：\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n>解题思路：\n>考虑到数组的方式更快，并且限制长度也不是很长，所以一开始想到辅助数组的方式，利用一个辅助数组先将数加入到数组，通过计数得到长度，再从辅助数组末尾依次把数加到返回           数组中，缺点是辅助数组的长度必须为10001；\n            或者利用辅助栈先进后出的特点，先将数压入栈中，最后出栈放入返回数组。\n## 1.辅助数组：\n```java\n  public static int[] reversePrint(ListNode head) {\n          if (head==null) return new int[0];\n          int [] aid = new int[10001];\n          int i=0;\n          while (head != null){\n              aid[++i]= head.val;\n              head=head.next;\n          }\n          int []res=new int[i];\n          for (int j=0;i>0;j++){\n              res[j]=aid[i--];\n          }\n          return res;\n        }\n```\n## 2.辅助栈：\n```java\npublic static int[] reversePrint2(ListNode head) {\n        if (head==null) return new int[0];\n        Stack<Integer>stack=new Stack<Integer>();\n        while (head != null){\n            stack.push(head.val);\n            head=head.next;\n        }\n        int []res=new int[stack.size()];\n        int i=0;\n        while (!stack.isEmpty()){\n            res[i++]=stack.pop();\n        }\n        return res;\n    }\n\n```\n\n## 运行结果：\n>发现数组方式确实要比栈快一点\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a166ae362024fb39e39da0caca8f415.png)\n\n\n\n---\n\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)\n","tags":["算法","数组","简单","offer","力扣","栈"],"categories":["力扣","链表"]},{"title":"React入门","url":"/2022/09/12/React入门/","content":"\n\n\n\n# 前言\n\nReact是一个用于构建用户界面的JavaScript库,用来为现代的网络构建用户界面。\n\n本次学习使用的**React**版本为**18.1.0**\n```c\n\"dependencies\": {\n    \"react\": \"^18.1.0\",\n    \"react-dom\": \"^18.1.0\"\n  }\n```\n---\n\n\n# 一、React的特点\n\n- 虚拟DOM\n- 声明式\n- 基于组件\n- 支持服务器渲染\n- 快速、简单、易学\n\n# 二、HelloReact\n## 1.引入库\n开发web项目，引入两个JS脚本\n\n- **react.js**\nreact.js是react核心库，只要使用react就必须引入\n- **react-dom.js** \n用来管理Dom操作的库。开发web应用必备\n\n## 2.创建React元素\n>**React.createElement()**;\n>-用来创建React元素\n>-参数：\n>     1.元素名\n>     2.元素中的属性\n>     3.元素的子元素（内容）\n代码如下：\n\n```c\nconst div=React.createElement('div',{},'我是div');\n```\n## 3.获取根元素对应的React元素\n>**ReactDOM.createRoot();**\n>需要一个DOM元素作为参数\n\n代码如下：\n\n```c\nconst root=ReactDOM.createRoot(document.getElementById('root');\n```\n\n## 4.渲染React元素到根元素\n\n代码如下：\n\n```c\nroot.render(div);;\n```\n\n---\n\n# 三、3个API\n## 1.React.createElement()\n- React.createElement(type,[props],[...children])\n    参数：\n    1.元素名称（html标签必须小写）\n    2.标签属性\n       设置事件时，属性名需要修改为驼峰命名法,\n    3.标签内容\n- 用来创建React元素\n- React元素无法修改\n## 2.ReactDOM.createRoot()\n- ReactDOM.createRoot(container[,options])\n- 用来创建React的跟容器，容器用来放置React元素\n## 3.root.render()\n- root.render(element)\n- 当首次调用时，容器节点里的所有DOM元素都会被替换，后续的调用则会使用React的DOM差分算法(DOM diffing algorithm)进行高效更新。\n- 不会修改容器节点（只会修改容器的子节点）。可以 在不覆盖现有子节点的情况下，将组件插入已有的DOM节点内。\n# 总结\n\n\n\n\n","tags":["前端","react","API"],"categories":["React","前端"]},{"title":"JS一些原理和方法","url":"/2022/09/12/JS一些原理和方法/","content":"\n# 前言\n\nJS一些原理和方法\n\n---\n\n\n# 一、JS深度拷贝\n\n## 1.深度拷贝和浅度拷贝的区别\n对象和数组是通过指针去指向内存地址区来确定其位置。\n\n对于浅拷贝只是复制了其指针，指向了同一块内存区域，在操作新数组或者对象时必然会影响到原数组或对象，也就是说改变新数组时，原数组也会进行改变。\n\n而深度拷贝是完全复制了原数组或对象，也在内存区申请了新空间，改变新数组或对象不会影响到原数组。\n\n## 2.如何进行深度拷贝\n首先是浅度拷贝，浅度拷贝我理解的就是简单的进行赋值\n\n>代码如下（示例）：\n\n```c\nlet arr1=[1,2,3,4,5];\nlet arr2=arr1;\n```\n\n对于深度拷贝可以用ES5或者ES6的语法规则来，当然ES6比较简单快捷，对于单层和多层嵌套的数组或对象ES5和ES6也有不一样的语法。\n>ES5代码如下（示例）：\n\n```c\n//ES5单层嵌套\nlet arr1=[1,2,3,4,5];\nlet arr2= ary1.concat();\n\n//ES5多层嵌套\nlet arr1=[1,2,3,4,5];\n JSON.parse(JSON.stringify(ary1));\n```\n>ES6代码如下（示例）：\n\n```c\n//ES6单层嵌套\nlet arr1=[1,2,3,4,5];\nlet arr2= [...ary1];\n//或者\nlet [...arr2]=arr1;\n\n//ES6多层嵌套\nlet arr1=[1,2,3,4,5];\nvar arr2 = arr1.constructor === Array ? [] : {};  \n        for (var i in arr1) {\n             arr2[i] = deepCopy(arr1[i]);\n        }\n```\n# 二、sort() 排序方法的使用\n`提示：sort()方法会改变原数组或对象`\nsort在没有传入参数时是根据各个字符的Unicode位来进行排序的\n>代码如下（示例）：\n\n```c\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\nmonths.sort();\n// 输出: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\n// 输出: Array [1, 100000, 21, 30, 4]\n\n```\n\nsort可以传入一个排序函数或者两个参数，显而易见排序函数中有两个参数也就是可以直接传的两个参数\n>代码如下（示例）：\n>`提示：为字符串时不排序`\n\n```c\narr=[1,30,4,21,100000];\narr.sort((p1,p2)=>{\n//升序\nreture p1-p2;\n// 输出: Array [1, 4, 21, 30, 100000]\n\n//降序\nreture p2-p1;\n//输出: Array [100000, 30, 21, 4, 1]\n})\n\n```\n\n# 三、判断数据类型\n>ES5数据类型共有6个：数值、字符串、布尔、对象、null、undefind\n\n>ES6又新加了symbol、bigInt\n>symbol（基本数据类型）是指独一无二的值，通过Symbol()生成的值都是唯一的，用来最为对象属性的标识符。\n\n>bigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示，数据必须加后缀n。\n\n`null被称为空对象指针：初始化对象时最好将其初始化为null。`\n\n`undefined:变量没有初始化、函数参数没提供、对象中属性没赋值、函数没有返回值，这些都为undefind`\n\n## 1、 判断基本数据类型\n- typeof x 。\n- x.constructor\n- Object.prototype.toString.call(x)\n\n\n# 四、比较运算\n><=、=、>=、==、!=  、! = =、 ===\n>`在比较运算符中==和===存在比较差异，==只比较值是否一样，而===则是值和类型同时比较；同理!=和!==一样`。\n\n# 五、跳出循环\n>break: 跳出整个大循环\n>continue：只跳出本次循环，开始下一次循环\n\n# 六、字符串方法\n>在字符串中如果要显示单引号或者双引号，需要转义在引号前加‘ \\ ’用来转义。\n\n## charAt（）\n>用来返回字符串中某个位置的字符，允许为负或者比字符串索引大，但返回一个空字符。\n\n## concat ( )\n>用来连接两个字符串，返回一个新字符串，不改变原字符串，可接受多个参数，如果参数不为字符串，则该方法会先将其转换为字符串。\n>用+来也可以代替该方法，字符串拼接。\n\n## substring（）\n>用来从原字符串取出子字符串并返回，不改变原字符串，它的第一个参数表示开始位置，第二个参数表示结束位置（结果不包含）。\n>只传一个参数则会返回该位置到结束的字符串\n>第一个参数比第二个参数，则会自动交换位置\n>如果为负，则会从0开始\n\n##  substr（）\n>与substring（）作用一样，但是参数不同\n>第一个参数为起始位置，第二个参数为长度\n>省略第二个参数则会从开始位置直到结束\n>如果第一个参数为负则会从倒数计算字符位置，第二个参数是负数，将会被自动转为0，返回空字符串\n\n\n##  indexOf（）\n>用来确定一个字符串在另一个字符串中出现的位置，返回结果为匹配开始的位置。\n>也可以传入第二个参数，表示从该位置开始匹配\n\n>在ES6中新增：\n>（1）includes()：返回布尔值，判断是否找到参数字符串。\n（2）startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。\n（3）endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。\n>都支持第二个参数，表示从这个位置开始。\n\n##  trim（）\n>用来去除字符串两端的空格，返回一个新字符串，不改变原字符串\n>去除的包括制表符（\\t、\\v）、换行符（\\n）和回车符（\\r）\n\n>ES6扩展方法trimEnd()和trimStart()方法，分别是去掉尾部和头部\n\n\n##  split（）\n>利用规则来将字符串分割开，返回一个结果数组\n>如果参数为空字符串，则会分割每一个字符\n>不传参数则返回整个字符串，不做分割\n>第二个参数则是返回结果的个数\n\n##  ES6其它新增字符串方法\n###  repeat（）\n>用来将字符串重复指定次数返回，不改变原字符串\n>参数为正整数，则返回指定次数\n>参数为非负小数，则向下取整\n>如果参数是0~-1之间的数，则取整，为0\n>如果参数是NaN，则为0次\n>如果参数为负数或者Infinity，则报错\n>如果为字符串，则会先转换为数字\n\n###  字符串补全\n>padStart（）:返回新字符串，表示用参数字符串从头补全原字符串。\n>padEnd（）:返回新字符串，表示用参数字符串从后边补全原字符串\n\n>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。\n\n#  七、数组方法\n## 数组静态方法Array.isArray()\n  >用来弥补typeof判断数组返回object的缺陷，该方法会返回布尔值表示参数是否为数组。\n\n##  push()和pop()方法\n>push用来在数组末端添加一个或多个元素，会改变原数组\n>pop用来删除数组最后一个元素并返回，会改变原数组\n\n##  shift（)和unshift()方法\n>shift用来删除数组第一个元素，并返回该元素，会改变原数组\n>unshift用来在数组头部添加元素，并返回添加元素的长度\n\n##  join（）方法\n>用来以参数作为分割符，将所有数组成员连接为一个字符串并返回，如果不提供，默认为逗号。如果数组的成员为Null或undefind或空位，会被转层空字符串。\n\n\n##  concat（）方法\n>用来多个数组合并，将新数组的成员，添加到原数组的后部，返回一个新数组，原数组不变。\n>参数除了数组外，还有可以传入其它类型的参数，并将其添加到原数组后边。\n\n\n##  reverse（）方法\n>用来颠倒数组元素，返回改变的数组，原数组会改变\n\n##  indexOf（）方法\n>用来返回给定元素在数组中第一次出现的位置，不存在返回-1\n>第二个参数表示开始查找的位置\n\n\n#  变量提升（hoisting）\n>在JS引擎工作时，先解析代码，获取所有被声明的变量，然后顺序执行，所有的变量声明语句，都会被提升到代码的头部。\n\n#  函数提升\n>JS引擎会将函数名视同变量一样，采用function声明函数时，整个函数会像变量一样提升到头部。\n\n\n#  Math对象\n##  Math.abs()\n>用来返回参数值的绝对值\n\n##   Math.max()和Math.min()\n>返回参数中最大值或最小值\n>参数为空时，返回-Infinity或Infinity\n\n##  Math.floor（）和Math.ceil（）\n>返回参数向下取整或者向上取整的值\n\n## Math.random()\n>返回一个0~1的随机数\n\n>某个范围的随机整数：\n\n```javascript\nfunction f(min,max) {\n    let result=Math.random()*(max-min)+min;\n    result=Math.floor(result);\n    return result;\n  }\n```\n#  Date对象\n>JS原生的时间库\n\n##  Date.now()\n>返回当前事件距离四件零点（1970年1月1日00：00：00 UTC）的毫秒数，相当于Unix时间戳乘以1000\n\n###  时间戳\n>是指格林威治时间（1970年1月1日00：00：00 ）北京时间（1970年1月1日08：00：00 ）起到现在总秒数。\n\n###  Date提供的get方法\n\n \n\n```javascript\ncost d=new Date('January 6,2022'); \n```\n\n - getTime()：返回实例距离1970年1月1日的毫秒数\n - getDate()：返回实例对象对应每个月的几号\n - getDay()：返回星期几，从0开始\n - getYear()：返回距离1900的年数\n - getFullYear()：返回四位的年份\n - getMonth：返回月份，从0开始\n - getHours：返回小时\n - getMillisecinds：返回毫秒\n - getMinutes：返回分钟\n - getSeconds()：返回秒\n\n","tags":["前端","JS","方法"],"categories":["JS","前端"]},{"title":"Vue模板语法","url":"/2022/09/12/Vue模板语法/","content":"\n\n---\n\n# 前言\n\n在Vue中，模板语法 的使用是频繁的。\n\n\n---\n\n\n# 一、插值\n## 1.插值语法\n插值语法用于文本的插入，数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：\n\n```javascript\n<span>Message: {{ msg }}</span>\n```\nMustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。也就是数据的动态绑定。\n值得注意的是插值语法中可以使用JavaScript的表达式。\n主要用于解析标签体内容。\n## 2.指令语法\n用于解析标签（标签属性、标签体内容、绑定事件...）\n### （1）数据绑定指令\n#### v-bind:(单向数据绑定)\n v-bind指令可以用于响应式地更新 HTML attribute。\ndata中的数据改变可以影响页面数据，但反过来不行。\n```javascript\n<a v-bind:href=\"url\">...</a>\n```\n其中href为参数，url是绑定的值，该指令也可以简写为“：”\n\n```javascript\n<a :href=\"url\">...</a>\n```\n#### v-model:双向数据绑定)\n该指令只能用于表单类元素（input、select等），也就是拥有value的标签，v-model实际上是通过标签value值来控制标签内容。\n\n```javascript\n<input type=‘button' v-model:value='name'/>\n```\n>也可以简写为：\n\n```javascript\n<input type=‘button' v-model='name'/>\n```\n\n改变输入框的值也会 影响data中的值，反过来也可以。\n### （2）事件监听指令\n#### v-on:(事件监听）\n用于事件的触发监听来执行对应的JS表达式。\n\n```javascript\n<input type=‘button' v-on:click='num++'/>\n```\n监听了点击事件使num每点击一下+1，也可以是一个函数\n\n```javascript\n<button v-on:click='say()'>Say hi</button>\n```\n该指令也可以简写为“@”\n\n```javascript\n<input type=‘button' @click='num++'/>\n```\n### （3）条件渲染指令\n#### v-if、v-else-if、v-else\n和判断相同根据表达式值在DOM中渲染或销毁元素或组件\nv-else是没有判断条件的，如果你加上去不会影响得到的结果\n```javascript\n  <p v-if=\"flag===‘晴’\">今天大晴天</p>\n  <p v-else-if=\"flag==='多云'\">今天多云</p>\n  <p v-else>今天下雨</p>\n```\n\n#### v-show\n和v-if类似，根据表达式的值控制标签或者组件的显示与隐藏。\n\n```javascript\n  <p v-show=\"flag\">今天要下雨</p>\n  <p v-show=\"!flag\">今天不要下雨</p>\n```\n### （4）内容渲染指令\n#### v-text\nv-text用法简单，只能用来渲染纯文本内容，如下：\n\n```javascript\n<p v-text=\"username\"></p>\n```\n他的缺点是他会直接覆盖掉原来标签里的内容。\n\n---\n\n#### v-html\n如果要渲染带包含html标签的内容，可以使用v-html\n\n```javascript\n<div v-html=\"content\"></div>\n\nconst vm = new Vue({\n            el: \"#app\",\n            data: {\n                content: \"<h1>你好</h1>\"\n            }\n        })\n```\n\n### （5）列表渲染指令\n#### v-for\n需要生成多个某个标签，就可以在该标签上加入v-for进行动态生成,v-for可以遍历**数组、对象、字符串以及指定次数**（将in或of后边换成数字即可）,v-for可以接收两个参数，其中第一个为每一项，第二个是当前索引值。\n具体语法如下：\n\n```javascript\n<ul>\n<li v-for=\"（item,inex） in 某个数据集合\" :key=\"index\">\n{{形参.数据集合的属性}}\n</li>\n</ul>\n```\nin也可以换成of，某些版本可能不行\n对于绑定的key（标识符）的使用存在着一些问题，后面可能会在其它文章中体现。\n## 指令间的小tips\n### 1.v-if和v-show\n\n\n  **（1）v-if和v-show的区别**：\n \n - v-if控制元素是否渲染到页面（是否创建）\n - v-show控制元素是否显示（已经创建，是否显示）\n \n **（2）v-if和v-show如何选择**：\n - 当频繁的切换显隐时使用v-show\n - 只有一次的切换时使用v-if\n \n###  2.v-if和v-for\nv-if的优先级是没有v-for的高的，也就是说将两个指令用在同一个标签上时，会先进行循环，再进行判断。\n这样做会导致性能受到影响。\n在源码中可以发现，他判断的顺序是：once-->for-->if(也就不难理解为什么for的优先级会比if高了)\n```javascript\nexport function genElement(el: ASTElement, state: CodegenState): string {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre\n  }\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      let data\n      const maybeComponent = state.maybeComponent(el)\n      if (!el.plain || (el.pre && maybeComponent)) {\n        data = genData(el, state)\n      }\n\n      let tag: string | undefined\n      // check if this is a component in <script setup>\n      const bindings = state.options.bindings\n      if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {\n        tag = checkBindingType(bindings, el.tag)\n      }\n      if (!tag) tag = `'${el.tag}'`\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c(${tag}${\n        data ? `,${data}` : '' // data\n      }${\n        children ? `,${children}` : '' // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n```\n\n如果想一起使用，可以在标签外层嵌套一层，将v-if绑定在外层。\n###  3.v-on事件修饰符\n事件修饰符可以多个一起用（如：事件.prevent.stop）。\n- @事件.prevent:阻止默认事件\n- @事件.stop:阻止事件冒泡（在包含关系中不同标签上有相同的触发函数，导致这两个被关联起来）\n- @事件.once:事件只触发一次\n- @事件.capture：使用事件捕获模式\n- @事件.self：只有event.target是当前操作的元素才触发事件\n- @事件.passive：事件的默认行为立即执行，无需等待事件回调执行\n\n###  3.v-on键盘事件\n@keyup:按键放开触发\n@keydown：按键按下触发\n\n几个按键也可以同时使用（如：@keyup.ctrl.y）。\n\n根据按键触发:\n**@keyup.按键别名**\n\n常用按键别名：\n\n - 回车：enter\n - 删除：delete\n - 退出：esc\n - 空格：space\n - 换行：tab（只能配合@keydown中使用）\n - 上：up\n - 下：down\n - 左：left\n - 右：right\n\n---\n获取按键名称或者编码：\n\n```javascript\nshow(e){//事件调用函数\ne.key;//按键名称\ne.keyCode;//按键编码\n}\n```\n\n---\n系统修饰键（特殊）：**ctrl、alt、shift、meta**\n配合keyup使用时必须同时按下其它键，释放后才会触发，keydown中正常。\n\n---\nVue自定义别名按键\n**Vue.config.keyCodes.自定义键名=键码；**\n# 总结\n\n\n以上就是今天要讲的内容，本文简单介绍了Vue的模板语法，以及常用的指令语法\n\n","tags":["Vue","指令语法"],"categories":["Vue","前端","指令"]},{"title":"JS运行机制 Vue全局API nextTick源码分析","url":"/2022/09/12/JS运行机制 Vue全局API nextTick源码分析/","content":"\n---\n\n# 前言\n\n\nVue中nextTick的实现原理和对源码的分析。\n\n---\n\n\n\n# 一、nextTick是什么？\n\n官方文档中，提到nextTick是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n在Vue开发时，有没有遇到这样的情况，在改了data里的数据后获取DOM时里边的值竟然还是原来的值，甚至在循环中，这次获取的DOM永远是上一次的状态，但页面明明都变了呀，但是在使用nextTick后这种情况的到解决，简直摸不到头脑。\n不过，在查看nextTick源码，还有网上的相关资料后，豁然开朗。\n有意思的是官方文档还标注了：\n\n> 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\n\nIE躺着也中枪，源码中确实也体现了官方的这句话。\n\n# 二、为什么会出现这种情况\n## 1.JS的运行机制？\n神XX机制，我真的会谢，能用就行呗，哈哈哈哈，开玩笑，开玩笑。\n说起JS运行机制，还真没了解过，趁这个机会，好好了解一下。\n\n### （1）JS运行机制流程\nJS的执行竟然是单线程的，我不知道，这是为什么，可能是机制吧，他是靠事件循环来执行。具体流程如下：\n\n---\n 1. 在主线程运行时，会形成执行栈，栈中在执行过程中遇到任务源，将任务源中的回调函数加入到任务队列中\n 2. 执行栈执行完成后，会将任务队列中的回调函数放入执行栈依次执行。\n ---\n 经过反复循环这两个操作，就变成了事件循环。\n### （2）同步、异步执行过程\n同（1）中所讲一致，不过**同步任务**是直接放到执行栈中执行，异步任务只能看着，突然发现还有一个**任务队列**，异步任务赶紧把自己的**任务**给他，让任务队列在同步执行**完成后**喊他。\n\n#### 任务：\n在任务里边也有分类，分为**宏任务**和**微任务**\n##### 宏任务：\n- 在宏任务执行过程中，可以创建宏任务加到宏任务队列的最后等待下一次循环执行；也可以创建微任务，加入到本次宏任务下微任务队列的最后，会在本次宏任务结束后顺序执行。（每个宏任务都有个微任务队列）\n- 在本次宏任务执行完成后，这时候才去执行宏任务下的微任务队列，微任务结束后，算一个task执行完成。\n- **在一个task执行完成，页面会进行渲染，然后进入下一个task。**（Event loop）\n- 常见的宏任务：`setTimeout, setInterval, requestAnimationFrame, I/O, script标签内代码，setImmediate`等。\n\n##### 微任务：\n- 微任务创建的宏任务，会被加入到宏任务队列的最后。\n- 微任务创建的微任务会被加入到微任务队列的最后，微任务会在本次task中执行完成。\n- 常见的微任务有：\t`Promise callback， Promise.then，MutationObserver`\n##### 解释场景问题\n到这，大家应该知道为啥获取DOM的状态是上一次的吧，是因为渲染DOM都是异步进行的，在更改数据时，Vue开启了事件队列，数据更改的任务被推进了任务队列，在此时依赖了DOM时获取的肯定是上一次DOM状态，因为那时候DOM还没到重新渲染，只不过这个时间太短，你感觉不出来。\n\n# 三、nextTick源码分析\n## 1.浏览器能力？\nnextTick执行延迟回调，如何实现这个功能，这可离不开浏览器的能力，浏览器的能力决定了nextTick以什么样的方式去实现这个功能，说白了就是最大限度提升性能。\n### 如何判断浏览器能力？\n`微任务的耗时是小于宏任务的`\n- 当然是if（）喽，首先去判断支不支持Promise，在其中把回调函数队列给Promise.then，然后就创建了微任务，值得注意的是在IOS中支持Promise，但他队列不更新，所以要加个空的任务强制刷新下队列。\n\n- 如果不支持Promise也没关系，他会去找有没有原生的MutationObserver的API（ES5中检测DOM节点变化的API），显然它创建的也是个微任务\n- 实在不行就来到了setImmediate，IE可以直接跳过前两个直接来到这，因为自身条件不达标，从这个开始创建的是宏任务了。\n- 最不推荐的就是setTimeout了，他是最慢的。\n\n```javascript\n// 判断浏览器的能力：\n// 顺序：Promise-->MutationObserver-->setImmediate-->setTimeout\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop) // ios具备promise但不会更新队列信息，所以强制加入一个空计时器，强制刷新。\n  }\n  isUsingMicroTask = true\n} else if ( //接下来就是判断有没有原生的MutationObserver，用来检测DOM树变化的API。\n  !isIE &&\n  typeof MutationObserver !== 'undefined' &&\n  (isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]')\n) {\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  // 靠MutationObserver中characterData属性去观察目标节点（textNode）下所有文本类型节点（即子代或后代）的文字变化\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n  // 然后是setImmediate 前两个都是创建微任务，但从这个开始就是创建宏任务了\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  // 最后推荐的是setTimeout，宏任务间也是有差距的\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n```\n## 2.回调队列函数\n回调队列函数中很简单，上锁和循环执行回调队列，\n\n```javascript\n// 执行回调队列函数\nfunction flushCallbacks() {\n  pending = false //重置异步锁\n  // 将回调函数队列复制并清空回调函数队列。防止nextTick中套娃出现错误，防止在回调函数中调用nextTick时将其回调函数加入到这个队列中，也就是不会开启多个异步任务。\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n```\n## 3.nextTick主体\n- 将传进来的回调函数推入对调队列中，再判断异步锁是否上锁，如果未上锁就在上锁后执行异步函数创建异步任务等待同步任务执行完成。\n- 如果没有回调，则在支持Promise的情况下返回一个Promise（IE无语）\n\n```javascript\nexport function nextTick(cb?: (...args: any[]) => any, ctx?: object) {\n  let _resolve\n  // 将回调函数推入回调队列\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e: any) {\n      // 发生错误时，回滚并调用全局API handleError获取错误信息\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  // 如果异步锁未上锁，则锁上异步锁，调用异步函数等待同步函数完成\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n  // $flow-disable-line\n  // 如果没有回调并且支持Promise则返回一个Promise\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n```\n\n# 总结\n\n以上就是今天记录的内容，本文对JS的运行机制和nextTick原理进行了分析，其次除了nextTick外，可以用$forceUpdate ，强制更新，他只会影响到实例本身和插入插槽内容的子组件。\n\n","tags":["JS","API","Vue","源码"],"categories":["JS","Vue","前端"]},{"title":"包含min函数的栈","url":"/2022/09/12/包含min函数的栈/","content":"# 问题描述：\n\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n---\n\n# 例子\n\n示例 1：\n\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.min();   --> 返回 -2.\n\n--- \n# 提示：\n\n各函数的调用总次数不超过 20000 次\n\n---\n\n\n# 代码实现：\n## 1.辅助栈：\n>寻找最小的值，开始时辅助栈入栈一个无穷大数保证在栈中没有元素盗用Min()方法任然是正常的，可以在每一次添加的时候利用辅助栈入栈一个当前最小值min，在出栈时，同时将两个栈出栈并更新min的值为辅助栈顶值，保证min是正确的。\n```java\nstatic class MinStack {\n        Stack<Integer> stack;\n        Stack<Integer> stack2;//辅助栈\n        public int min;//记录最小值\n        public MinStack() {\n            min=Integer.MAX_VALUE;\n            stack=new Stack<>();\n            stack2=new Stack<>();\n            stack2.push(min);\n        }\n\n        public void push(int x) {\n            System.out.println(\"加入的值为：\"+x);\n            stack.push(x);\n            min= Math.min(x, min);//记录最小值\n            stack2.push(min);\n            System.out.println(\"加入后栈为：\"+stack);\n        }\n\n        public void pop() {\n            stack.pop();\n            stack2.pop();\n            min=stack2.peek();//出栈后及时更新min的值\n            System.out.println(\"出栈后栈为:\"+stack);\n        }\n\n        public int top() {\n            System.out.println(\"栈顶元素为：\"+stack.peek());\n            return stack.peek();\n        }\n\n        public int min() {\n            System.out.println(\"最小值为：\"+min);\n            return min;\n        }\n    }\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0ce05eb0fe7452e9c3f1a82912fdcea.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)\n","tags":["算法","简单","offer","力扣","栈"],"categories":["力扣","栈"]},{"title":"用两个栈实现队列","url":"/2022/09/12/用两个栈实现队列/","content":"\n# 问题描述：\n\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n\n---\n\n# 例子\n\n示例 1：\n输入：\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n\n示例 2：\n输入：\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n\n\n---\n# 提示：\n\n1 <= values <= 10000\n最多会对 appendTail、deleteHead 进行 10000 次调用\n\n---\n\n\n# 代码实现：\n## 1.双栈元素翻转：\n>模拟示例二\n```java\n /*\n       题目描述：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n       解题思路：利用栈的特性，添加直接在A栈尾部添加，删除时将A的元素依次出栈并入栈到B中，B出栈尾元素后，将剩余元素依次出栈并入栈到A，此时完成删除。\n     */\n    public static void main(String[] args) {\n        CQueue obj=new CQueue();\n        obj.deleteHead();\n        obj.appendTail(5);\n        obj.appendTail(2);\n        obj.deleteHead();\n        obj.deleteHead();\n    }\n     static class CQueue{\n        Stack<Integer>A,B;\n        public CQueue(){\n            A=new Stack<>();\n            B=new Stack<>();\n        }\n\n        public  void appendTail(int value){//直接入栈\n            System.out.println(\"添加的值为\"+value);\n            A.push(value);\n            System.out.println(\"添加后：\"+A.toString());\n        }\n        public  int deleteHead(){\n            if (A.isEmpty()){//如果为空则返回-1\n                System.out.println(\"队列中没有值可以删\"+A);\n                return -1;\n            }\n            System.out.println(\"删除前:\"+A);\n           while (!A.isEmpty()){//出栈所有元素并入栈到B\n               B.push(A.pop());\n           }\n           int value=B.pop();//删除的元素\n           while (!B.isEmpty()){//重新将B中剩于元素入栈到A\n               A.push(B.pop());\n           }\n            System.out.println(\"删除后：\"+A.toString());\n            System.out.println(\"本次删除的是：\"+value);\n            return value;\n        }\n    \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/53fd16a174624d149674c39f7eba557a.png)\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof)\n","tags":["算法","简单","offer","力扣","栈","队列"],"categories":["力扣","栈"]},{"title":"二进制加法","url":"/2022/09/12/二进制加法/","content":"\n# 问题描述：\n\n给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。\n            输入为 非空 字符串且只包含数字 1 和 0。\n\n---\n\n# 例子\n\n示例 1：\n\n输入: a = \"11\", b = \"10\"\n输出: \"101\"\n\n示例 2：\n输入: a = \"1010\", b = \"1011\"\n输出: \"10101\"\n\n示例 3：\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n\n---\n# 提示：\n\n- 每个字符串仅由字符 '0' 或 '1' 组成。\n- 1 <= a.length, b.length <= 10^4\n- 字符串如果不是 \"0\" ，就都不含前导零。\n\n---\n\n\n# 代码实现：\n## 对位相加：\n>通过对位相加满2进1的思路进行计算，不足位用0代替。\n>字符运算时是通过ASCII码进行计算的，所以在计算时结果应“ -‘0’ ”，取余时应“ +‘0’ ”\n```java\npublic static String addBinary(String a,String b){\n         StringBuilder ans=new StringBuilder();//存字符的\n         int n= Math.max(a.length(), b.length());//选择最长的字符长度\n         int carry=0;//进位计数\n         for (int i=0;i<n;i++){//从最右边开始＋，没有的用0代替\n             carry+=a.length()>i?(a.charAt(a.length()-i-1)-'0'):0;// 字符运算时通过ASCII码进行计算的所以这里要“-‘0’”使其值是对的\n             carry+=b.length()>i?(b.charAt(b.length()-i-1)-'0'):0;\n             ans.append((char)(carry%2+'0'));//取余查看剩下是0还是1\n             carry /=2;//进位是否为1\n         }\n         if (carry==1){//最终最高位判定\n             ans.append('1');\n         }\n         ans.reverse();//翻转\n         return ans.toString();\n     }\n```\n## 运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/57cd83457cbc4d6480be4fc6f8f062ae.png)\n\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/JFETK5/)\n","tags":["算法","简单","offer","力扣","字符串"],"categories":["力扣","字符串"]},{"title":"奇偶排序（左边为奇数右边为偶数）","url":"/2022/09/12/奇偶排序（左边为奇数右边为偶数）/","content":"\n\n# 问题描述：\n\n\n给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数;并且都要分别有序。\n\n第一行输入整数n。(1<=n<=1000)表示数组大小 第二行输入n个整数a.(1<=n<=100)\n\n---\n\n# 例子\n\n示例 1：\n\n输入：\n6\n3 34 67 89 90 58\n输出：3 67 89 34 90 58\n\n\n---\n# 提示：\n\n无\n\n---\n\n\n# 代码实现：\n## 1.双指针：\n```java\npublic static ArrayList<Integer> solution(int n, ArrayList<Integer> arr){\n        ArrayList<Integer> result = new ArrayList<>();\n        ArrayList<Integer> result2 = new ArrayList<>();\n        int left=0;\n        int right=0;\n        int L=0;\n        int R=n-1;\n        while (L <= R) {// 双指针查找，左指针位偶就去 右指针找奇数，然后交换位置，最后左右指针相遇结束，就得到了左边位奇数，右边为偶数的数组，但是不是有序的的。\n            if (arr.get(L) % 2 == 0) {\n                left = arr.get(L);\n\n                while (true) {\n                    if (L > R) {\n                        break;\n                    }\n                    if (arr.get(R) % 2 != 0) {\n                        right = arr.get(R);\n                        arr.set(L++, right);\n                        arr.set(R--, left);\n\n                        break;\n                    } else {\n                        R--;\n                    }\n                }\n            } else {\n                L++;\n            }\n        }\n        //有序处理\n        for(Integer item:arr){\n            if(item%2==0){\n                break;\n            }\n            result.add(item);\n        }\n        for(int i=n-1;;i--){\n            if(arr.get(i)%2!=0){\n                break;\n            }\n            result2.add(arr.get(i));\n        }\n        arr.clear();\n        Collections.sort(result);\n        Collections.sort(result2);\n        arr.addAll(result);\n        arr.addAll(result2);\n        return arr;\n    }\n```\n---\n## 运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/93bd12f4b9314ecfb304b098108cc3ab.png#pic_center)\n\n---\n题目来源：CSDN\n链接: [CSDN题目](https://edu.csdn.net/skill/program/28795?practiceId=6842155)\n","tags":["算法","数组","简单","offer","力扣"],"categories":["力扣","排序"]},{"title":"offer整数除法","url":"/2022/09/12/offer整数除法/","content":"\n# 问题描述：\n\n\n给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。\n注意：\n\n - 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1\n\n---\n\n# 例子\n\n示例 1：\n输入: a = \"11\", b = \"10\"\n输出: \"101\"\n解释：15/2 = truncate(7.5) = 7\n\n示例 2：\n输入：a = 7, b = -3\n输出：-2\n解释：7/-3 = truncate(-2.33333..) = -2\n\n示例 3：\n输入：a = 0, b = 1\n输出：0\n\n示例 4：\n输入：a = 1, b = 1\n输出：1\n\n---\n# 提示：\n\n- -231 <= a, b <= 231 - 1\n- b != 0\n\n---\n\n\n# 代码实现：\n## 1.O（n）：\n>用a不断的减去b，然后累加次数，就是结论，但是要考虑越界问题，所以把两个数全弄成负数，再考虑边界问题单独解决\n```java\nclass Solution {\n    public int divide(int a, int b) {\n     // 32 位最大值：2^31 - 1 = 2147483647\n    // 32 位最小值：-2^31 = -2147483648\n    // -2147483648 / (-1) = 2147483648 > 2147483647 越界了\n    if (a == Integer.MIN_VALUE && b == -1)\n        return Integer.MAX_VALUE;\n    int sign = (a > 0) ^ (b > 0) ? -1 : 1;\n    /\n    if (a > 0) a = -a;\n    if (b > 0) b = -b;\n    int res = 0;\n    while (a <= b) {\n        a -= b;\n        res++;\n    }\n    // 因为不能使用乘号，所以将乘号换成三目运算符\n    return sign == 1 ? res : -res;\n\n作者：tangweiqun\n链接：https://leetcode.cn/problems/xoh6Oh/solution/jian-dan-yi-dong-javac-pythonjs-zheng-sh-e8r6/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n    }\n}\n```\n## 2.常数级别（31次循环）：\n>和上面一样，思路就是每次用减法来计算，但是是从最大的数开始找，也就是从2^31（最大）开始找，如果不够将2的指数依次减小，\n```java\nclass Solution {\n    public int divide(int a, int b) {\n       if (a == Integer.MIN_VALUE && b == -1) {\n            return Integer.MAX_VALUE;\n        }\n        int symbol=(a>0)^(b>0)?-1:1;// 符号判断\n        a=Math.abs(a);\n        b=Math.abs(b);\n        int res=0;\n        for(int i=31;i>=0;i--){\n            //右移避免越界\n            // >>>无符号右移， -2147483648看成正的2147483648\n            if ((a>>>i)-b>=0){// 和a>=(b<<i)一样但是有可能越界\n                a-=(b<<i);\n                res+=(1<<i);// 累加结果\n            }\n        }\n        return symbol==1?res:-res;\n    }\n}\n\n```\n\n\n\n```\n\n题目来源：力扣（LeetCode）\n[LeetCode题目](https://leetcode.cn/problems/xoh6Oh/?plan=lcof&plan_progress=gdsixbt)\n","tags":["算法","简单","offer","力扣"],"categories":["力扣","整数"]},{"title":"H5声明和H5基本骨架，各种标签以及H5的新标签","url":"/2022/09/12/HTML5简介和H5新标签/","content":"# 前言\nH5声明和H5基本骨架，各种标签以及H5的新标签\n\n---\n\n# 一、HTML5的DOCTYPE声明\n\n>DOCTYPE是document type(文档类型)的缩写，<!DOCTYPE html>是H5的声明，位于文档最前面，他是网页必备组成部分，避免浏览器的怪异模式。\n\n# 二、HTML5的基本骨架\n## 1.html标签\n\n - 包裹其它标签\n - 限定文档的开始和结束\n> `<html lang=\"en\">`表示当前网页语言为英文\n  \n## 2.head标签\n\n - 定义文档的头部，包括文档的各种属性和信息，包括标题\n - 不展示给用户\n - 和其他文档的关系\n - 在Web中的位置\n\n>`<meta charset=\"UTF-8\">`表示当前编码为UTF-8\n## 3.body标签\n\n - 定义文档的主体\n - 包括了文档所有内容（文本、超链接、图像、表格、列表）\n - 直接在页面中显示，用户直观看到的内容\n\n## 4.title标签\n\n - 定义文档标题\n - 显示在浏览器窗口的标题栏或状态栏上\n - 该标签是head标签中唯一必须的标签\n - 有利于SEO优化（浏览器搜索引擎搜索的排名）\n\n---\n\n# 二、标题标签\n>标题（Heading）是通过<h1>~<h6>标签来定义的。\n><h1>定义最大 标题，<h6定义最小标题>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n</body>\n</html>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cbd4185ac2664813b43d2ea3d4e9104d.png)\n>标签位置摆放：\n>在标签中添加属性align=\"left | center | right\"默认居左\n\n```html\n<h1 align=\"center\">一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e0929400b67343b3a6d2ea18c191862f.png)\n\n\n`正确使用标题标签有利于SEO优化`\n\n\n# 三、段落、换行、水平线标签\n## 1、 段落\n>段落用`<p>`标签定义\n\n```html\n<body>\n<p>这是一个段落</p>\n<p>这是另一个段落</p>\n</body>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e0150229b284f5bba4ea22f6a928605.png)\n\n## 2、 换行\n>换行用`<br>`标签定义,为单标签\n\n```html\n<body>\n<p>这是一个段落</p>\n<p>这是<br/>另一个段落</p>\n</body>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7a261b61db7043b38e35e02990225644.png)\n\n## 3、 水平线\n>水平线用`<hr>`标签定义,为单标签\n\n属性：\n\n - color:设置水平线颜色\n - width：设置水平线长度\n - size:设置水平线的高度\n - align:设置水平线对齐方式（默认居中），可取值 left | right\n \n `<hr color=\"red\" width=\"300px\" size=\"5px\" align=\"left\"/>`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/376c5daec6414c94a429fe268a826fbd.png)\n\n# 四、图片标签\n>图片用`<img>`标签定义,为单标签\n\n```html\n<img src=\"\" alt=\"\">\n```\n属性：\n\n - src:图片路径\n - alt:规定图像的替代文本\n - width：规定图像的宽度\n - height：规定图像的高度\n - title：鼠标悬停在图片上的提示文字\n\n路径：\n\n - 绝对路径：电脑中储存的具体位置\n - 相对路径：\n              -  子级关系：/\n              -  父级关系：../\n              -  同级关系：./  \n              \n    \n\n# 五、超文本标签\n>超文本用`<a>`标签定义\n\n```html\n<a href=\"\"></a>\n```\n属性：\n\n - href:跳转链接地址\n \n---\n1. 一个未访问过的链接显示未蓝色字体并带有下划线\n2. 访问过的链接显示未紫色并带有下划线\n3. 点击链接时，链接显示为红色并带有下划线\n\n# 六、文本标签\n>常用文本标签：\n - `<em>`: 定义着重文字\n - `<b>`:定义粗体文本\n - `<i>`:定义斜体字\n - `<strong>`:定义加重语气\n - `<del>`:定义删除字\n - `<span>`:元素没有特定含义\n\n```html\n<em>em</em>\n<br>\n<i>i</i>\n<br>\n<b>b</b>\n<br>\n<strong>strong</strong>\n<br>\n<del>del</del>\n<br>\n<span>span</span>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c72d9e968358449f832b37f03811383b.png)\n# 七、有序列表标签\n>有序列表始于`<ol>`标签，每个列表始于`<li>`标签。\n\n```html\n<ol>\n    <li>123</li>\n    <li>123456</li>\n</ol>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/05aab8e7a6cf46b6baa9a4003b36dfd3.png)\nol属性type的选项：\n - 1\n - a\n - A\n - i\n - I\n \n![在这里插入图片描述](https://img-blog.csdnimg.cn/4f310307420543fa9dd9102a5d70b8d1.png)\n>可嵌套列表：\n\n```html\n<ol type=\"A\">\n    <li>123\n    <ol>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ol>\n    </li>\n    <li>123456</li>\n</ol>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e5637b78c2c41ccb487f3fa73b61f0f.png)\n# 八、无序列表标签\n>无序列表始于`<ul>`标签，每个列表始于`<li>`标签。\n\n```html\n<ul>\n    <li>123</li>\n    <li>123456</li>\n</ul>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1c0b1d670c414977a95ece9c4acee54b.png)\nol属性type的选项：\n\n - disc:默认实心圆\n - circle:空心圆\n - squarer:小方块\n - none:不显示\n \n \n>可嵌套列表：\n\n```html\n<ul>\n    <li>123\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ul>\n    </li>\n    <li>123456</li>\n</ul>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/17db97e3d1f644c7b19a98cfd16c7ef2.png)\n\n# 九、表格标签\n>表格：`<table>`标签\n>行：`<tr>`标签\n>单元格（列）：`<td>`标签\n\n```html\n<tr>\n        <td>1</td>\n        <td>2</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2b2fdcf2f87a4acca2702c43f76bccbe.png)\n>快捷键\n>`table>tr*2>td{内容}`\n\ntable表格属性：\n\n - border: 设置表格的边框\n - width: 设置表格的宽度\n - height: 设置表格的高度\n \n \n\n```html\n<table border=\"1px\" width=\"300px\" height=\"100px\">\n    <tr>\n        <td>1</td>\n        <td>2</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n</table>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/02c1c6efd9d3499f95d8c3978630f317.png)\n\n>单元格合并属性\n>水平合并：colspan 保留左边，删除右边，值为合并单元格个数\n>垂直合并：rowspan 保留上边，删除下边，值为合并单元格个数\n\n```html\n<table border=\"1px\" width=\"300px\" height=\"100px\">\n    <tr>\n        <td colspan=\"2\">1</td>\n        <td rowspan=\"2\">3</td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td>5</td>\n    </tr>\n</table>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/83ac69c89fef4a57a08de68efe985fee.png)\n\n# 十、Form表单\n>用来给用户填写信息，从而能采集用户信息，使网页具有交互的功能。\n>表单是由容器和控件组成，一个表单一般应该包括用户填写信息的输入框，提交按钮等，这些称为控件，表单就是容器，能容纳各种控件。\n\n>`<form action=\"url\" method=\"get | post\" name=\"myForm\">`\n>属性：\n>action:服务器地址\n>name:表单名称\n>meethod：请求方式（get | post）\n\n>表单元素：\n>完整的表单包含三个基本组成部分：表单标签、表单域、表单按钮\n\n```html\n<form action=\"url\" method=\"get | post\" name=\"myForm\">\n    <input type=\"text\">\n    <button type=\"submit\">提交</button>\n</form>\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/10e8dfb02ed4447ebb82ed47cd187397.png)\n\n>文本域：用户输入字母数字等内容\n>`<input type=\"text\">`\n\n>密码框：输入的密码\n>`<input type=\"password\">`\n\n>提交按钮：用来提交表单\n>`<input type=\"submit\" value=\"登录\">`\n\n# 十一、元素分类（块、行内元素）\n块级元素     | 行内元素\n-------- | -----\n块元素会在页面中独占一行（自上而下垂直排列）  | 行内元素不会独占一行，只占自身的大小\n可以设置width,height属性  | 行内元素设置width,height属性无效\n一般块级元素可以包含行内元素和其它块级元素  | 一般行内元素不包含块级元素\n\n## 块元素\n>常见：div、form、h1~h6、hr、p、table、ul、等\n## 行内元素\n>常见：a、b、em、i、span、strong、等\n\n## 行内块级元素\n>不换行、能够识别宽高\n>常见：button、img、input、等\n\n# 十二、HTML5新增标签\n有利于搜索引擎SEO优化\n>传统的页面采用DIV+CSS实现，某个模块最外层用`<div>`标签包裹\n\n```html\n<div>\n    <form action=\"url\" method=\"get | post\" name=\"myForm\">\n        <input type=\"submit\" value=\"登录\">\n        <button type=\"submit\">提交</button>\n    </form>\n</div>\n```\n\n>H5新增标签：\n\n - `<header></header>`头部标签\n - `<nav></nav>`导航栏标签\n - `<section></section>`文档中的节，如章节、页眉、页脚\n - `<article></article>`一个独立的、完整的相关内容块\n - `<aside></aside>`侧边栏标签\n - `<footer></footer>`底部标签\n\n# 总结\n\n本文仅仅简单介绍了HTML和H5，其中包括了H5声明和各种标签\n\n","tags":["HTML","标签"],"categories":["HTML","前端"]},{"title":"二叉树的识别与应用","url":"/2022/09/12/二叉树的识别与应用/","content":"\n# 前言\n\n>二叉树节点结构：\n\n```java\n  public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data){\n            this.value=data;\n        }\n    }\n```\n\n`代码中实现的二叉树都为图片所示二叉树`\n\n\n# 一、二叉树的先序、中序、后序遍历\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b5239a183a8245ae80862c62bbf94599.png)\n二叉树递归序：1->2->3->3->3->2->4->4->4->2->1->6->7->7->7->6->1\n\n先序：1->2->3->4->6->7\n中序：3->2->4->1->7->6\n后序：3->4->2->7->6->1\n## 1、递归方式（先序、中序、后序）\n```java\npublic class traverse {\n    public static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n\n        System.out.println(\"==============二叉树遍历===============\");\n        System.out.print(\"pree-order: \");\n        preorderTraversal(head);\n\n        System.out.println();\n        System.out.print(\"in-order: \");\n        inorderTraversal(head);\n\n        System.out.println();\n        System.out.print(\"pos-order: \");\n        postOrderTraversal(head);\n\n    }\n    // 树节点\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    //先序遍历\n    public static void preorderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        System.out.print(head.value+\" \");\n        preorderTraversal(head.left);\n        preorderTraversal(head.right);\n    }\n\n    //中序遍历\n    public static void inorderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        inorderTraversal(head.left);\n        System.out.print(head.value+\" \");\n        inorderTraversal(head.right);\n    }\n\n    //后序遍历\n    public static void postOrderTraversal(Node head){\n        if (head==null){\n            return;\n        }\n        postOrderTraversal(head.left);\n        postOrderTraversal(head.right);\n        System.out.print(head.value+\" \");\n    }  \n}\n\n```\n\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/dc5e3ca1645e40538685bd0032bae0e0.png)\n\n## 2、非递归（先序、中序、后序）\n\n```java\npublic static void main(String[] args) {\n        traverse.Node head=new traverse.Node(1);\n        head.left=new traverse.Node(2);\n        head.right=new traverse.Node(6);\n        head.left.left=new traverse.Node(3);\n        head.left.right=new traverse.Node(4);\n        head.right.left=new traverse.Node(7);\n\n        System.out.println(\"==============二叉树非递归遍历===============\");\n        preOrderUnRecur(head);\n\n        System.out.println();\n        inOrderUnRecur(head);\n\n        System.out.println();\n        posOrderUnRecur1(head);\n\n\n    }\n    // 树节点\n    public static class Node{\n        public int value;\n        public traverse.Node left;\n        public traverse.Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    //先序遍历\n    public static void preOrderUnRecur(Node head){\n        System.out.print(\"pre-order: \");\n        if (head!=null){\n            Stack<Node> stack=new Stack<Node>();\n            stack.add(head);\n            while (!stack.isEmpty()){\n                head=stack.pop();\n                System.out.print(head.value+\" \");\n                if (head.right!=null){\n                    stack.push(head.right);\n                }\n                if (head.left!=null){\n                    stack.push(head.left);\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    //中序遍历\n    public static void inOrderUnRecur(Node head){\n        System.out.print(\"in-order: \");\n        if (head!=null){\n            Stack<Node>stack=new Stack<Node>();\n            while (!stack.isEmpty() || head != null){\n                if (head!=null){// 把左边界都入栈\n                    stack.push(head);\n                    head=head.left;\n                }else {// 依次弹节点并跳到右结点\n                    head=stack.pop();\n                    System.out.print(head.value+\" \");\n                    head=head.right;\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    // 后序遍历\n    // 用先序遍历的 头右左 逆序输出就是后序遍历\n    public static void posOrderUnRecur1(Node head){\n        System.out.print(\"pos-order: \");\n        if (head!=null){\n            Stack<Node>s1=new Stack<Node>();\n            Stack<Node>s2=new Stack<Node>();\n            s1.push(head);\n            while (!s1.isEmpty()){\n                head=s1.pop();\n                s2.push(head);\n                if (head.left!=null){\n                    s1.push(head.left);\n                }\n                if (head.right!=null){\n                    s1.push(head.right);\n                }\n            }\n            while (!s2.isEmpty()){\n                System.out.print(s2.pop().value+\" \");\n            }\n        }\n        System.out.println();\n    }\n```\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/f7d15bb9db1a4283b9b6c6071afd36ac.png)\n\n# 二、宽度优先遍历\n## 1.遍历\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n        System.out.println(\"==========宽度优先遍历===========\");\n        w(head);\n    }\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n    public static void w(Node head){\n        if (head==null){\n            return;\n        }\n        Queue<Node>queue=new LinkedList<>();\n        queue.add(head);\n        while (!queue.isEmpty()){\n            Node cur=queue.poll();\n            System.out.print(cur.value+\" \");\n            if (cur.left!=null){\n                queue.add(cur.left);\n            }\n            if (cur.right!=null){\n                queue.add(cur.right);\n            }\n        }\n    }\n```\n\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/70d8b13a66ac4607b713b277166f4f11.png)\n## 2、最大宽度查找\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(6);\n        head.left.left=new Node(3);\n        head.left.right=new Node(4);\n        head.right.left=new Node(7);\n\n        System.out.println(\"==========最大宽度===========\");\n        System.out.println(\"该树最大宽度为： \"+w(head));\n    }\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n    public static int w(Node head){\n        if (head==null){\n            return 0;\n        }\n        Queue<Node> queue=new LinkedList<>();\n        queue.add(head);\n        HashMap<Node,Integer>levelMap=new HashMap<>();\n        levelMap.put(head,1);\n        int curLevel=1;\n        int curLevelNodes=0;\n        int max=Integer.MIN_VALUE;\n        while (!queue.isEmpty()){\n           Node cur=queue.poll();\n           int curNodeLevel=levelMap.get(cur);\n           if (curNodeLevel==curLevel){\n               curLevelNodes++;\n           }else {\n               max=Math.max(max,curLevelNodes);\n               curLevel++;\n               curLevelNodes=1;\n           }\n            if (cur.left!=null){\n                levelMap.put(cur.left,curNodeLevel+1);\n                queue.add(cur.left);\n            }\n            if (cur.right!=null){\n                levelMap.put(cur.right,curNodeLevel+1);\n                queue.add(cur.right);\n            }\n        }\n        max=Math.max(max,curLevelNodes);\n        return max;\n    }\n```\n> 运行结果：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/eecd7eb2fb0a484f911ab85d7a26fb12.png)\n\n# 三、是否为搜索二叉树\n## 1、搜索二叉树\n>整棵树右子树要大于左子树的值，称该树为搜索二叉树，如图:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b36f09f405b94d3b8eac45d054a76b76.png)\n\n\n## 2、判断搜索二叉树\n利用中序遍历的特点（左中右），如果为是搜索二叉树，则中序遍历是逐渐增大的。\n\n>分为递归和非递归方式\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(8);\n        head.left=new Node(3);\n        head.right=new Node(10);\n        head.left.left=new Node(1);\n        head.left.right=new Node(6);\n        head.left.right.left=new Node(4);\n        head.left.right.right=new Node(7);\n        head.right.right=new Node(14);\n        head.right.right.left=new Node(13);\n        System.out.print(\"递归方式： \");\n        System.out.println(checkBST(head)?\"是一颗搜索二叉树\":\"不是一颗搜索二叉树\");\n        System.out.print(\"非递归方式： \");\n        System.out.println(checkBST2(head)?\"是一颗搜索二叉树\":\"不是一颗搜索二叉树\");\n    }\n\n    public static class Node{\n        public int value;\n        public Node left;\n        public Node right;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    public static int preValue=Integer.MIN_VALUE;\n\n    //递归 判断是否为搜索二叉树\n    public static Boolean checkBST(Node head){\n        if (head==null){\n            return true;\n        }\n        boolean isLeftBst=checkBST(head.left);\n        if (!isLeftBst){\n            return false;\n        }\n        if (head.value<=preValue){\n            return false;\n        }else {\n            preValue= head.value;\n        }\n        return checkBST(head.right);\n    }\n\n    //非递归\n    public static int preValue2=Integer.MIN_VALUE;\n    public static Boolean checkBST2(Node head){\n        if (head!=null){\n            Stack<Node>stack=new Stack<Node>();\n            while (!stack.isEmpty() || head != null){\n                if (head!=null){// 把左边界都入栈\n                    stack.push(head);\n                    head=head.left;\n                }else {// 依次弹节点并跳到右结点\n                    head=stack.pop();\n                    if (head.value<=preValue2){\n                        return false;\n                    }else {\n                        preValue2= head.value;\n                    }\n                    head=head.right;\n                }\n            }\n        }\n       return true;\n    }\n```\n\n> 运行结果：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8fa6e7de492b4ea2beca81132842e6f3.png)\n\n\n---\n  >套路递归：\n  >每一颗子树都应该满足：**左子树<父节点<右子树**\n\n>构建信息体：\n\n```java\n public static class ReturnData{// 信息体\n        public boolean isBST;\n        public int min;\n        public int max;\n\n        public ReturnData(boolean is,int min,int max){\n            this.isBST=is;\n            this.min=min;\n            this.max=max;\n        }\n    }\n```\n>加工信息：\n\n```java\npublic static ReturnData process(Node x){\n        if (x==null){\n            return null;\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n        int min=x.value;\n        int max= x.value;\n        if (leftData!=null){// 左子树中最大和最小\n            min=Math.min(min, leftData.min);\n            max=Math.max(max, leftData.max);\n        }\n        if (rightData!=null){// 右子树中最大和最小\n            min=Math.min(min, rightData.min);\n            max=Math.max(max, rightData.max);\n        }\n\n        boolean isBST=true;\n        // 左子树不为空和（左子树>=父节点 或 左子树不为搜索二叉树）\n        if (leftData!=null && (!leftData.isBST || leftData.max>=x.value)){\n            isBST=false;\n        }\n        // 右子树不为空和（右子树<=父节点 或 右子树不为搜索二叉树）\n        if (rightData!=null && (!rightData.isBST ||x.value>=rightData.min)){\n            isBST=false;\n        }\n        return new ReturnData(isBST,min,max);//最终返回\n    }\n```\n\n# 四、是否为完全二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3f9a09e29a6446b9bff0d49d4650b5f4.png)\n\n## 完全二叉树的两个条件\n 1. 某个节点左孩子为空右孩子不能为空\n 2. 在一的条件下遇到过左右两孩子不双全的节点，当前节点不能有叶子节点\n\n> 代码如下\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(3);\n        head.left.left=new Node(4);\n        head.left.right=new Node(5);\n        head.right.left=new Node(6);\n        head.right.right=new Node(7);\n        head.left.left.left=new Node(8);\n        head.left.left.right=new Node(9);\n        head.left.right.left=new Node(10);\n        head.left.right.right=new Node(11);\n        head.right.left.left=new Node(12);\n        System.out.println(\"是否为完全二叉树： \"+isBCT(head));\n    }\n\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data ){\n            this.value=data;\n        }\n    }\n\n    /*\n      判断是否为完全二叉树需要两个条件\n      1、左孩子为空右孩子不能为空\n      2、在一的条件下遇到过左右两孩子不双全的节点，当前节点不能有叶子节点\n     */\n    public static Boolean isBCT(Node head){\n        if (head==null){\n            return true;\n        }\n        LinkedList<Node>queue=new LinkedList<>();\n        boolean leaf=false;// 是否遇到过左右两个孩子不双全的节点\n        Node l=null;\n        Node r=null;\n        queue.add(head);\n        while (!queue.isEmpty()){\n            head=queue.poll();\n            l=head.left;\n            r=head.right;\n            if(\n                    (leaf && (l != null || r != null))\n                    ||\n                            (l==null && r!=null)\n            ){\n                return false;\n            }\n            if (l!=null){\n                queue.add(l);\n            }\n            if (r!=null){\n                queue.add(r);\n            }\n            if (l==null||r==null){\n                leaf=true;\n            }\n        }\n        return true;\n    }\n```\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d9f014f7e2e45eb98a56086f128163d.png)\n\n# 五、是否为满二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/85e6dac612864a7289c4a6dabc6ca174.png)\n## 满二叉树的条件\n\n >记一棵树最大深度为L，所有节点数为N，满二叉树存在以下关系：\n **N=2^L-1**\n \n>构建信息体，只要知道树的高度和节点个数\n\n```java\n public static class ReturnData{\n        public boolean isF;\n        public int height;\n        public int nodes;\n        public ReturnData(boolean isF ,int height,int nodes){\n            this.height=height;\n            this.nodes=nodes;\n            this.isF=isF;\n        }\n    }\n```\n\n>信息处理\n\n```java\n//加工信息\n    public static ReturnData process(Node x){\n        if (x==null){\n            return new ReturnData(true,0,0);\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n\n        boolean isF=true;\n        int height=Math.max(leftData.height,rightData.height)+1;\n        int nodes=leftData.nodes+ rightData.nodes+1;\n        // 是否符合 N=2^L-1\n        if (nodes!=Math.pow(2,height)-1){\n            isF=false;\n        }\n        return new ReturnData(isF,height,nodes);\n    }\n}\n```\n\n>完整代码\n\n```java\n public static void main(String[] args) {\n        Node head=new Node(1);\n        head.left=new Node(2);\n        head.right=new Node(3);\n        head.left.left=new Node(4);\n        head.left.right=new Node(5);\n        head.right.left=new Node(6);\n        head.right.right=new Node(7);\n        head.left.left.left=new Node(8);\n        head.left.left.right=new Node(9);\n        head.left.right.left=new Node(10);\n        head.left.right.right=new Node(11);\n        head.right.left.left=new Node(12);\n        head.right.left.right=new Node(13);\n        head.right.right.left=new Node(14);\n        head.right.right.right=new Node(15);\n        System.out.println(\"节点数： \"+process(head).nodes);\n        System.out.println(\"高度： \"+process(head).height);\n        System.out.println(\"是否为满二叉树： \"+process(head).isF);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n\n    /*\n    构建信息体\n     */\n    public static class ReturnData{\n        public boolean isF;\n        public int height;\n        public int nodes;\n        public ReturnData(boolean isF ,int height,int nodes){\n            this.height=height;\n            this.nodes=nodes;\n            this.isF=isF;\n        }\n    }\n\n    //加工信息\n    public static ReturnData process(Node x){\n        if (x==null){\n            return new ReturnData(true,0,0);\n        }\n        ReturnData leftData=process(x.left);\n        ReturnData rightData=process(x.right);\n\n        boolean isF=true;\n        int height=Math.max(leftData.height,rightData.height)+1;\n        int nodes=leftData.nodes+ rightData.nodes+1;\n        // 是否符合 N=2^L-1\n        if (nodes!=Math.pow(2,height)-1){\n            isF=false;\n        }\n        return new ReturnData(isF,height,nodes);\n    }\n```\n\n# 六、是否为平衡二叉树\n## 平衡二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/989fe7c9037d492db12bb38368924acb.png =300x300)\n\n>对任何一个子树来说，左数和右树的高度差不超过1。\n\n 1. 左子树为平衡二叉树\n 2. 右子树为平衡二叉树\n 3. |左子树高度-右子树高度|<=1\n \n\n```java\n public static ReturnType process(Node x){\n        if (x==null){\n            return new ReturnType(true,0);\n        }\n        // 递归左右子树返回信息\n        ReturnType leftData=process(x.left);\n        ReturnType rightData=process(x.right);\n\n        // 整颗树高度\n        int height=Math.max(leftData.height, rightData.height)+1;\n        // 三个条件判断\n        boolean isBalanced= leftData.isBalanced && rightData.isBalanced\n                && Math.abs(leftData.height- rightData.height)<2;\n\n        return new ReturnType(isBalanced,height);//最终返回总的\n    }\n```\n\n---\n>在递归结构中左子树和右子树需要的信息都为高度和是否平衡：\n\n```java\npublic static class ReturnType{ // 子树信息结构体\n        public boolean isBalanced;// 是否平衡\n        public int height;// 树高度\n        public ReturnType(boolean isB,int height){// 构造函数\n            this.isBalanced=isB;\n            this.height=height;\n        }\n    }\n```\n\n>完整代码：\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(5);\n        head.left=new Node(3);\n        head.right=new Node(7);\n        head.left.left=new Node(2);\n        head.left.right=new Node(4);\n        head.right.left=new Node(6);\n        System.out.println(\"树高为：\"+isBalanced(head).height);\n        System.out.println(\"是否为平衡二叉树：\"+isBalanced(head).isBalanced);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public int value;\n\n        public Node(int data){\n            this.value=data;\n        }\n    }\n\n    public static ReturnType isBalanced(Node  head){// 主函数\n        return process(head);\n    }\n    public static class ReturnType{ // 子树信息结构体\n        public boolean isBalanced;// 是否平衡\n        public int height;// 树高度\n        public ReturnType(boolean isB,int height){// 构造函数\n            this.isBalanced=isB;\n            this.height=height;\n        }\n    }\n    public static ReturnType process(Node x){\n        if (x==null){\n            return new ReturnType(true,0);\n        }\n        ReturnType leftData=process(x.left);\n        ReturnType rightData=process(x.right);\n\n        int height=Math.max(leftData.height, rightData.height)+1;\n        boolean isBalanced= leftData.isBalanced && rightData.isBalanced\n                && Math.abs(leftData.height- rightData.height)<2;\n\n        return new ReturnType(isBalanced,height);\n    }\n```\n\n>运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a54e916bd034bad90c77ec428e10dc7.png)\n# 七、二叉树题目应用\n## 1、最低公共祖先节点\n>题目描述：\n>给定两个二叉树的节点node1和node2,找到他们最低公共祖先节点\n>如图G和F节点的最低公共祖先节点为C，E和G的 最低公共祖先为E。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n\n\n>解题思路：\n>理解版：\n>将其中一个节点往上回溯的其余节点和他本身放到一个集合中，如F节点往上回溯将A、C、F三个节点放入集合中，再将另一个节点往上回溯，每次回溯都去第一个集合查询是否存在该节点，没有就往上回溯，直到第一个出现在第一集合中的节点就是最低公共祖父节点，如G节点往上回溯，发现G、E不存在，最终找到C，C就是该最低祖父节点。\n\n>储存关系集合：\n\n```java\n //迭代将整个树关系储存\n    public static void process(Node head, HashMap<Node,Node>fatherMap){\n        if (head==null){\n            return;\n        }\n        fatherMap.put(head.left,head);\n        fatherMap.put(head.right,head);\n\n        process(head.left,fatherMap);\n        process(head.right,fatherMap);\n    }\n\n```\n\n>回溯查找：\n\n```java\npublic static Node lca(Node head,Node o1,Node o2){\n        HashMap<Node,Node>fatherMap=new HashMap<>();\n        fatherMap.put(head,head);\n        process(head,fatherMap);//储存整棵树各个节点的回溯关系\n        HashSet<Node>set1=new HashSet<>();\n        HashSet<Node>set2=new HashSet<>();\n\n        Node cur=o1;\n        while (cur!=fatherMap.get(cur)){//第一个节点回溯添加\n            set1.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        set1.add(head);// 将头节点添加\n\n        cur=o2;\n        while (cur!=fatherMap.get(cur)){//第二个节点回溯添加\n            set2.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        for (Node node1:set2){\n            for (Node node2 : set1) {\n                if (node1==node2){\n                    return node2;\n                }\n            }\n        }\n```\n\n>**简易版:**\n>  1、当o1是 o2的最低公共祖先或当o2是 o1的最低公共祖先\n        2、o1和o2不互为公共祖先，必须向上回溯才能找到\n\n```java\npublic static Node lca2(Node head,Node o1,Node o2){\n        if (head==null || head==o1 || head==o2){\n            return head;\n        }\n        //以头节点分成左右两个树\n        Node left=lca2(head.left, o1, o2);//左树返回\n        Node right=lca2(head.right, o1, o2);//右树返回\n        if (left!=null && right!=null){// 条件二判断\n            return head;\n        }\n        //左右两棵树，并不都有返回值（条件一）\n        return left!=null ? left:right;\n    }\n```\n\n>完整代码：\n\n```java\n public static void main(String[] args) {\n        Node head=new Node(\"A\");\n        head.left=new Node(\"B\");\n        head.right=new Node(\"C\");\n        head.left.left=new Node(\"D\");\n        head.right.left=new Node(\"E\");\n        head.right.right=new Node(\"F\");\n        head.right.left.left=new Node(\"G\");\n        System.out.println(\"理解版最低祖父公共节点为：\"+lca(head,head.right.left.left,head.right.right).value);\n        System.out.println(\"简洁版最低祖父公共节点为：\"+lca2(head,head.right.left.left,head.right.right).value);\n    }\n    public static class Node{\n        public Node left;\n        public Node right;\n        public String value;\n\n        public Node(String data){\n            this.value=data;\n        }\n    }\n\n    /*\n    易理解版\n     */\n    public static Node lca(Node head,Node o1,Node o2){\n        HashMap<Node,Node>fatherMap=new HashMap<>();\n        fatherMap.put(head,head);\n        process(head,fatherMap);//储存整棵树各个节点的回溯关系\n        HashSet<Node>set1=new HashSet<>();\n        HashSet<Node>set2=new HashSet<>();\n\n        Node cur=o1;\n        while (cur!=fatherMap.get(cur)){//第一个节点回溯添加\n            set1.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        set1.add(head);// 将头节点添加\n\n        cur=o2;\n        while (cur!=fatherMap.get(cur)){//第二个节点回溯添加\n            set2.add(cur);\n            cur=fatherMap.get(cur);\n        }\n        for (Node node1:set2){\n            for (Node node2 : set1) {\n                if (node1==node2){\n                    return node2;\n                }\n            }\n        }\n\n        return head;\n    }\n    //迭代将整个树关系储存\n    public static void process(Node head, HashMap<Node,Node>fatherMap){\n        if (head==null){\n            return;\n        }\n        fatherMap.put(head.left,head);\n        fatherMap.put(head.right,head);\n\n        process(head.left,fatherMap);\n        process(head.right,fatherMap);\n    }\n\n\n    /*\n    简洁版：\n        1、当o1是 o2的最低公共祖先或当o2是 o1的最低公共祖先\n        2、o1和o2不互为公共祖先，必须向上回溯才能找到\n     */\n    public static Node lca2(Node head,Node o1,Node o2){\n        if (head==null || head==o1 || head==o2){\n            return head;\n        }\n        //以头节点分成左右两个树\n        Node left=lca2(head.left, o1, o2);//左树返回\n        Node right=lca2(head.right, o1, o2);//右树返回\n        if (left!=null && right!=null){// 条件二判断\n            return head;\n        }\n        //左右两棵树，并不都有返回值（条件一）\n        return left!=null ? left:right;\n    }\n```\n>运行结果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9aa2ac8ab7d04832b63d393c5805fbce.png)\n\n## 2、后继节点\n>题目描述：\n>不通过中序遍历找到某个节点的后继（前继）节点\n>`后继节点就是中序遍历的当前节点的后一个节点，前继相反`\n>如图二叉树中序遍历为：D->B->A->G->E->C->F\n>则B的后继为A，前继为D\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n\n>解题思路：\n\n>后继：\n >1. 当需要找的节点有右子树时，他的后继就是右子树的最左子树（没有最左时就是本身）\n > 2. 当需要找的节点有右子树时，向上寻找节点，直到找到某个节点是该节点头节点的左子树时，该节点的头就是后继\n\n>根据情况一向左一直找最左子树\n\n```java\n // 向左寻找最左子树\n    public static Node getLeftMost(Node node){\n        if (node==null){\n            return null;\n        }\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n```\n\n>根据情况二找\n\n```java\n Node parent=node.parent;\n            while (parent!=null && parent.left!=node){//当前节点是其父亲节点右孩子 情况二\n                node=parent; //往上移动\n                parent=node.parent;\n            }\n            return parent;\n```\n\n>完整代码\n\n```java\npublic static void main(String[] args) {\n        Node head=new Node(\"A\");\n        head.left=new Node(\"B\");\n        head.right=new Node(\"C\");\n        head.left.left=new Node(\"D\");\n        head.right.left=new Node(\"E\");\n        head.right.right=new Node(\"F\");\n        head.right.left.left=new Node(\"G\");\n        head.parent=null;\n        head.left.parent=head;\n        head.right.parent=head;\n        head.left.left.parent=head.left;\n        head.right.left.parent=head.right;\n        head.right.right.parent=head.right;\n        head.right.left.left.parent=head.right.left;\n        System.out.println(\"G节点的后继为：\"+getSuccessorNode(head.right.left.left).value);\n    }\n    public static class Node{\n        public String value;\n        public Node left;\n        public Node right;\n        public Node parent;// 指向自己的父节点\n        public Node(String value){\n            this.value=value;\n        }\n    }\n    public static Node getSuccessorNode(Node node){\n        if (node==null){\n            return null;\n        }\n        if (node.right!=null){//情况一\n            return getLeftMost(node.right);\n        }else {//无右子树\n            Node parent=node.parent;\n            while (parent!=null && parent.left!=node){//当前节点是其父亲节点右孩子 情况二\n                node=parent; //往上移动\n                parent=node.parent;\n            }\n            return parent;\n        }\n    }\n    // 向左寻找最左子树\n    public static Node getLeftMost(Node node){\n        if (node==null){\n            return null;\n        }\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n```\n\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c183681319254d358d5bb6a8a3224473.png)\n## 3、二叉树的序列化与反序列化\n>题目描述：\n>从字符串到内存结构的转换叫反序列化，从内存结构到字符串的转换叫序列化\n>以‘#’表示null，节点之间用'_'隔开\n>如图所示二叉树的先序为：A_B_D_C_E_G_F\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f7c0105c82bc4bee8caa47fb16decd26.png =300x300)\n### （1）二叉树的序列化\n\n```java\n public static String serialByPre(Node head){\n        if (head==null){\n            return \"#_\";\n        }\n        String res=head.value+\"_\";\n        res+=serialByPre(head.left);\n        res+=serialByPre(head.right);\n        return res;\n    }\n```\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d29624b16513492997b1126ba55ca39e.png)\n\n### （1）二叉树的反序列化\n\n```java\n//反序列化主函数\n    public static Node reconByPreString(String preStr){\n        String[]values=preStr.split(\"_\");\n        Queue<String> queue = new LinkedList<String>(Arrays.asList(values));//将每一项复制给队列\n        return reconPreOrder(queue);\n    }\n    //反序列化处理\n    public static Node reconPreOrder(Queue<String>queue){\n        String value=queue.poll();\n        if (Objects.equals(value, \"#\")){\n            return null;\n        }\n        Node head=new Node(value);\n        head.left=reconPreOrder(queue);//左树反序列\n        head.right=reconPreOrder(queue);//右树反序列\n        return head;\n    }\n```\n## 4、折纸条问题\n>问题描述：\n>一个纸条向自己的方向向上折N次，依次打印折痕方向（折痕向外为‘凹’，向内为‘凸’）。\n>\n>如折一次时，纸条的折痕为‘凹’；折两次时，折痕为‘凹凹凸’；三次时，折痕为‘凹凹凸凹凹凸凸’。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e99ffb2d6da4b91b3ffdb5dc46f9c7e.png)\n\n\n\n>解题思路：\n>经过模拟发现折痕是一颗总头节点为‘凹’ 左子树为‘凹’，右子树为‘凸’的满树，如果打印折痕就是将这棵树中序遍历。\n\n>代码实现\n\n```java\npublic static void main(String[] args) {\n        int N=3;\n        printAllFolds(N);\n    }\n    public static void printAllFolds(int N){\n        printProcess(1,N,true);\n    }\n    /*\n       i为节点层数\n       N为共几层\n       down == true 凹\n       down == false 凸\n     */\n\n    public static void printProcess(int i,int N,boolean down){\n        if (i>N){// 超过就返回\n            return;\n        }\n        //中序遍历\n        printProcess(i+1,N,true);\n        System.out.println(down?\"凹\":\"凸\");\n        printProcess(i+1,N,false);\n    }\n```\n\n>运行结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cc2e0bb98867458dac22165e5cedea55.png)\n\n# 总结\n\n\n本文简单介绍了二叉树的三种遍历，以及相关二叉树的识别以及一些二叉树的应用题。\n\n","tags":["数据结构","二叉树","二叉树遍历","搜索二叉树"],"categories":["数据结构和算法","二叉树"]},{"title":"桶排序及其应用","url":"/2022/09/12/桶排及稳定性汇总/","content":"\n\n---\n\n# 前言\n\n桶排序及其应用\n\n---\n\n\n\n# 一、桶排序流程\n\n相比其它排序，桶排序不基于比较的排序，根据数据状况来排序。应用范围不是很广。\n##  （1）计数排序\n定义一个数组，用来记录每个数出现的次数，数组下标就是值，然后根据排序规则，分别输出每种数的个数。最终就得到有序数组。\n\n>代码如下：\n\n```java\npublic class countSort {\n    public static void main(String[] args) {\n        int []arr={21,1,8,15,15,15,1,1,2,2,3,4,4,4,4};\n        System.out.println(\"排序前:\"+Arrays.toString(arr));\n        countSort(arr);\n        System.out.println(\"排序后:\"+Arrays.toString(arr));\n    }\n    public static void countSort(int[]arr){\n        int max=maxNum(arr);// 最大数\n        int[]help=new int[max+1];// 创建出最大数长度的辅助数组\n        for (int i=0;i<arr.length;i++){\n            help[arr[i]]+=1;// 计数\n        }\n        System.out.println(\"桶子：\"+Arrays.toString(help));\n        int temp=0;\n        for (int j=0;j<help.length;j++){// 出桶\n            if (help[j]!=0){\n                for (int d=0;d<help[j];d++){\n                    arr[temp++]=j;\n                }\n            }\n        }\n    }\n    // 找最大数\n    public static int maxNum(int []arr){\n        int max=0;\n        for (int i:arr){\n            max=Math.max(max,i);\n        }\n        return max;\n    }\n}\n\n\n```\n\n>时间复杂度：O（N）\n>结果如下：\n![!\\[在这里插入图片描述\\](https://img-blog.csdnimg.cn/2ebd86fbfe2e4e97b0bcda10696f326d.png](https://img-blog.csdnimg.cn/de45363093ec4a3c908d058a94d52b8b.png)\n\n\n## （2）基数排序\n准备十个桶，分别对应数字0~9，桶就是个容器，可以是队列，数组，栈等...,最开始将所有数按最多位的数以0补齐位数（【34，789，444】补全为：【034，789，444】），从个位数将数放入对应桶中（034就放入4号桶，789就放入9号桶），然后依次从0 ~ 9号桶的顺序取出一个桶里的遵循先进先出。然后从十位重复，最后到最高位，出桶后就得到有序数组。（优先级是从最高位开始依次递减）。\n>代码如下：\n\n```java\npublic class radixSort {\n    public static void main(String[] args) {\n        int []arr={63,21,80,91,23,42,444,382,45};\n        System.out.println(\"排序前:\"+ Arrays.toString(arr));\n        radixSort(arr);\n        System.out.println(\"排序后:\"+Arrays.toString(arr));\n    }\n    public static void radixSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        radixSort(arr,0,arr.length-1,maxbits(arr));\n    }\n    public static void radixSort(int []arr,int L,int R,int maxBit){\n        final int radix=10;// 10个桶子\n        int i=0,j=0;// j=>当前数的第几位\n        int []bucket=new int[R-L+1];// 辅助数组\n        for (int d=1;d<=maxBit;d++){ // 有多少位就进多少次\n            // 桶子共有maxBit个\n            // 桶子的计数与流程有差别，桶子计数的为小于等于当前下标的个数之和\n            // （第6个桶子是【0，1，2，3，4，5，6，7】的数字的总和）\n            int []count =new int [radix];\n            for (i=L;i<=R;i++){// 取出当前位的数字 入桶\n                j=getDigit(arr[i],d);\n                count[j]++;\n            }\n            for (i=1;i<radix;i++){// 桶子的累加和\n                count[i]=count[i]+count[i-1];\n            }\n            for (i=R;i>=L;i--){// 从右到左遍历，取出对应位 桶中对应数--，摆放位置 出桶\n                j=getDigit(arr[i],d);\n                bucket[count[j]-1]=arr[i];\n                count[j]--;\n            }\n            for (i=L,j=0;i<=R;i++,j++){// 将辅助数中的值给arr准备下一次进桶出桶\n                arr[i]=bucket[j];\n            }\n        }\n    }\n    // 取出一个数中的第d位数字\n    public static int getDigit(int x,int d){\n        return ((x/(int)(Math.pow(10,d-1)))%10);\n    }\n    // 找一个数组内最多有多少位\n    public static int maxbits(int []arr){\n        int max=Integer.MIN_VALUE;\n        for (int j : arr) {// 找出最大值\n            max = Math.max(max, j);\n        }\n        int res=0;\n        while (max!=0){// 循环计位数\n            res++;\n            max/=10;\n        }\n        return res;\n    }\n}\n```\n\n>结果如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/564462c2843a44c7b67e7edd0014bcc3.png)\n\n\n# 二、排序算法的稳定性及其汇总\n## 稳定性\n  ****同样的个体间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。****\n\n 1. 不具备稳定性的排序：\n- 选择排序\n- 快速排序\n- 堆排序\n2. 具备稳定性的排序：\n- 冒泡排序\n- 插入排序\n- 归并排序\n- 一切桶排序思想下的排序\n\n目前按没有找到时间复杂度O(N*logN),空间复杂度O(1)又稳定的排序算法。\n\n|  | 时间复杂度 |额外空间复杂度|稳定性|\n|--|--|--|--|\n| 选择 | O(N^2) |O(1)|×|\n| 冒泡 | O(N^2) |O(1)|√|\n| 插入 | O(N^2) |O(1)|√|\n|归并  | O(N*logN) |O(N)|√|\n| 快排（随机） | O(N*logN) |O(logN)|×|\n| 堆 |O(N*logN)  |O(1)|×|\n\n\n## 坑\n\n - 归并排序的额外空间复杂度可以变成O（1）但会丧失稳定性，而且非常难（归并排序，内部缓存法）\n - 原地归并排序，让时间复杂度变成O（N^2）\n - 快速排序可以做到稳定，但空间复杂度会变为O(N)，而且非常难\n - 目前没有找到时间复杂度O(N*logN),额外空间按复杂度O(1)，又稳定的排序。\n - 奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变。\n\n## 工程上堆排序的改进\n- 充分利用O(N*logN)和O（N^2）排序各自优势\n在快排中，当样本容量小于60时使用插入排序更快（综合排序）\n\n\n- 稳定性考虑\n在系统中使用排序，基础类型，系统会使用快排进行排序；而遇到非基础类型排序时，会使用归并保持稳定性。\n# 总结\n以上就是桶排序的所有内容。\n","tags":["算法","数据结构","排序算法","桶排序"],"categories":["算法","数据结构和算法"]},{"title":"堆结构、堆排序及其应用","url":"/2022/09/12/堆及堆排序应用/","content":"\n\n\n---\n\n# 前言\n\n堆结构、堆排序及其应用\n\n---\n\n\n\n# 一、堆结构\n堆结构是一个数组对象，就是一颗特殊的完全二叉树或是一颗特殊的满二叉树。\n堆分为**大根堆**和**小根堆**。\n>满二叉树：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7d670002d9db47fe8e6563d0e8608858.png)\n\n>完全二叉树：（）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7ba20f01e1e04dcbb0d55d292d5060c6.png)\n\n---\n\n**某个节点i**\n- 左孩子节点下标索引：i*2+1\n- 右孩子节点下标索引：i*2+2\n- 父节点下标索引：(i-1)/2\n---\n\n## 1、大根堆\n每一棵子树的最大值为头节点的值，就为大根堆\n\n>如下\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/210abc6dad0c43d9998868581c19b4c6.png)\n### （1）向上调整（heapInsert）\n调整某个位置能否往上移动\n\n>代码如下：\n\n```java\n// 某个数在index位置能否往上移动\n    public static void heapInsert(int[]arr,int index){\n        while(arr[index]>arr[(index-1)/2]){\n            swap(arr,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n```\n\n### （2）向下调整（heapify）\n某个位置能否往下移动。\n返回最大值并移除：最大值就是第一个值，用最后边那个数代替头节点，整体堆长度减小一，此时需要对这个头节点进行调整，在子孩子中找到最大的再与头节点比较，如果头节点小于子孩子就交换位置，以此类推当子孩子不大于头结点或者没有子孩子时，停止，此时为大根堆。\n>调整代价为：O（logN）\n\n>代码如下：\n\n```java\n    // 某个数在Index位置，能否往下移动\n    public static void heapify(int[]arr,int index,int heapSize){\n        int left=index*2+1; // 左孩子下标\n        while (left<heapSize){ // 如果当前位置有子节点\n            //将两个子孩子大的下标记录\n            int largest=left+1<heapSize && arr[left+1]>arr[left]?left+1:left;\n            //比较父和子哪个值大，值大的记录\n            largest=arr[largest]>arr[index]?largest:index;\n            if (largest==index){ // 符合跳出循环\n                break;\n            }\n            swap(arr,index,largest);\n            index=largest;\n            left=index*2+1;\n        }\n    }\n```\n### （3）合并应用\n当改变其中某个值，可以分别使用向下调整和向上调整，调整过后得到大根堆。\n\n>调整代价为：O（logN）\n## 2、小根堆\n每一棵子树的最小值为头节点的值，就为小根堆,和大根堆刚好相反。\n>如下\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b7c4ead0562f4d8ca1744e25f7b4a826.png)\n\n\n\n# 二、堆排序\n## 1.过程\n不断的从0~1，0 ~2....做到大根堆或小根堆，heapSize为堆长度，每一次新进来个数heapSize++，最终得到堆，然后将最大的与最后一个位置交换，heapSize--，就将最大位置排在了最后并剔除了堆，利用向下调整得到堆，再重复上述步骤，最终heapSize为0时，这个数组就有序了。\n>时间复杂度为：O（NlogN）\n>额外空间复杂度为：O（1）\n\n>代码如下：\n\n```java\npublic class bigRootPile {\n\n    public static void main(String[] args) {\n        int []arr={2,4,5,1,8,2,9,4,3,6};\n        heapSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void heapSort(int[]arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        // O(NlogN)\n        // 可优化\n        for (int i=0;i<arr.length;i++){\n            heapInsert(arr,i);\n        }\n        int heapSize=arr.length;\n        swap(arr,0,--heapSize);\n        while (heapSize>0){\n            heapify(arr,0,heapSize);// O(logN)\n            swap(arr,0,--heapSize);//O(1)\n        }\n    }\n    // 某个数在index位置能否往上移动\n    public static void heapInsert(int[]arr,int index){\n        while(arr[index]>arr[(index-1)/2]){\n            swap(arr,index,(index-1)/2);\n            index=(index-1)/2;\n        }\n    }\n    // 某个数在Index位置，能否往下移动\n    public static void heapify(int[]arr,int index,int heapSize){\n        int left=index*2+1; // 左孩子下标\n        while (left<heapSize){ // 如果当前位置有子节点\n            //将两个子孩子大的下标记录\n            int largest=left+1<heapSize && arr[left+1]>arr[left]?left+1:left;\n            //比较父和子哪个值大，值大的记录\n            largest=arr[largest]>arr[index]?largest:index;\n            if (largest==index){ // 符合跳出循环\n                break;\n            }\n            swap(arr,index,largest);\n            index=largest;\n            left=index*2+1;\n        }\n    }\n    // 交换\n    public static void swap(int[]arr,int index,int fIndex){\n        int temp=arr[index];\n        arr[index]=arr[fIndex];\n        arr[fIndex]=temp;\n    }\n}\n\n```\n>结果如下：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/08f94a79e9034ea6b336895a7d4da8ff.png)\n\n`只让一个不为大根堆的变为大根堆可以将以下代码优化`\n\n```java\n for (int i=0;i<arr.length;i++){\n            heapInsert(arr,i);\n        }\n```\n>优化后：\n\n```java\n  for (int i=arr.length-1;i>=0;i--){\n            heapify(arr,i,arr.length);\n        }\n```\n在最后一个数往下调整，做到依次局部大根堆，最终得到大根堆。\n\n# 三、堆排序扩展\n`如果做到高效的进行堆结构的调整，就必须自己手写，而不用系统自带的堆结构，因为系统自带的堆结构在调整时，是从头开始扫描调整`\n\n>**JAVA**中的堆结构：(默认为小根堆)\n>PraiorityQyueue<Integer>heap=new PriorityQueue<>();\n\n## （1）几乎有序数组排序\n已知一个几乎有序数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对则个数据进行排序。\n> 时间复杂度：O（NlogK）\n> 代码如下：\n\n```java\npublic class almostOrdinal {\n    public static void main(String[] args) {\n        int k=2;\n        int []arr={2,8,6,4,14,12,16,16,18};\n        System.out.println(\"排序前：\"+Arrays.toString(arr));\n        almostOrderedSort(arr,k);\n        System.out.println(\"排序后：\"+Arrays.toString(arr));\n    }\n    public static void almostOrderedSort(int[]arr,int k){\n        PriorityQueue<Integer>heap=new PriorityQueue<>();\n        int index=0;\n        for (;index<=Math.min(arr.length,k);index++){// 把前k+1个数放入小根堆（如果k大于数组长度则把整个数组放入）\n            heap.add(arr[index]);\n        }\n        int i=0;\n        for (;index<arr.length;index++){\n            heap.add(arr[index]);// 新加后一位数放到小根堆中\n            arr[i++]= heap.poll();//小根堆弹出最小的数放到i位置\n        }\n        while (!heap.isEmpty()){// 如果没有可加的新数字 依次弹出就行\n            arr[i++]= heap.poll();\n        }\n    }\n}\n```\n\n> 结果如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a0c97ec4ae0241ccab0e030a94dd0cdd.png)\n\n# 四、比较器\n自己定义比较策略的类，实质就是重载比较运算符。\n\n# 总结\n\n以上文章主要讲了堆（大根堆、小根堆）和堆排序的思想，以及扩展，和比较器。\n","tags":["算法","数据结构","排序算法","堆结构","堆排序"],"categories":["算法","数据结构和算法"]},{"title":"归并排序，快排变形应用","url":"/2022/09/12/归并排序，快排变形应用/","content":"\n---\n\n# 前言\n\nO(NlogN)的排序\n\n---\n\n\n\n# 一、数组中点防溢出\n在取一个数组的中点时，传统写法为：\n\n- **mid=(min+max)/2**;  这样会发生（mn+max）溢出。\n- **min+(max-min)/2**; 可以改成这样。\n- **mn+（(max-min)>>1）**;也可以这样。\n\n\n\n\n\n# 二、master公式\n## 1.master公式的使用\n**T（N）=a*T（N/b）+O(N^d)**\n其中T（N）表示母问题规模，a表示子问题调用次数，T（N/b）表示子问题规模，O（N^d）表示其它规模。\n`必须在子问题规模一样的情况下`\n时间复杂度\n- logb^a<d  --->O(N ^ d)\n- logb^a>d   ---> O(N ^logb ^a)\n- logb^a==d  ---> O(N ^d *logN)\n  \n \n\n# 归并排序\n## 1.流程\n将数组沿中点分成两部分,分别将左右两部分先排序，然后申请辅助空间，依次比较 左右两边的数，根据规则将较大或较小数copy到辅助空间，将这一侧往后移一位和另一侧不移动的数比较，以此类推，最终一边越界将另一边剩下的直接copy进辅助空间，就得到了有序数组。\n\n>T（N）=2T（N/2）+O（N）\n>归并排序的时间复杂度为：O（NlogN）\n>额外空间复杂度为：O（N）\n> 代码如下\n\n```java\npublic class mergeSort {\n    public static void process(int []arr,int L,int R){ // 递归\n        if (L==R){\n            return;\n        }\n        int mid=L+((R-L)>>1);// 取中点\n        // 两次递归\n        process(arr,L,mid);\n        process(arr,mid+1,R);\n        merge(arr,L,mid,R);\n    }\n    public static void merge(int []arr,int L,int M,int R){// 比较\n        int[] help=new int[R-L+1];// 辅助空间\n        int i=0;\n        int p1=L; // 左指针\n        int p2=M+1; // 右指针\n        // O（N）\n        while (p1 <= M && p2 <= R){// 比较\n           help[i++]= arr[p1]<=arr[p2]?arr[p1++]: arr[p2++];\n        }\n        // 最终\n        while (p1<=M){\n            help[i++]=arr[p1++];\n        }\n        while (p2<=R){\n            help[i++]=arr[p2++];\n        }\n        // O（N）\n        for (int j=0;j<help.length;j++){\n            arr[L+j]=help[j];\n        }\n    }\n}\n```\n---\n## 2.归并排序拓展\n### （1）求小和问题\n>描述：在一个数组中，每一个数左边比当前的数大累加起来，叫做这个数组的小和。求一个数组的小和。\n例如：\n[1,3,4,2,5],1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、4、2；所以小和为1+1+3+1+1+3+4+2=16。\n\n>思路：转换问题，将求左边比当前数小改为求右边比当前数大的个数，再与该数相乘，最后相加得到小和。\n>例如：\n>1右边比1大的数有4个，就是1*4；3右边比3大的有2个，就是3*2；4右边比4大的有1个，就是4*1；2右边比2大的有1个，就是2*1；5右边没有比5大的数；所以小和为1*4+3*2+4*1+2*1=16。\n\n>利用归并找到小和，在左右两边都排序后，只要左边比右边的小，就要进行小和的累加，当相同时，先复制右边的，这样能更快找完但个数的小和。\n\n```java\npublic class smallSumProblem {\n    public static int process(int []arr, int L, int R){ // 递归\n        if (L==R){\n            return 0;\n        }\n        int mid=L+((R-L)>>1);\n        return process(arr,L,mid) +process(arr,mid+1,R)+merge(arr,L,mid,R); //总小和\n    }\n    public static int merge(int []arr,int L,int M,int R){// 比较\n        int[] help=new int[R-L+1];// 辅助空间\n        int i=0;\n        int p1=L; // 左指针\n        int p2=M+1; // 右指针\n        int res =0;\n        while (p1 <= M && p2 <= R){// 比较 求小和\n            res+=arr[p1]<arr[p2]?(R-p2+1)*arr[p1]:0; // 左边小于右边时，计算小和数\n            help[i++]= arr[p1]<arr[p2]?arr[p1++]: arr[p2++];// 左右两边相等时先拷贝右边的\n        }\n        // 最终\n        while (p1<=M){\n            help[i++]=arr[p1++];\n        }\n        while (p2<=R){\n            help[i++]=arr[p2++];\n        }\n        for (int j=0;j<help.length;j++){\n            arr[L+j]=help[j];\n        }\n        return res;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/4ce416eaf43949438852cdefc3d76419.png)\n\n### （2）逆序对问题\n>描述：在一个数组中，左边的数如果比右边大，则这两个数构成一个逆序对，请打印所有逆序对。\n---\n\n```java\npublic class reversePairProblem {\n    public static void main(String[] args) {\n        int[] arr = {5, 3, 4, 2, 1};\n        process(arr, 0, 4);\n    }\n\n    public static void process(int[] arr, int L, int R) { // 递归\n        if (L == R) {\n            return;\n        }\n        int mid = L + ((R - L) >> 1);\n         process(arr, L, mid);\n         process(arr, mid + 1, R);\n         merge(arr,L,mid,R);\n    }\n    public static void merge(int[] arr, int L, int M, int R) {// 比较\n        int p1 = L; // 左指针\n        int p2 = M + 1; // 右指针\n        while (p1 <= M && p2 <= R) {// 比较\n            if (arr[p1]>arr[p2]){\n                System.out.println(\"[\"+arr[p1]+\",\"+arr[p2]+\"]\");\n                p1++;\n            }else {\n                p2++;\n            }\n\n        }\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/59e2a6119b6b48c69281d8724ff9d01e.png)\n\n## 3.荷兰国旗问题\n### （1）荷兰国旗问题一\n>描述：\n>给定一个数组arr，和一个数num，请把小于等于num的数放在数组左边，大于num的数放在数组的右边，要求额外空间复杂度O(1)，时间复杂度O（N）。\n\n>思路：\n>他并不要求有序，值啊要将小于等于num的数放左边，大于num的数放右边就可以。先规定一个小于等于num的区域area，area起始是arr第一个数的左边，让指针i指向arr第一个数，让arr[i]与num比较，如果比num小或等，就让i+1，让area往右边扩一位，将arr[i]包含其中；如果arr[i]大于num时，i+1,area不变，接着比较下一位，知道有一位比num小时，交换这一位和area下一位数的位置，再将area往下扩一位，以此类推。\n\n```java\npublic class dutchFlagQuestionOne {\n    public static void main(String[] args) {\n        int []arr={3,8,5,3,8,1,2,9,7};\n        int num=5;\n        hollandOne(arr,num);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void hollandOne(int []arr,int num){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        partition(arr,num,0, arr.length-1);\n    }\n    public static void partition(int []arr,int num,int L,int R){\n        int less=L-1;\n        int more=R+1;\n        while (L<more){\n            if (arr[L]<=num){\n                swap(arr,++less,L++);\n            }else {\n                swap(arr,--more,L);\n            }\n        }\n    }\n    //交换方法\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/a75e03cdeb3741b7a111f22f9db649dc.png)\n\n### （2）荷兰国旗问题二\n>描述：\n给定一个数组arr，和一个数num，请把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组的右边，要求额外空间复杂度O(1)，时间复杂度O（N）。\n\n> 思路:\n> 和上一个差不多，只不过多了一个等于的区域\n>  - [i]<num,[i]和小于区下一位交换，小于区右扩一位，i++\n>  -   [i]=num，i++\n>  -  [i]>num,[i]和大于区前一位交换，大于区左扩一位，i不变\n\n```java\npublic class dutchFlagQuestionOne {\n    public static void main(String[] args) {\n        int []arr={3,8,5,3,8,1,2,9,7};\n        int num=5;\n        hollandOne(arr,num);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void hollandOne(int []arr,int num){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        partition(arr,num,0, arr.length-1);\n    }\n    public static void partition(int []arr,int num,int L,int R){\n        int less=L-1;\n        int more=R+1;\n        while (L<more){\n            if (arr[L]<=num){\n                swap(arr,++less,L++);\n            }else {\n                swap(arr,--more,L);\n            }\n        }\n    }\n    //交换方法\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/1e965cf11de343cb8e584ed7a2bdc9c5.png)\n\n## 4.快排\n### （1）快排1（荷兰国旗问题一的递归）\n>将最后一个数作为划分数进行判断，先判断第一个数与划分数的大小关系，如果小于等于划分数，与小于区后一位交换，小于区域右扩一位；如果大于划分数，与大于区前一位数交换，大于区左扩一位，返回小于区与大于区的交界值，进行递归，最终必定能得到一个有序数组。\n>时间复杂度为：O（N^2）\n>空间复杂度为：O（logN）\n\n```java\npublic class quickRowOne {\n    public static void main(String[] args) {\n        int []arr={1,9,4,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        quickSort(arr,0,arr.length-1);\n    }\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            int p=partition(arr,L,R);\n            quickSort(arr,0,p-1);\n            quickSort(arr,p,R);\n        }\n    }\n    public static int partition(int []arr,int L,int R){\n        int less=L-1; // 小于等于区右边界\n        int more=R;// 大于区左边界\n       while (L<more){\n           if (arr[L]<=arr[R]){\n               swap(arr,++less,L++);\n           }else swap(arr,--more,L);\n       }\n        swap(arr,more,R);\n       return more;\n    }\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/e3651b96fdc34e3ba46580ab7af5f008.png)\n\n### （2）快排2（荷兰国旗问题二的递归）\n>在一的基础上添加了=的区域，也就是说=区域的那部分在后面就不用递归排序了。\n>时间复杂度为：O（N^2）\n>空间复杂度为：O（logN）\n```java\npublic class quicksortTwo {\n    public static void main(String[] args) {\n        int []arr={1,9,4,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int []arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        quickSort(arr,0,arr.length-1);\n    }\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            int p[]=partition(arr,L,R);\n            quickSort(arr,0,p[0]-1);\n            quickSort(arr,p[1]+1,R);\n        }\n    }\n    public static int[] partition(int []arr,int L,int R){\n        int less=L-1; // 小于等于区右边界\n        int more=R;// 大于区左边界\n        while (L<more){\n            if (arr[L]<arr[R]){\n                swap(arr,++less,L++);\n            }else if (arr[L]>arr[R]){\n                swap(arr,--more,L);\n            }else L++;\n        }\n        swap(arr,more,R);\n        return new int[]{less+1,more};\n    }\n    public static void swap(int []arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/eeff751387c1457993dbdbba754f4e50.png)\n\n### （3）快排3（随机选取数来划分）\n>选取划分数时，在列表中随机选取一个数，并人为的将其放到列表的最后一位。\n>时间复杂度为：O（N*logN）\n>空间复杂度为：O（logN）\n```java\npublic class quickRowThree {\n    public static void main(String[] args) {\n        int []arr={1,9,4,2,5};\n        quickSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n    public static void quickSort(int[]arr){\n       if (arr==null||arr.length<2){\n           return;\n       }\n       quickSort(arr,0,arr.length-1);\n    }\n\n    // 递归排序\n    public static void quickSort(int[]arr,int L,int R){\n        if (L<R){\n            swap(arr,L+(int)(Math.random()*(R-L+1)),R); // 随机范围数，手动交换到最后一位\n            int[]p=partition(arr,L,R);// 用来确定等于区域边界\n            quickSort(arr,L,p[0]-1);// 小于区域\n            quickSort(arr,p[1]+1,R);// 大于区域\n        }\n    }\n\n    public static int[] partition(int[]arr, int L, int R){\n        int less=L-1; // 小于取右边界\n        int more=R;// 大于区左边界\n        while (L<more){\n            // [i]<num,[i]和小于区下一位交换，小于区右扩一位，i++\n            // [i]=num，i++\n            // [i]>num,[i]和大于区前一位交换，大于区左扩一位，i不变\n            if (arr[L]<arr[R]){\n                swap(arr,++less,L++);\n            }else if (arr[L]>arr[R]){\n                swap(arr,--more,L);\n            }else {\n                L++;\n            }\n        }\n        swap(arr,more,R);\n        return new int[]{less+1,more};\n    }\n    public static void swap(int[]arr,int L,int R){\n        int temp=arr[L];\n        arr[L]=arr[R];\n        arr[R]=temp;\n    }\n}\n```\n>结果：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/0f4ca14d34364059bafc3a33d8e0af19.png)\n\n---\n# 总结\n\n上文主要讲了master公式的使用，归并排序以及快排逻辑，以及递归解决问题。\n","tags":["算法","数据结构","排序算法","归并排序","快排排序"],"categories":["算法","数据结构和算法"]},{"title":"复杂度和简单排序算法及位运算的实际问题","url":"/2022/09/12/复杂度和简单排序算法及位运算的实际问题/","content":"# 前言\n数据结构和算法是每个程序员必不可少的一部分，算法培养思维逻辑，而数据结构提供实现思维的载体。\n# 复杂度和简单排序算法\n\n## 复杂度\n### 1.时间复杂度\n是对一个算法流程中发生的常数操作的总结，在总结出的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分为f（N），那么时间复杂度为O（f(N)。\n\n### 2.空间复杂度\n是对一个算法在运行过程中临时占用存储空间大小的一个量度。在常量空间中空间复杂度为S（n）=O(1)，在线新空间和递归空间中空间复杂度都为 S（n）=O(n),在二维空间中空间复杂度为S（n）=O(n*m)。\n## 简单排序算法\n### 1.选择排序算法\n从第一个数开始在其中找到最小的数与其交换位置，一直到最后交换完成，就完成了排序\n```java\n//选择排序\n    public static void selectionSort(int[] arr){\n        //长度不足2的都直接返回\n        if (arr==null||arr.length<2){\n            return;\n        }\n        for (int i=0;i<arr.length-1;i++){\n            int minIndex=i;\n            //找到最小值的下标和值\n            for (int j=i+1;j<arr.length;j++){\n                minIndex=arr[j]<arr[minIndex]?j:minIndex;\n            }\n            //交换位置\n            swap(arr,i,minIndex);\n        }\n    }\n    // 交换两个数的位置\n    public static void swap(int[] arr,int i,int j){\n        int tmp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=tmp;\n    }\n```\n\n### 2.冒泡排序算法\n从开始两个数开始谁大（小）往右移动，一轮就确定了一位，以此类推就可以得到一个有序队列。\n\n```java\n public static void bubbleSort(int[]arr){\n        if (arr==null||arr.length<2){\n            return;\n        }\n        for (int i=arr.length-1;i>0;i--){\n            for (int j=0;j<i;j++){\n                if (arr[i]>arr[i+1]){\n                    swap(arr,i,i+1);\n                }\n            }\n        }\n    }\n    //交换函数\n    public static void swap(int[]arr,int i,int j){\n        arr[i]=arr[i]^arr[j];\n        arr[j]=arr[i]^arr[j];\n        arr[i]=arr[i]^arr[j];\n    }\n```\n交换中，异或运算中（无进位相加）\n\n- n^0=n\n- n^n=0\n- a^ b=b^a\n- (a^ b)^c=a ^(b ^ c)\n- 一堆数异或，改变顺序，结果不变\n\n不用其它变量交换两个数\n**a=a ^ b;\nb=a ^ b;\na=a ^ b;**\n`a和b值可以一样但储存的内存地址不能相同`\n\n### 3.插入排序算法\n依次做到从0~1、0 ~2、0 ~3...0 ~n位置上有序，也就是说比较当前位置和前一位置的大小，按照排序要求比较移动（升序就把小的往前挪，降序把大的往前挪），移动完成再和前一个数比较，直到不满足条件则跳到下一组进行排序，到最后一组完成时整个数列就是有序的了。\n`插入排序的时间复杂度，会根据原数组的顺序而发生改变，最坏情况下为O（N^2）最好情况下为O（N）`\n\n```java\n   public static void interpolationSort(int[] arr){\n        if (arr == null||arr.length<2){\n            return;\n        }\n        //0~0已经有序\n        for (int i=1;i<arr.length;i++){//0~i有序\n            for (int j=i-1;j>=0&&arr[j]>arr[j+1];j--){//当前数往前换到不能换或者到第一个位置为止\n                swap(arr,j,j+1);\n            }\n\n        }\n    }\n    public static void swap(int[]arr,int i,int j){\n        arr[i]=arr[i]^arr[j];\n        arr[j]=arr[i]^arr[j];\n        arr[i]=arr[i]^arr[j];\n    }\n```\n\n## 异或问题求解\n### 1.数组中只存在一种数出现了奇数次，其它数出现了偶数次，如何找到这种数？\n因为只有一种数出现了偶数次，根据异或运算规则，偶数次 数异或运算都为0，当到奇数次的数时，最后0 ^ 这个数等于他本身，就找到了。\n```java\npublic static void printOddTimesNum1(int[]arr){\n        int eor=0;\n        for (int cur:arr){\n            eor ^=cur;\n        }\n        System.out.println(eor);\n    }\n```\n### 2.数组中只存在两种数出现了奇数次，其它数出现了偶数次，如何找到这两种数？\n当整个数组异或完后最后等于这两个数的异或，也就是这两个数的异或肯定不等于0，也就是这两个数其中位运算中某一位肯定不相同，提取出两个数异或运算后某一位为1的位置，所有的数在这个位置相同的形成一个集合，这里边一定存在这两种数中的一个，则另一个在另外一边，再将一边的数进行异或，由于只有那种数是奇数个，最后异或结果就是这种数，再将 这种数与两种数异或的结果进行异或就得到了另一种数。\n```java\n public static void printOddTimesNum2(int[]arr){\n        int eor=0;\n        for (int cur:arr){\n            eor ^=cur;\n        }\n        //eor=a^b\n        //eor!=0\n        //eor必定有一位不为0\n        int rightOne=eor & (~eor +1);//提取最右侧为1的数  ~eor取反\n        int onlyOne=0;\n        for (int cur:arr){\n            if ((cur & rightOne)==0){\n                onlyOne ^=cur;\n            }\n        }\n        System.out.println(onlyOne+\" \"+(eor ^onlyOne));\n    }\n```\n\n# 总结\n本文简单的介绍了复杂度和几种简单排序算法以及位运算的基本使用。\n","tags":["算法","数据结构","排序算法","复杂度","选择排序","冒泡排序","插入排序"],"categories":["算法","数据结构和算法"]},{"title":"两数之和II-输入有序数组","url":"/2022/09/10/两数之和II-输入有序数组/","content":"\n# 问题描述：\n\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n你所设计的解决方案必须只使用常量级的额外空间。\n\n---\n\n# 例子\n\n示例 1：\n\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n示例 2：\n\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n示例 3：\n\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n\n---\n# 提示：\n\n - 2 <= numbers.length <= 3 * 104\n- -1000 <= numbers[i] <= 1000\n- numbers 按 非递减顺序 排列\n- -1000 <= target <= 1000\n- 仅存在一个有效答案\n\n---\n\n\n# 代码实现：\n## 1.双指针：\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n       int left =0;\n       int rigth=numbers.length-1;\n       while(left<rigth){\n           if(numbers[left]+numbers[rigth]==target){\n               return new int []{left+1,rigth+1};\n           }else if(numbers[left]+numbers[rigth]<target){\n               left++;\n           }else rigth--;\n       }\n       return new int[]{};\n    }\n}\n```\n## 2.二分：\n`使用二分时我发现会超时，但是暴力求解不会`\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        for(int i=0;i<numbers.length-1;i++){\n          int left =i+1;\n          int rigth=numbers.length-1;\n          while(left<=rigth){\n               int mid=left+((rigth-left)>>1);\n           if(numbers[mid]==target-numbers[i])return new int[]{i+1,mid+1};\n           else if (numbers[mid] > target - numbers[i]){\n              rigth=mid-1; \n           }\n           else rigth=mid+1;\n           }\n        }\n       return new int[]{-1,-1};\n    }\n}\n\n```\n\n## 3.暴力求解\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int temp2[]=new int[2];\n        for(int i=0;i<numbers.length;i++){\n            int temp=target-numbers[i];\n            for(int j=i+1;j<numbers.length;j++){\n               if(numbers[j]==temp){\n                   temp2[0]=i+1;\n                   temp2[1]=j+1;\n                   return temp2;\n               }\n            }\n        }\n        return temp2;\n    }\n}\n\n```\n\n---\n题目来源：力扣（LeetCode）\n链接: [LeetCode题目](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)\n","tags":["算法","数组","简单","offer","力扣"],"categories":["力扣","整数"]},{"title":"一些JS的插件库","url":"/2022/09/10/js插件库/","content":"\n1、[airbnb](https://github.com/airbnb)/[lottie-web](https://github.com/airbnb/lottie-web)*\n\n一个可以从Adobe After Effects中创建的动画直接导出到你的网站。\n\n适用于Lottie for Web，[Android](https://github.com/airbnb/lottie-android)，[iOS](https://github.com/airbnb/lottie-ios)，[React Native](https://github.com/airbnb/lottie-react-native)和[Windows。](https://aka.ms/lottie)\n\n例子：\n\n![Example4.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example4.gif?raw=true)\n\n![Example2.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Example2.gif?raw=true)\n\n\n\n![Community 2_3.gif](https://github.com/airbnb/lottie-web/blob/master/gifs/Community%202_3.gif?raw=true)\n\n2、[wagerfield](https://github.com/wagerfield)/**[parallax](https://github.com/wagerfield/parallax)**\n\n一个轻量级视差渲染JS库，可以创建视察效果，用鼠标来控制，还可以调整物体移动速度。\n\n示例网站：[parallax.js (wagerfield.com)](http://matthew.wagerfield.com/parallax/)\n\n\n\n3、[e-oj](https://github.com/e-oj)/**[Magic-Grid](https://github.com/e-oj/Magic-Grid)**\n\n一个简单、轻量级的 Javascript 库，用于动态网格布局\n\n效果：\n\n![Magic-Gridv](http://imgconvert.csdnimg.cn/aHR0cHM6Ly92dWVqc2V4YW1wbGVzLmNvbS9jb250ZW50L2ltYWdlcy8yMDE5LzAxL01hZ2ljLUdyaWR2LmdpZg)\n\n\n\n4、[webslides](https://github.com/webslides)/**[WebSlides](https://github.com/webslides/WebSlides)**\n\n以漂亮的方式制作HTML演示文稿\n\n演示网站：https://webslides.tv/demos.\n\n\n\n5、[svgdotjs](https://github.com/svgdotjs)/**[svg.js](https://github.com/svgdotjs/svg.js)**\n\n用于操作 SVG 和制作动画的轻量级库，无需任何依赖项。\n\n\n\n6、[dixonandmoe](https://github.com/dixonandmoe)/**[rellax](https://github.com/dixonandmoe/rellax)**\n\n是一个超轻量级，JavaScript视差库。Rellax 现在可以在移动设备上工作 \n\n效果网站：[Demo Website](https://dixonandmoe.com/rellax/)\n\n\n\n7、[Dynamics.js (dynamicsjs.com)](http://dynamicsjs.com/)\n\n用于创建基于物理的动画\n\n\n\n\n\n8、[mojs](https://github.com/mojs)/**[mojs](https://github.com/mojs/mojs)**\n\n用于 Web 的运动图形工具\n\n演示网址：[mo.js](https://mojs.github.io/)\n\n\n\n9、[metafizzy](https://github.com/metafizzy)/**[zdog](https://github.com/metafizzy/zdog)**\n\n圆形，平面，设计师友好的伪3D引擎，用于canvas和SVG\n\n官网：[Zdog · Round, flat, designer-friendly pseudo-3D engine for canvas and SVG (zzz.dog)](https://zzz.dog/)\n\n\n\n10、[leader-line-vue](https://www.npmjs.com/package/leader-line-vue)\n\n用来画引导线:\n\n![前020](https://raw.githubusercontent.com/anseki/leader-line/HEAD/img/ex-020.gif)\n","tags":["前端","JS","插件"],"categories":["JS","前端"]},{"title":"Vue的生命周期，各个组件间的执行情况","url":"/2022/09/10/Vue生命周期及各组件间的执行情况/","content":"\n\n\n---\n\n# 前言\n\n\nVue的生命周期，各个组件间的执行情况。\n`注：本文是以Vue2.x版本展开叙述`\n\n\n---\n\n\n# 一、Vue的生命周期是什么？\nVue的组件都是独立存在的，每个组件都要经历他自己的`生命周期`。Vue的生命周期是指组件：\n**创建**--->**数据初始化**--->**挂载**--->**更新**--->**销毁**\n简单的来说就是组件从创建到销毁之间的过程\n\n\n# 二、Vue生命周期中具体过程\n## 1.Vue生命周期中的函数\n**生命周期钩子**也叫**生命周期函数**也叫**生命周期事件**，vue中他自己携带了八个生命周期函数，如下：\n### 创建Vue实例期阶段：\n\n - **beforeCreate：**\n 实例刚在内存中被创建出来，此时，还没有初始化完成data和methods属性。\n\n- **created：**\n实例已经在内存中创建完成，此时data和menthods以及创建完成，但没有开始编译模板。\n- **beforeMount：**\n此时完成了模板的编译，但没有进行挂载。\n- **mounted：**\n此时已经完成挂载到指定容器中显示了。\n### 运行阶段：\n- **beforeUpdate：**\n状态更新之前调用此函数，此时data中的状态值是最新的，但在界面上并没有得到更新，还没有开始重新渲染DOM节点。\n- **updated：**\n实例更新完成后调用此函数，此时以及重新渲染好DOM节点，界面显示数据也是最新的。\n### 销毁阶段：\n- **beforeDestroy：**\n实例 销毁前调用的函数，此时，实力还是完全可用的。\n- **destroyed：**\n实例销毁后调用，实例锁指示的所有东西都将解绑，所有监听器将移除，所有子实例也将销毁。\n>生命周期流程图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/27c2330b888345dba3fec82144bb8306.png#pic_center)\n\n\n>代码演示：\n\n```c\n var app = new Vue({\n        el: \"#app\",\n        data: {\n            message: \"Hello Vue!\"\n        },\n        methods: {\n            changeMessage() {\n                this.message='改变了！'\n            }\n        },\n        beforeCreate() {\n            console.log(\"---------- 初始化前 beforeCreate-----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n            \n        },\n        created() {\n            console.log(\"---------- 初始化完成 created----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeMount() {\n            console.log(\"---------- 挂载前 beforeMount----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        mounted() {\n            console.log(\"---------- 挂载完成 mounted----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        beforeUpdate() {\n            console.log(\"---------- 更新前 beforeUpdate----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        },\n        updated() {\n            console.log(\"---------- 更新完成 updated----------\");\n            this.message===undefined?console.log('message没拿到'):console.log(this.message);\n            this.$el===undefined?console.log('el没拿到'):console.log(this.$el);\n        }\n    });\n```\n>创建阶段运行结果：\n>\n![](https://img-blog.csdnimg.cn/d3c052cebaad48329c13c55b72f25f23.png)\n**可以看到首次加载只会运行前四个周期函数，在挂载前才能拿到el属性，如果要操作DOM节点最早在挂在完成 mounted中操作。**\n>运行阶段运行结果：\n>\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b1907c6374949568f14cccd17df1bbe.png)\n## 2.加入keep-alive后\n### 1）keep-alive的认识：\n\n是vue自带的内部组件，是用**来缓存组件**的，达到**提升性能**的目的。\n当使用keep-alive后会增加两个生命周期函数：\n- activated\n在 **keep-alive 组件激活**时调用， 该钩子函数在**服务器端渲染期间**不被调用。\n承担原来**created**钩子中获取数据的任务\n在第一次进入keep-alive包裹的组件时，会调用 beforeCreate、created、beforeMount、mounted、activated；这五个生命周期函数。\n当第二次或第n次进入时只会调用activated\n\n- deactivated\n在 keep-alive 组件停用时调用，该钩子在服务器端渲染期间不被调用。\n\n### 2）keep-alive的用法：\nProps有三个include、exclude、max。\n  - include\n  使用字符串或者正则表达式，匹配的组件才会被缓存\n  - exclude\n  使用字符串或者正则表达式，匹配的组件都不会被缓存\n  - max\n  以数字的形式记录可以缓存多少个组件实例，到达这个值后再次缓存时将销毁最久未使用的组件实例。\n\n# 各组件间的执行情况\n## 1.加载渲染过程\n\n>过程：\n>**父组件beforeCreate** --> **父组件created** --> **父组件beforeMount** --> **子组件beforeCreate** --> **子组件created** --> **子组件beforeMount** --> **子组件mounted** --> **父组件mounted**\n## 2.子组件更新过程\n>过程：\n> **子组件beforeUpdate**  -->  **子组件updated**  \n## 3.父组件更新过程\n>**父组件beforeUpdate**  -->  **父组件updated**\n## 4.组件销毁过程\n>**父组件beforeDestroy** --> **子组件beforeDestroy** --> **子组件destroyed** --> **父组件destroyed**\n## 5.过程演示\n> 父组件代码\n\n```javascript\n<template>\n  <div style=\"border: 2px #1E1E1E; height: 500px;width: 500px;background-color: blueviolet; text-align: center\">\n    <span>{{message}}</span>\n    <button @click=\"changef\" >父组件改变</button>\n    <Son></Son>\n    <button @click=\"destroy\">点击销毁</button>\n  </div>\n</template>\n\n<script>\nimport Son from './components/Son.vue'\n\nexport default {\n  name: 'App',\n  components: {\n    Son\n  },\n  data() {\n    return {\n      message: \"父组件\"\n    }\n  },\n  methods: {\n    changef(){\n      this.message='父组件改变了'\n    },\n    destroy(){\n      this.$destroy();\n      console.log('销毁完成');\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 父组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 父组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 父组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 父组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 父组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 父组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 父组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 父组件销毁后 destroyed----------')\n  }\n}\n</script>\n\n```\n> 子组件代码\n\n```javascript\n<template>\n  <div>\n    <div style=\"border: 2px #1E1E1E; height: 200px;width:200px;background-color: aqua;\">\n      <span>{{message}}</span>\n      <button @click=\"changes\">子组件改变</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  // eslint-disable-next-line vue/multi-word-component-names\n  name: 'Son',\n  props: {\n\n  },\n  data() {\n    return {\n      message: \"子组件\"\n    }\n  },\n  methods: {\n    changes(){\n      this.message='子组件改变了'\n    }\n  },\n  beforeCreate() {\n    console.log(\"---------- 子组件初始化前 beforeCreate-----------\");\n\n\n  },\n  created() {\n    console.log(\"---------- 子组件初始化完成 created----------\");\n\n  },\n  beforeMount() {\n    console.log(\"---------- 子组件挂载前 beforeMount----------\");\n\n  },\n  mounted() {\n    console.log(\"---------- 子组件挂载完成 mounted----------\");\n\n  },\n  beforeUpdate() {\n    console.log(\"---------- 子组件更新前 beforeUpdate----------\");\n  },\n  updated() {\n    console.log(\"---------- 子组件更新完成 updated----------\");\n  },\n  beforeDestroy(){\n    console.log('---------- 子组件销毁前 beforeDestroy----------');\n  },\n  destroyed(){\n    console.log('---------- 子组件销毁后 destroyed----------')\n  }\n}\n</script>\n```\n\n>加载渲染：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1e0fc120774141659a13fc399163e525.png)\n\n>更新阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/1dbd838712ba4a6cbbb50f8b26c45ef9.png)\n\n>销毁阶段：\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/11c316d9bff44e798c70517f11209b53.png)\n# 总结\n - 生命周期：\n   - 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n    -   是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n    -   生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n     -  生命周期函数中的this指向是vm 或 组件实例对象。\n ---\n- 常用的生命周期钩子：\n   -  mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n   - beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n   \n---\n- 关于销毁Vue实例：\n   - 销毁后借助Vue开发者工具看不到任何信息。\n   - 销毁后自定义事件会失效，但原生DOM事件依然有效。\n   - 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n","tags":["Vue","生命周期","组件"],"categories":["Vue","前端"]}]